//Copyright @ 2015 University of Caliafornia, Santa Barbara//The terms under which the software and associated documentation (the Software) is provided are as the following://The Software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions://1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.//Agreed to by //Wei Cao, Kaustav Banerjee//March 18 2015////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////`include "constants.vams"`include "disciplines.vams"module ucsb_2dfet(S,D,Gt,Gb); inout S, D, Gt, Gb;  //external portselectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes//versionparameter real  version  = 1.00     from [0 : inf);//Submodel Control Flagsparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;parameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;parameter integer  Trap     = 1                from [0 : 1];            //interface trap model parameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation modelparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect//General Constantsparameter real  eps  = `P_EPS0           from (0:inf);parameter real  m0   = 9.1e-31           from (0:inf);  //static electron massparameter real  pi   = `M_PI             from (0:inf);  parameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constantparameter real  q    = `P_Q              from (0:inf);  //electron chargeparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage//Structural Parametersparameter real  W      = 1e-6      from (0:inf);  //device widthparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel lengthparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension lengthparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension lengthparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap lengthparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap lengthparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thicknessparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thicknessparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness//Dopingparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formationparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor//Material Parametersparameter real  Eg   = 1.8 * q     from (0:inf);  //band gapparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction bandparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channelparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectricparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectricparameter real  g_s   = 2     from (0:inf);  //spin degeneracyparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction bandparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction bandparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence bandparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x directionparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y directionparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x directionparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y directionparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x directionparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y directionparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valleyparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valleyparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective massparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOSparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOSparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;parameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility//Electrostatics Parametersparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  parameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);parameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length parameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel materialparameter real  dVgb     = Eg / q /2    from (0:inf);//Numerical Setupparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method parameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth functionparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections//Parasiticsparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance parameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitanceparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contactparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contactparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradationparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factorreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; real kesi, kesi_sd;real subSct, subSch, subchS, subchD, subDch, subDct;real supSct, supSch, supchS, supchD, supDch, supDct;real Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;real F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;real F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;real Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;real Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;real Cgt, Cgb, Cgb_S, Cgb_D;real Qgt, Qgb;real Phi, dPhi;real Fvt, Fvb;real Ids;integer k; analog begin  Vsct = V(Sct); Vsch = V(Sch); Vdch = V(Dch);  Vdct = V(Dct); Vgt = V(Gt);  Vgb = V(Gb);  kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2); subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2); supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch; Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess  Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2); supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch; Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q))); Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential if (SDseries == 1)  begin   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess    Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess    Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess    Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess    Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side  end for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel  begin   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);   Phi_chS  = Phi_chS - F_chS / F_chS_prime;     F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);   Phi_chD  = Phi_chD - F_chD / F_chD_prime;   if (SDseries == 1)    begin     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;       F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;       F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;    end  end Cgt = W * L_ch * epsTOX / T_TOX; Cgb = W * L_ch * epsBOX / T_BOX; Cgb_S = W * L_S * epsBOX / T_BOX; Cgb_D = W * L_D * epsBOX / T_BOX; Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);  if (SDseries == 1)  begin  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);  end else  begin  Q_Sct = 0;  Q_Sch = 0;  Q_Dct = 0;  Q_Dch = 0;  end Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb); Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD); if (MobDeg == 1)   begin   Ids = 0;   Phi = Phi_chS;   dPhi = (Phi_chD - Phi_chS) / n_int;           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model    begin     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;     Phi = Phi + dPhi;     end   I(Dch, Sch) <+ Type * Ids;    if (SDseries == 1)     begin     Ids = 0;     Phi = Phi_Sct;     dPhi = (Phi_Sch - Phi_Sct) / n_int;             for (k = 0; k < n_int; k = k + 1)      begin            Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;       Phi = Phi + dPhi;       end     I(Sch, Sct) <+ Type * Ids;     Ids = 0;     Phi = Phi_Dch;     dPhi = (Phi_Dct - Phi_Dch) / n_int;             for (k = 0; k < n_int; k = k + 1)      begin            Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;       Phi = Phi + dPhi;       end     I(Dct, Dch) <+ Type * Ids;     end   else     begin     V(Sch, Sct) <+ 0;     V(Dct, Dch) <+ 0;     end  end else   begin   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);   if (SDseries == 1)    begin     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);    end   else    begin     V(Sch, Sct) <+ 0;     V(Dct, Dch) <+ 0;    end  end I(D, Dct) <+ V(D, Dct) / Rd; I(S, Sct) <+ V(S, Sct) / Rs; I(Dch) <+  ddt(Q_chD); I(Sch) <+  ddt(Q_chS); I(Dch) <+  ddt(Q_Dch); I(Sch) <+  ddt(Q_Sch); I(Dct) <+  ddt(Q_Dct); I(Sct) <+  ddt(Q_Sct); I(Gt) <+  ddt(Qgt); I(Gb) <+  ddt(Qgb);endendmodule