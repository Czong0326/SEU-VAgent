[
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n     Phi = Phi_Dct; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n     Phi = Phi_Dch;\n\n Correction Criteria：Incorrect starting point for numerical integration in the drain extension region. The integration should start at the channel side potential (Phi_Dch) but erroneously starts at the contact side potential (Phi_Dct), reversing the integration direction and corrupting the current calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter integer  SDseries = 1                from [1 : 0];            //insufficient doping effect Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n Correction Criteria：Invalid range [1:0] (high < low) reverses parameter constraints, making all values invalid since 1 > 0. This violates range definition rules and locks SDseries in an undefined state, breaking the doping effect control."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  mx_c1  = 0.0 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\n\n Correction Criteria：Setting electron effective mass (mx_c1) to zero causes division by zero in m_c1 calculation (line 85), leading to invalid density of states (N_DOS) and incorrect electrostatic behavior."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nkesi  = (Vgt - dVgt)/pow(namda_T, 2) - (Vgb - dVgb)/pow(namda_B, 2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nkesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n\n Correction Criteria：Changed '+' to '-' in kesi calculation, reversing the electrostatic coupling effect between top and bottom gates. This violates Poisson's equation integration and corrupts channel potential calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_T, 2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n\n Correction Criteria：Replaced namda_B with namda_T, incorrectly using top-gate natural length scale instead of bottom-gate scale for drain extension region potential calculation. This violates the electrostatic model since drain extensions are only coupled to the bottom gate."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nF_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd - Phi_Sch / pow(namda_B, 2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nF_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n\n Correction Criteria：Changed sign from '+' to '-' for the Phi_Sch term. This inverts the Laplace component in Poisson's equation, disrupting the electrostatic potential calculation for the source extension region."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (supSch * (1 - np) + subSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n Correction Criteria：Swapped 'subSch' and 'supSch' in the second term, eliminating the complementary np/(1-np) logic. This causes incorrect potential calculation for p-type devices by using identical expressions for both terms instead of inverted doping-dependent expressions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nsubchS  = (kesi + q/epsTMD * Nd_pos) * pow(namda, 2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nsubchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n\n Correction Criteria：Replaced channel doping parameter Nd_pre (pre-gate formation) with Nd_pos (post-gate heavy doping). This incorrectly applies S/D extension doping to the channel region, corrupting electrostatic calculations and threshold voltage characteristics."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nIds = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) - Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nIds = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n\n Correction Criteria：Changed '+' to '-' before Nd_pre * T_TMD, incorrectly subtracting doping charge instead of adding it. This violates charge conservation by misrepresenting the fixed charge contribution in the channel current calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre - Nd_pos)) * pow(namda_B, 2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n\n Correction Criteria：Changed the doping term from (Nd_pre + Nd_pos) to (Nd_pre - Nd_pos), incorrectly subtracting the extra doping concentration. This inverts the doping effect in the source extension region, leading to erroneous electrostatic potential calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nI(Sct, Sch) <+ Type * Ids; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nI(Sch, Sct) <+ Type * Ids;\n\n Correction Criteria：Reversed the direction of the current flow in the source extension region. Current should flow from Sch (channel side) to Sct (contact side), but after modification it incorrectly flows from Sct to Sch."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  miu0   = -60e-4                 from (0:inf);  //intrinsic mobility Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n Correction Criteria：Assigned negative mobility value (-60e-4) which violates physical constraints. Mobility must be positive; negative values cause unphysical current inversion and violate the 'from (0:inf)' range declaration."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgt; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb;\n\n Correction Criteria：Declared Vgb as Vgt instead. This causes the bottom gate voltage (Vgb) to share the same variable as the top gate voltage (Vgt), eliminating independent control of the bottom gate and coupling all bottom gate calculations to the top gate potential."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nV(Sch, Dct) <+ 0; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nV(Sch, Sct) <+ 0;\n\n Correction Criteria：Incorrectly connects the source internal node (Sch) to the drain contact node (Dct) instead of the source contact node (Sct), creating an unintended short between source and drain when SDseries is disabled."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal dPhi; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Phi, dPhi;\n\n Correction Criteria：Removed 'Phi' variable declaration, causing it to be undeclared in the numerical integration loops for mobility degradation. This breaks the current calculation when MobDeg=1 since 'Phi' is used as the integration variable."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct_missing; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\n\n Correction Criteria：The variable Smooth_Dct is misspelled as Smooth_Dct_missing in the declaration. This causes Smooth_Dct to be undeclared, breaking the drain contact potential calculation and electrostatic modeling since Smooth_Dct is used in the Newton-Raphson iterations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nPhi_chS  = Phi_chS + F_chS / F_chS_prime; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nPhi_chS  = Phi_chS - F_chS / F_chS_prime;\n\n Correction Criteria：Changed Newton-Raphson iteration from subtraction to addition, causing potential calculation to diverge instead of converge. This violates the fundamental algorithm for finding roots of equations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nIds = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD - Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nIds = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n\n Correction Criteria：Changed '+' to '-' before the thermal diffusion term, reversing the carrier diffusion direction and corrupting current calculation in the channel segment integration."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  mx_c2  = 0.5664 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\n\n Correction Criteria：Assigned incorrect y-direction mass value (my_c1) to x-direction mass parameter (mx_c2), violating physical consistency and altering density of states calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nPhi = Phi - dPhi; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nPhi = Phi + dPhi;\n\n Correction Criteria：The sign error in the potential increment causes reverse integration direction. Instead of progressing from source to drain potential, the calculation moves backward, inverting the channel current direction and corrupting mobility calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nfor (k = 0; k < n_int k = k + 1) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nfor (k = 0; k < n_int; k = k + 1)\n\n Correction Criteria：Missing semicolon between condition and increment in for loop"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  g_c2  = 6     from (0:inf;  //valley degeneracy of the second lowest valley in the conduction band Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\n\n Correction Criteria：Missing closing parenthesis in range expression. The correct form requires balanced parentheses around '0:inf'."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n     Phi = Phi_Dch Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n     Phi = Phi_Dch;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  miu0   = 60e-4                 from (0:inf)  //intrinsic mobility Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n Correction Criteria：Missing semicolon at end of parameter declaration. VerilogA requires semicolons to terminate parameter statements."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n     Phi = Phi + dPhi:  Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n     Phi = Phi + dPhi; \n\n Correction Criteria：Replaced terminating semicolon with colon, which is invalid statement termination in VerilogA"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf;  //fringing bottom capacitance Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\n\n Correction Criteria：Missing closing parenthesis ')' in range constraint. The range should end with ')' to denote exclusive infinity, but it was replaced by ';' which is invalid syntax."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   Phi_chD  = (supchD * (1 - np) + subchD * np) Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n Correction Criteria：Missing multiplication operator between the first parenthesized expression and 'Smooth_chD"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch Smooth_Dct; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\n\n Correction Criteria：Missing comma between variables Smooth_Dch and Smooth_Dct in the declaration list"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   if (SDseries == 1 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   if (SDseries == 1)\n\n Correction Criteria：Missing closing parenthesis for conditional expression"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter integer  iter     = 10     from [1 : inf];  //# of iteration in Newton-Raphson method Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method\n\n Correction Criteria：Mismatched range delimiter: Used closing square bracket ']' instead of required closing parenthesis ')' for exclusive upper bound in range constraint."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nF_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nF_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n\n Correction Criteria：Missing semicolon at end of statement, which is required to terminate Verilog-A assignments"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n Correction Criteria：Unmatched parentheses: Missing closing parenthesis for the second term after 'supDct * np', causing unbalanced parentheses in the expression."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   if (MobDeg == 1 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   if (MobDeg == 1)\n\n Correction Criteria：Missing closing parenthesis for the condition statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n I(S, Sct) < V(S, Sct) / Rs; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n Correction Criteria：Missing '+' in contribution operator: '<' is invalid without the '+', must use '<+' for analog operator contributions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Vsct, Vdct, Vsch, Vdch, Vgt Vgb; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb;\n\n Correction Criteria：Missing comma between 'Vgt' and 'Vgb' in variable declaration list causes syntax error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nI(Sch) <+  ddt(Q_Sch) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nI(Sch) <+  ddt(Q_Sch);\n\n Correction Criteria：Missing semicolon at end of statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nQgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos * T_TMD; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nQgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n Correction Criteria：Missing closing parenthesis for the second term in the expression. The opening parenthesis before 'Nd_pre' in the second subtraction is never properly closed."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD) + Vdch; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n\n Correction Criteria：Mismatched parentheses in ln() function call - missing closing parenthesis for ln argument"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n I(S, Sct) <+ V(S, Sct) / Rs Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n Correction Criteria：Missing semicolon at the end of the contribution statement, causing syntax error in VerilogA analog block."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//Copyright @ 2015 University of Caliafornia, Santa Barbara\n\n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n\n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n\n//The authors or copyright holders grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n\n//1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.\n\n//2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n\n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n\n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n//Agreed to by \n//Wei Cao, Kaustav Banerjee\n//March 18 2015\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule ucsb_2dfet(S,D,Gt,Gb); \n\ninout S, D, Gt, Gb;  //external ports\nelectrical S, D, Sch, Dch, Sct, Dct, Gt, Gb; //all nodes\n\n//version\nparameter real  version  = 1.00     from [0 : inf);\n\n//Submodel Control Flags\nparameter integer  Type     = -1               from [-1 : 1] exclude 0; //type of FET, n-type = 1; p-type = -1;\nparameter integer  np       = (1 - Type) / 2   from [0 : 1];            //a selection index, n-type = 0; p-type = 1;\nparameter integer  Trap     = 1                from [0 : 1];            //interface trap model \nparameter integer  MobDeg   = 1                from [0 : 1];            //mobility degradation model\nparameter integer  SDseries = 1                from [0 : 1];            //insufficient doping effect\n\n//General Constants\nparameter real  eps  = `P_EPS0           from (0:inf);\nparameter real  m0   = 9.1e-31           from (0:inf);  //static electron mass\nparameter real  pi   = `M_PI             from (0:inf);  \nparameter real  h_   = `P_H / (2 * pi)   from (0:inf);  //reduced Planck constant\nparameter real  q    = `P_Q              from (0:inf);  //electron charge\nparameter real  kT   = 0.0259 * q        from (0:inf);  //thermal voltage\n\n\n//Structural Parameters\nparameter real  W      = 1e-6      from (0:inf);  //device width\nparameter real  L_ch   = 1e-6      from (0:inf);  //effective channel length\nparameter real  L_S    = 0.5e-6    from (0:inf);  //source extension length\nparameter real  L_D    = 0.5e-6    from (0:inf);  //drain extension length\nparameter real  L_SOL  = 3e-9      from [0:inf);  //source-channel overlap length\nparameter real  L_DOL  = 3e-9      from [0:inf);  //drain-channel overlap length\nparameter real  T_TMD  = 0.65e-9   from (0:inf);  //channel thickness\nparameter real  T_TOX  = 2e-9      from (0:inf);  //top gate dielectric thickness\nparameter real  T_BOX  = 20e-9     from (0:inf);  //bottom gate dielectric thickness\n\n//Doping\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\nparameter real  Nd_pos  = Type * 1e26     from (-inf:inf); //extral doping after gate formation, i.e. in the source/drain extenstion regions, 'm-3' positive: donor negative: acceptor\n\n//Material Parameters\nparameter real  Eg   = 1.8 * q     from (0:inf);  //band gap\nparameter real  dEc  = 0.05 * q    from (0:inf);  //energy difference between the lowest and second lowest valley in the conduction band\n\nparameter real  epsTMD  = 4.8 * eps     from (0:inf);  //dielectric permitivity of channel\nparameter real  epsTOX  = 20 * eps      from (0:inf);  //dielectric permitivity of top gate dielectric\nparameter real  epsBOX  = 3.9 * eps     from (0:inf);  //dielectric permitivity of bottom gate dielectric\n\nparameter real  g_s   = 2     from (0:inf);  //spin degeneracy\nparameter real  g_c1  = 2     from (0:inf);  //valley degeneracy of the lowest valley in the conduction band\nparameter real  g_c2  = 6     from (0:inf);  //valley degeneracy of the second lowest valley in the conduction band\nparameter real  g_v   = 2     from (0:inf);  //valley degeneracy of the valence band\n\nparameter real  mx_c1  = 0.5788 * m0           from (0:inf);  //electron effective mass of the lowest valley along x direction\nparameter real  my_c1  = 0.5664 * m0           from (0:inf);  //electron effective mass of the lowest valley along y direction\nparameter real  mx_c2  = 0.5788 * m0           from (0:inf);  //electron effective mass of the second lowest valley along x direction\nparameter real  my_c2  = 0.5644 * m0           from (0:inf);  //electron effective mass of the second lowest valley along y direction\nparameter real  mx_v   = 0.65 * m0             from (0:inf);  //hole effective mass along x direction\nparameter real  my_v   = 0.65 * m0             from (0:inf);  //hole effective mass along y direction\nparameter real  m_c1   = sqrt(mx_c1 * my_c1)   from (0:inf);  //DOS electron effective mass of the lowest valley\nparameter real  m_c2   = sqrt(mx_c2 * my_c2)   from (0:inf);  //DOS electron effective mass of the second lowest valley\nparameter real  m_v    = sqrt(mx_v * my_v)     from (0:inf);  //DOS hole effective mass\nparameter real  N_DOS  = g_s * g_c1 * m_c1 * kT / (2 * pi * h_ * h_) + g_s * g_c2 * m_c2 * kT / (2 * pi * h_ * h_) * exp(- dEc / kT) from (0:inf); //effective electron DOS\nparameter real  P_DOS  = g_s * g_v * m_v * kT / (2 * pi * h_ * h_) from (0:inf); //effective hole DOS\nparameter real  DOS    = (1 - np) * N_DOS + np * P_DOS;\nparameter real  miu0   = 60e-4                 from (0:inf);  //intrinsic mobility\n\n//Electrostatics Parameters\nparameter real  namda_T  = sqrt(T_TOX * T_TMD *epsTMD / epsTOX)  from (0:inf);  \nparameter real  namda_B  = sqrt(T_BOX * T_TMD *epsTMD / epsBOX)  from (0:inf);\nparameter real  namda    = 1/ sqrt(1/ pow(namda_T, 2) + 1/ pow(namda_B, 2)) from (0:inf); //natural scale length \nparameter real  dVgt     = Eg / q /2    from (0:inf);  //flatband voltage plus Ec-Ef of channel material\nparameter real  dVgb     = Eg / q /2    from (0:inf);\n\n//Numerical Setup\nparameter integer  iter     = 10     from [1 : inf);  //# of iteration in Newton-Raphson method \nparameter integer  k_smooth = 10     from [0 : inf);  //abruptness control parameter in smooth function\nparameter integer  n_int    = 100    from [0 : inf);  //# if integration sections\n//Parasitics\nparameter real  Cft  = 0.1 * W * L_ch * epsTOX / T_TOX from [0 : inf);  //fringing top capacitance \nparameter real  Cfb  = 0.1 * W * L_ch * epsBOX / T_BOX from [0 : inf);  //fringing bottom capacitance\nparameter real  Rs  = 1e-6 / W                         from [0 : inf);  //contact resistance at the source contact\nparameter real  Rd  = 1e-6 / W                         from [0 : inf);  //contact resistance at the drain contact\nparameter real  Fcrit  = 7e9                           from [0 : inf);  //critical vertical electric field for mobility degradation\nparameter real  beta  = 1.5                            from [0 : inf);  //mobility degradation fitting power factor\n\nreal Vsct, Vdct, Vsch, Vdch, Vgt, Vgb; \n\nreal kesi, kesi_sd;\nreal subSct, subSch, subchS, subchD, subDch, subDct;\nreal supSct, supSch, supchS, supchD, supDch, supDct;\nreal Smooth_Sct, Smooth_Sch, Smooth_chS, Smooth_chD, Smooth_Dch, Smooth_Dct;\nreal F_Sct, F_Sch, F_chS, F_chD, F_Dch, F_Dct;\nreal F_Sct_prime, F_Sch_prime, F_chS_prime, F_chD_prime, F_Dch_prime, F_Dct_prime;\nreal Phi_Sct, Phi_Sch, Phi_chS, Phi_chD, Phi_Dch, Phi_Dct;\nreal Q_Sct, Q_Sch, Q_chS, Q_chD, Q_Dch, Q_Dct;\nreal Cgt, Cgb, Cgb_S, Cgb_D;\nreal Qgt, Qgb;\nreal Phi, dPhi;\nreal Fvt, Fvb;\nreal Ids;\n\ninteger k; \n\nanalog \nbegin\n \n Vsct = V(Sct);\n Vsch = V(Sch);\n Vdch = V(Dch); \n Vdct = V(Dct);\n Vgt = V(Gt); \n Vgb = V(Gb); \n\n kesi  = (Vgt - dVgt)/pow(namda_T, 2) + (Vgb - dVgb)/pow(namda_B, 2);\n subchS  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchS  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vsch;\n Smooth_chS = 0.5 * (1+ tanh(k_smooth * (subchS - Vsch + Eg/ q * np + 2 * kT / q)));      //smooth function for initial guess \n Phi_chS  = (supchS * (1 - np) + subchS * np) * Smooth_chS + (subchS * (1 - np) + supchS * np) * (1 - Smooth_chS);  //initial guess for source potential\n\n subchD  = (kesi + q/epsTMD * Nd_pre) * pow(namda, 2);\n supchD  = -Eg/ q * np + Type * kT /q * ln(abs((kesi + q / epsTMD * Nd_pre) / q / DOS * epsTMD * T_TMD)) + Vdch;\n Smooth_chD = 0.5 * (1+ tanh(k_smooth * (subchD - Vdch + Eg/ q * np + 2 * kT / q)));\n Phi_chD  = (supchD * (1 - np) + subchD * np) * Smooth_chD + (subchD * (1 - np) + supchD * np) * (1 - Smooth_chD);  //inital guess for drain potential\n\n if (SDseries == 1)\n  begin\n   kesi_sd  = (Vgb - dVgb)/pow(namda_B, 2);\n   subSct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsct;\n   Smooth_Sct = 0.5 * (1+ tanh(k_smooth * (subSct - Vsct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sct  = (supSct * (1 - np) + subSct * np) * Smooth_Sct + (subSct * (1 - np) + supSct * np) * (1 - Smooth_Sct); //inital guess for source extension potenial at the contact side\n\n   subSch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supSch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vsch;\n   Smooth_Sch = 0.5 * (1+ tanh(k_smooth * (subSch - Vsch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Sch  = (supSch * (1 - np) + subSch * np) * Smooth_Sch + (subSch * (1 - np) + supSch * np) * (1 - Smooth_Sch); //initial guess for source extension potential at the channel side\n\n   subDct  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDct  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdct;\n   Smooth_Dct = 0.5 * (1+ tanh(k_smooth * (subDct - Vdct + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dct  = (supDct * (1 - np) + subDct * np) * Smooth_Dct + (subDct * (1 - np) + supDct * np) * (1 - Smooth_Dct); //initial guess for drain extension potential at he contact side\n\n   subDch  = (kesi_sd + q/epsTMD * (Nd_pre + Nd_pos)) * pow(namda_B, 2);\n   supDch  = -Eg/q * np + Type * kT /q * ln(abs((kesi_sd + q / epsTMD * (Nd_pre + Nd_pos)) / q / DOS * epsTMD * T_TMD)) + Vdch;\n   Smooth_Dch = 0.5 * (1+ tanh(k_smooth * (subDch - Vdch + Eg/q * np + 2 * kT / q)));    //smooth function for initial guess \n   Phi_Dch  = (supDch * (1 - np) + subDch * np) * Smooth_Dch + (subDch * (1 - np) + supDch * np) * (1 - Smooth_Dch); //initial guess for drain extension potenial at the chanel side\n  end\n\n for (k=0 ; k<iter +1 ; k=k+1)  //Newton-Raphson method to evaluate potentials at several points along the channel\n  begin\n   F_chS  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chS / pow(namda, 2);\n   F_chS_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chS - Type * Vsch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chS  = Phi_chS - F_chS / F_chS_prime;\n  \n   F_chD  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) - q * Nd_pre / epsTMD - kesi + Phi_chD / pow(namda, 2);\n   F_chD_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_chD - Type * Vdch - Eg/ q * np)) +  1 / pow(namda, 2);\n   Phi_chD  = Phi_chD - F_chD / F_chD_prime;\n\n   if (SDseries == 1)\n    begin\n     F_Sct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sct / pow(namda_B, 2);\n     F_Sct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sct - Type * Vsct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sct  = Phi_Sct - F_Sct / F_Sct_prime;\n  \n     F_Sch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Sch / pow(namda_B, 2);\n     F_Sch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Sch - Type * Vsch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Sch  = Phi_Sch - F_Sch / F_Sch_prime;\n\n     F_Dct  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dct / pow(namda_B, 2);\n     F_Dct_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dct - Type * Vdct -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dct  = Phi_Dct - F_Dct / F_Dct_prime;\n  \n     F_Dch  = Type * q * DOS / epsTMD / T_TMD * exp (q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) - q * (Nd_pre + Nd_pos) / epsTMD - kesi_sd + Phi_Dch / pow(namda_B, 2);\n     F_Dch_prime = q * q * DOS / epsTMD / T_TMD / kT * exp(q/ kT * (Type * Phi_Dch - Type * Vdch -Eg/q * np)) +  1 / pow(namda_B, 2);\n     Phi_Dch  = Phi_Dch - F_Dch / F_Dch_prime;\n    end\n  end\n\n Cgt = W * L_ch * epsTOX / T_TOX;\n Cgb = W * L_ch * epsBOX / T_BOX;\n Cgb_S = W * L_S * epsBOX / T_BOX;\n Cgb_D = W * L_D * epsBOX / T_BOX;\n\n Q_chS = 0.5 * Cgt * V(Sch, Gt) + 0.5 * Cgb * V(Sch, Gb); //a simple constant capacitance model in this version\n Q_chD = 0.5 * Cgt * V(Dch, Gt) + 0.5 * Cgb * V(Dch, Gb);\n \n if (SDseries == 1)\n  begin\n  Q_Sct = 0.5 * Cgb_S * V(Sct, Gb);\n  Q_Sch = 0.5 * Cgb_S * V(Sch, Gb);\n  Q_Dct = 0.5 * Cgb_D * V(Dct, Gb);\n  Q_Dch = 0.5 * Cgb_D * V(Dch, Gb);\n  end\n else\n  begin\n  Q_Sct = 0;\n  Q_Sch = 0;\n  Q_Dct = 0;\n  Q_Dch = 0;\n  end\n\n Qgt = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgt /(Cgt + Cgb);\n Qgb = -(Q_chS + Q_chD - Nd_pre * T_TMD) * Cgb /(Cgt + Cgb) - (Q_Sct + Q_Sch + Q_Dct + Q_Dch -2 * (Nd_pre +Nd_pos) * T_TMD);\n\n if (MobDeg == 1)\n   begin\n   Ids = 0;\n   Phi = Phi_chS;\n   dPhi = (Phi_chD - Phi_chS) / n_int;\n           for (k = 0; k < n_int; k = k + 1)  //numerical integral is used to evaluate current in MobDeg model\n    begin\n     Fvt = epsTOX / epsTMD / T_TOX * abs(Vgt - dVgt -Phi);\n     Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n     Ids = Ids + q * W / L_ch * (epsTMD * T_TMD / q * (kesi - Phi / pow(namda, 2)) + Nd_pre * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda /namda) * miu0 /(1 + pow((Fvt + Fvb)/Fcrit, beta)) * dPhi;\n     Phi = Phi + dPhi; \n    end\n   I(Dch, Sch) <+ Type * Ids;\n \n   if (SDseries == 1) \n    begin\n     Ids = 0;\n     Phi = Phi_Sct;\n     dPhi = (Phi_Sch - Phi_Sct) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_S * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Sch, Sct) <+ Type * Ids;\n\n     Ids = 0;\n     Phi = Phi_Dch;\n     dPhi = (Phi_Dct - Phi_Dch) / n_int;\n             for (k = 0; k < n_int; k = k + 1)\n      begin\n     \n       Fvb = epsBOX / epsTMD / T_BOX * abs(Vgb - dVgb -Phi);\n       Ids = Ids + q * W / L_D * (epsTMD * T_TMD / q * (kesi_sd - Phi / pow(namda_B, 2)) + (Nd_pre + Nd_pos) * T_TMD + Type * kT * epsTMD * T_TMD /q /q /namda_B /namda_B) * miu0 /(1 + pow(Fvb / Fcrit, beta)) * dPhi;\n       Phi = Phi + dPhi; \n      end\n     I(Dct, Dch) <+ Type * Ids;\n \n    end\n   else \n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0; \n    end\n  end\n else \n  begin\n\n   I(Dch, Sch) <+ Type * q * miu0 * W / L_ch * ((T_TMD * epsTMD /q * kesi + Type * T_TMD * epsTMD / q / pow(namda, 2) * kT /q + Nd_pre * T_TMD) * (Phi_chD - Phi_chS) - T_TMD * epsTMD / q / pow(namda, 2) * ( pow(Phi_chD, 2) - pow(Phi_chS, 2) ) / 2);\n\n   if (SDseries == 1)\n    begin\n     I(Sch, Sct) <+ Type * q * miu0 * W / L_S * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Sch - Phi_Sct) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Sch, 2) - pow(Phi_Sct, 2) ) / 2);\n\n     I(Dct, Dch) <+ Type * q * miu0 * W / L_D * ((T_TMD * epsTMD /q * kesi_sd + Type * T_TMD * epsTMD / q / pow(namda_B, 2) * kT /q + (Nd_pre + Nd_pos) * T_TMD) * (Phi_Dct - Phi_Dch) - T_TMD * epsTMD / q / pow(namda_B, 2) * ( pow(Phi_Dct, 2) - pow(Phi_Dch, 2) ) / 2);\n    end\n   else\n    begin\n     V(Sch, Sct) <+ 0;\n     V(Dct, Dch) <+ 0;\n    end\n  end\n\n\n I(D, Dct) <+ V(D, Dct) / Rd;\n I(S, Sct) <+ V(S, Sct) / Rs;\n\n I(Dch) <+  ddt(Q_chD);\n I(Sch) <+  ddt(Q_chS);\n\n I(Dch) <+  ddt(Q_Dch);\n I(Sch) <+  ddt(Q_Sch);\n\n I(Dct) <+  ddt(Q_Dct);\n I(Sct) <+  ddt(Q_Sct);\n\n\n I(Gt) <+  ddt(Qgt);\n I(Gb) <+  ddt(Qgb);\n\nend\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf; //doping concentration before gate formation Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real  Nd_pre  = Type * 1e24     from (-inf:inf); //doping concentration before gate formation\n\n Correction Criteria：Missing closing parenthesis in range constraint. The correct syntax requires parentheses around the range values, but the closing ')' was replaced with a semicolon."
      }
    ]
  }
]