/****************************************************************************************************
Copyright @ 2019 Università di Modena e Reggio Emilia (Italy).

The terms under which the software and associated documentation (the Software) is provided are as the following:

The Software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.

Università di Modena e Reggio Emilia (Italy) grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:

1. The users agree not to charge for the code itself but may charge for additions, extensions, or support.

2. In any product based on the Software, the users agree to acknowledge the Research Group that developed the software. This acknowledgment shall appear in the product documentation.

3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.

4. Redistributions to others of source code must retain the copyright notice, disclaimer, and list of conditions.

5. Redistributions to others in binary form must reproduce the copyright notice, disclaimer, and list of conditions in the documentation and/or other materials provided with the distribution.

Agreed to by 
Francesco Maria Puglisi, Università di Modena e Reggio Emilia (Italy)
May 20, 2019
*********************************************************************/
/********************************************************************
    VerilogA Model for bipolar RRAM devices including variability on RESET and SET and Random Telegraph Noise
        VerilogA Model
         Version 1.0.0
    Authors: F. M. Puglisi, T. Zanotti, P. Pavan    
    Affiliation: DIEF – Università di Modena e Reggio Emilia – Via P. Vivarelli 10/1, 41125 – Modena (MO) – Italy
    
    Reference:
    F. M. Puglisi et al, "Random Telegraph Noise in Resistive Random Access Memories: Compact Modeling and
    Advanced Circuit Design," in IEEE Transactions on Electron Devices, vol. 65, no. 7, pp. 2964-2972, July 2018.
    
    Modified on May 20, 2019 by T. Zanotti
*********************************************************************/

`include "constants.vams"
`include "disciplines.vams"
`include "UNIMORE_RRAM_model_additional_disciplines_1_0_0.va" // Additional natures definitions: the barrier thickness and the temperature require non-standard tolerances during the SET of the device.

module UNIMORE_RRAM_model_1_0_0 (TE, BE);

    inout TE, BE;
    electrical TE, BE, ME, N_noise_x, N_noise_s, N_dvdt;    
    my_temperature n2, n3, n22, n33, gnd_t;    
    my_barrier n1, n11, gnd_b;
    
    /********
     * TE        - Top electrode
     * BE        - Bottom electrode
     * n1        - Barrier thickness internal node 1[V] = 1[nm]
     * n11       - Support node used for barrier thickness initialization 1[V] = 1[nm]
     * n2        - Conductive filament temperature internal node 1[V] = 1[nm]
     * n22       - Support node used for conductive filament temperature initialization 1[V] = 1[K]
     * n3        - Barrier temperature internal node 1[V] = 1[nm]
     * n33       - Support node used for barrier temperature initialization 1[V] = 1[K] 
     * gnd_t     - Internal ground reference for my_temperature discipline 
     * gnd_b     - Internal ground reference for my_barrier discipline
     * N_noise_s - White_noise internal node for CF cross-section variability
     * N_noise_x - White_noise internal node for barrier thickness variability
     * N_dvdt    - Internal node for device voltage time derivative computation
     ********/
    
    (*desc = "Oxide material resistivity", units = "ohm*nm"*)             parameter real rho=3000 from (0:inf);   
    (*desc = "Oxide layer thickness", units = "nm"*)                      parameter real t_ox=12 from (0:inf);  
    (*desc = "Initial conductive filament section", units = "nm^2"*)      parameter real S0=72 from (0:inf);     
    (*desc = "Boltzmann constant", units = "eV/K"*)                       localparam real kb=8.6e-5 from (0:inf);
    (*desc = "Activation Energy TAT", units = "eV"*)                      parameter real Ea=0.12 from [0:inf);   
    (*desc = "Ambient temperature", units = "K"*)                         parameter real T0=300 from [0:inf);     
    (*desc = "Typical tunneling length", units = "nm"*)                   parameter real l=0.42 from (0:inf);    
    (*desc = "HRS current non-linearity factor", units = "V"*)            parameter real V0=0.32 from (0:inf);    
    (*desc = "Resistivity temperature coeff.", units = "1/K"*)            parameter real alpha=0.002 from [0:inf);
    (*desc = "Barrier resistance fitting parameter"*)                     parameter real beta=1e-3 from [0:inf);
    (*desc = "Bond vibration frequency", units="Hz"*)                     parameter real c0=5e13 from [0:inf);    
    (*desc = "Barrier thermal capacity", units = "J/K"*)                  parameter real Cpb=4e-9 from [0:inf);    
    (*desc = "CF thermal capacity", units = "J/K"*)                       parameter real Cpcf=5e-13 from [0:inf); 
    (*desc = "Barrier thermal conductivity", units = "W/K"*)              parameter real kbar=5e-5 from [0:inf);  
    (*desc = "CF thermal conductivity", units = "W/K"*)                   parameter real kcf=1e-6 from [0:inf);   
    (*desc = "Barrier/CF mutual thermal conductivity", units = "W/K"*)    parameter real kex=0 from [0:inf);      
    (*desc = "Diffusion activation energy of oxygen ions ", units = "eV"*)parameter real Ead=4.4 from [0:inf);    
    (*desc = "Field enhancement factor for oxygen ions diffusion", units = "e * nm"*) parameter real g=54 from [0:inf); 
    (*desc = "Field enhancement factor for bond breaking", units = "e * nm"*)    parameter real gg=1.75 from [0:inf);   
    (*desc = "Bond breaking activation energy", units = "eV"*)            parameter real Eag=1.2 from [0:inf);        
    (*desc = "Initial barrier thickness", units = "nm"*)                  parameter real xinit=0 from [0:inf);      
    (*desc = "Initial temperature", units = "K"*)                         parameter real Tinit=300 from [0:inf);    
    (*desc = "Temperature at which RLRS is measured ", units = "K"*)      parameter real Tmeas=300 from [0:inf);    
    (*desc = "Minimum time step (for positive applied voltages)", units = "s"*) parameter real min_time_step_vpos = 100e-15 from [0:inf);
    (*desc = "Minimum time step (for negative applied voltages)", units = "s"*) parameter real min_time_step_vneg = 100e-15 from [0:inf);
    (*desc = "Adaptive time step parameter"*)                             parameter real tstep_param = 1e2;
    (*desc = "RESET curve slope fitting parameter", units="e*nm"*)        parameter real a = 14 from [0:inf); 
    (*desc = "RESET curve curvature fitting parameter"*)                  parameter real b = 0.4 from [0:inf);
    (*desc = "SET event detection threshold on the barrier derivative ", units = "nm/s"*) parameter real th_set = 10; 
    (*desc = "Maximum variation allowed on the barrier thickness (=3sigma)", units = "nm"*) parameter real dx = 0.8 from[0:t_ox];
    (*desc = "Maximum variation allowed on the CF cross-section (=3sigma)", units = "nm^2"*)parameter real ds = 20 from[0:inf);
    (*desc = "CF cross-section at which the measured ds is obtained", units = "nm^2"*)      parameter real S0var = 72 from[0:inf);
    (*desc = "Maximum frequency of the noise for transient noise analysis", units = "nm"*)  parameter real Fmax = 1000 from(0:inf);    
    (*desc = "RESET event detection threshold on the barrier derivative", units = "nm/s"*)parameter real ddt_x_clip_th = 10e-6 from[0:inf);
    localparam real Wnoise_param_x = dx*dx /(9*Fmax) from[0:inf);               //Barrier White_noise power  
    localparam real Wnoise_param_s = ds*ds * S0var*S0var/(9*Fmax) from[0:inf);  //CF cross-section white_noise power
    localparam real max_x_noise_amplitude = dx from[0:t_ox);                    //Barrier noise maximum amplitude 
    localparam real max_s_noise_amplitude = ds * S0var from[0:inf);             //CF cross-section noise maximum amplitude
    
    
    // RTN Parameters
    (*desc = "Initial random seed to account for variability"*)             parameter real rand_seed_ini = 0;       
    (*desc = "Parameter used to switch on the RTN module (0=OFF; 1=ON)"*)   parameter integer RTN_ON = 0 from [0:1];
    (*desc = "Capture and emission times constant", units = "J*m^3/s"*)     parameter real const0 = 4.19e-32;   
    (*desc = "Density of states at the bottom of the conduction band ", units = "1/(J*m^3)"*)    parameter real Nc = 2.42e45;
    (*desc = "Energy barrier for injected electrons", units = "eV"*)        parameter real phi = 2.1; 
    (*desc = "Typical tunneling length (capture)", units = "eV"*)           parameter real lambda_c = 2e-10;
    (*desc = "Typical tunneling length (emission)", units = "eV"*)          parameter real lambda_e = 2e-10;
    (*desc = "Maximum number of defects that can be generated"*)            parameter integer maximum_number_defects = 100; 
    localparam real t_ox_rtn = 1e-9 * t_ox; // oxide thickness in (m)
    (*desc = "Spread of the oxygen ions relaxation energy distribution", units = "eV"*)          parameter real Delta_Erel_O = 0.4;  
    (*desc = "Spread of the oxygen ions thermal ionization energy distribution ", units = "eV"*) parameter real Delta_Et_O = 0.5;
    (*desc = "Spread of the oxygen vacancies relaxation energy distribution", units = "eV"*)     parameter real Delta_Erel_V = 0.4;
    (*desc = "Spread of the oxygen vacancies thermal ionization energy distribution ", units = "eV"*)            parameter real Delta_Et_V = 0.5;
    (*desc = "Mean of the normal distribution associated to the logNormal distribution of the RHRS due to RTN"*) parameter real DeltaR_dist_HRS_mean = -0.693147180559945; // ln(0.5)
    (*desc = "Standard deviation of the normal distribution associated to the logNormal distribution of the RHRS due to RTN"*) parameter real DeltaR_dist_HRS_std = 0.6;
    (*desc = "Standard deviation of the normal distribution of the RLRS due to RTN. For further information see"*)             parameter real DeltaR_dist_LRS_std = 0.3;
    (*desc = "Length of the side of the cubic volume of influence of a defect", units = "m"*) parameter real rt = 1.7e-9;
    (*desc = "Defects density in HRS", units = "m^-3"*)                           parameter real O_ions_density = 1e26;
    (*desc = "Defects density in LRS", units = "m^-3"*)                           parameter real V_density = 2e27;        
    (*desc = "Nominal oxygen ions relaxation energy", units = "eV"*)              parameter real Erel0_O = 2.67;        
    (*desc = "Nominal oxygen ions thermal Ionization energy", units = "eV"*)      parameter real Et0_O = 2.3;           
    (*desc = "Nominal oxygen vacancies relaxation energy ", units = "eV"*)        parameter real Erel0_V = 1.19;        
    (*desc = "Nominal oxygen vacancies thermal ionization energy", units = "eV"*) parameter real Et0_V = 2.1;           
    (*desc = "Threshold on the barrier derivative to randomly re-assign defects positions", units = "m/s"*) parameter real dxdt_th = 1e-10 from [0:inf); 
      
    
    // Model variables    
    real Vtb;               // Voltage across the Top and Bottom electrodes (V) 
    real R_lrs;             // Low Resistive State resistance variable (ohm)
    real Sp;                // Negative voltage flag (1 when Vtb<0, 0 elsewhere)
    real Sn;                // Positive voltage flag (1 when Vtb>=0, 0 elsewhere)
    real barrier;           // Barrier thickness variable (nm)
    real set_v;             // SET event detection variable
    real Tcf;               // CF temperature variable (K)
    real Tbar;              // Barrier temperature variable (K)
    real ddt_Tbar;          // Barrier temperature time derivative (K/s)
    real ddt_Tcf;           // CF temperature time derivative (K/s)
    real ddt_x;             // Barrier thickness time derivative (nm/s)
    real R;                 // Device total resistance variable (ohm)       
    real Rcf;               // CF resistance variable (ohm)
    real Rbar;              // Barrier resistance variable (ohm)
    real Vbar;              // Voltage across the barrier (V)
    real Vcf;               // Voltage across the conductive filament (V)
    real x_b;               // Support variable for barrier thickness time derivative (e*nm)
    real S_var;             // CF cross-section variable (nm^2)
    integer flag_set;       // Activation of variability during a SET event (1 during a SET event, 0 elsewhere)     
    real tstep;             // Time step variable (s)  
    real sig_wn_x, sig_wn_s;// RESET and SET noise variables for variability   
    real ddt_x_clip;        // Clipped dx/dt (1 during a RESET event, 0 elsewhere)
    real II;                 // Output current from RRAM model without RTN (A)
 
    
    // RTN model variables 
    real I_rtn;               // RTN Current contribution (A)
    real x;                   // Barrier thickness value (m)
    integer i;                // for loop cycles variable 
    real N_O;                 // Average number of O ions in vol. x*S
    real N_V;                 // Average number of O vacancies around the CF
    real Erel_O;              // Oxygen ions relaxation energy (eV)
    real Et_O;                // Oxygen ions thermal ionization energy (eV)
    real Erel_V;              // Oxygen vacancies relaxation energy (eV)
    real Et_V;                // Oxygen vacancies thermal ionization energy (eV)
    integer n;                // Number of defects
    real Delta_R;             // Total Resistance Variation due to RTN (ohm)
    real tau;                 // Defect transition time - either tau_e or tau_c, depending on State
    real Srtn;                // CF cross-section in m^2
    real delta_R_ref;         // Delta R offset due to RTN updated after defect position re-initialization. 
    real f_correction;        // RTN defects DeltaR correction factor  
    real ddt_vtb;             // Applied voltage time derivative (V/s) 
    
    //Array Size is the maximum defect number (custom)
    real pos[maximum_number_defects:1];              // Random defect location (distance from the cathode)
    real delta_R[maximum_number_defects:1];          // Resistance variation due to RTN
    real state[maximum_number_defects:1];            // Defect state - empty or filled
    real last_time[maximum_number_defects:1];        // Defect last transition time
    real p[maximum_number_defects:1];                // Probability of Transition
    integer type[maximum_number_defects:1];          // Defect type being generated - 0 (Oxygen Ions) 1 (Oxygen Vacancies)   
    real tau_c[maximum_number_defects:1];            // Defect capture time to bottom electrode
    real tau_e[maximum_number_defects:1];            // Defect emission time to bottom electrode

    //RTN random functions
    integer rtn_rand_seed;
    integer dr_rand_seed;
    integer pos_rand_seed;
    integer trans_rand_seed;
    integer Erel_rand_seed;
    integer Et_rand_seed;
    
    //Branches definition    
    branch (n1, gnd_b) b_a;
    branch (n2, gnd_t) b_b;
    branch (n3, gnd_t) b_c;
    branch (TE,BE) b_TB;
    branch (n1, n11) b_a2;
    branch (n2, n22) b_b2;
    branch (n3, n33) b_c2;
    branch (TE, ME) b_TM;
    branch (ME, BE) b_MB;


    analog begin
        // Network node relationships definition
        VB(b_a2)<+ 0;
        VT(b_b2)<+ 0;
        VT(b_c2)<+ 0;
        V(b_TM)<+ 0; 
        VT(gnd_t)<+ 0; // voltage reference for temperature nature
        VB(gnd_b)<+ 0; // voltage reference for barrier nature
        
        //Set initial conditions        
        @(initial_step) begin                               
            VB(n11, gnd_b)<+ xinit;    // initial barrier thickness
            VT(n22, gnd_t)<+ Tinit;    // initial conductive filament temperature
            VT(n33, gnd_t)<+ Tinit;    // initial barrier temperature
            S_var = S0;                // initial conductive filament section
            ddt_x = 0;                 // Barrier time derivative initialization
            ddt_x_clip=0;
            delta_R_ref = 0;
            // Random seeds initializations
            rtn_rand_seed   = rand_seed_ini;
            dr_rand_seed    = rand_seed_ini;
            pos_rand_seed   = rand_seed_ini;
            trans_rand_seed = rand_seed_ini;
            Erel_rand_seed  = rand_seed_ini;
            Et_rand_seed    = rand_seed_ini;
            // RTN defects initialization
            if(RTN_ON == 1) begin
                Srtn = S0 * 1e-18;
                x = xinit * 1e-9;
                if (x > 0) begin    // RESET defect update
                    N_O = max(0.1,x * Srtn * O_ions_density);   // Avg. Number of O Ions in vol. x*S . The max function prevents errors when the barrier becomes slightly negative. 
                    n = $rdist_poisson(rtn_rand_seed, N_O);     // Number of defects random generation
                    if (n > maximum_number_defects) begin       // limiting the maximum number of defects
                        n = maximum_number_defects;
                    end
                    
                    for(i = 1; i <= n ; i = i+1) begin
                        Erel_O = Erel0_O + $rdist_uniform(Erel_rand_seed,-Delta_Erel_O,Delta_Erel_O);
                        Et_O = Et0_O + $rdist_uniform(Et_rand_seed,-Delta_Et_O,Delta_Et_O);        
                        pos[i] = x*$rdist_uniform(pos_rand_seed,0,1);        
                        delta_R[i] = Rbar*exp($rdist_normal(dr_rand_seed, DeltaR_dist_HRS_mean, DeltaR_dist_HRS_std));     
                        tau_c[i] = 1/(const0 * Nc *exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/x),2)/(4*Erel_O*kb*Tcf))));
                        tau_e[i] = 1/(const0 * Nc *exp(-(x-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                        state[i] = $rdist_uniform(dr_rand_seed,0,1)>0.5; //random initial state
                        last_time[i] = $abstime;
                        p[i] = 0;
                        type[i] = 0;
                        delta_R_ref = delta_R_ref + delta_R[i]*state[i];
                    end
                    for(i = n+1; i <= maximum_number_defects ;i = i + 1) begin
                        pos[i] = 0;
                        delta_R[i] = 0;
                        tau_c[i] = 0;
                        tau_e[i] = 0; 
                        state[i] = 0;
                        last_time[i] = 0;
                        p[i] = 0;
                        type[i] = 0;
                    end
                    if(n>1)begin                        // to prevent divide by 0
                        f_correction = R/delta_R_ref;   // Scaling of defects resistances so that active defects carry II
                        delta_R_ref = R;
                        for(i = 1; i <= n ; i = i+1) begin
                            delta_R[i] = delta_R[i]*f_correction;                        
                        end
                    end    
                end else if (xinit == 0) begin // SET defects update

                        N_V     = max(0.1,t_ox_rtn *`M_PI *(pow((rt),2)+2*rt*sqrt(Srtn/`M_PI))* V_density);//Avg. Number of O Vacancies in vol. t_ox*pi*(r_t^2+2rcf*r_t)
                        n     = $rdist_poisson(rtn_rand_seed, N_V); // Number of defects random generation
                        if (n > maximum_number_defects) begin
                            n = maximum_number_defects;
                        end
                        for(i = 1; i <= n ; i = i + 1) begin
                            if (i % 2 == 0) begin
                                Erel_V         = Erel0_V + $rdist_uniform(Erel_rand_seed,-Delta_Erel_V,Delta_Erel_V);
                                Et_V         = Et0_V + $rdist_uniform(Et_rand_seed,-Delta_Et_V,Delta_Et_V);
                                pos[i]         = t_ox_rtn*$rdist_uniform(pos_rand_seed,0,1);
                                delta_R[i]     = R_lrs * exp($rdist_normal(dr_rand_seed, ln(1/(2+(2*t_ox_rtn*Srtn)/pow((rt),3))), DeltaR_dist_LRS_std)); 
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_V-(Et_V-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_V*kb*Tcf))));
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_V/(4*kb*Tcf)));
                                type[i]     = 1;
                            end else begin
                                Erel_O         = Erel0_O + $rdist_uniform(Erel_rand_seed,-Delta_Erel_O,Delta_Erel_O);
                                Et_O         = Et0_O + $rdist_uniform(Et_rand_seed,-Delta_Et_O,Delta_Et_O);
                                pos[i]         = t_ox_rtn*$rdist_uniform(pos_rand_seed,0,1);
                                delta_R[i]     = R_lrs * exp($rdist_normal(dr_rand_seed, ln(1/(2+(2*t_ox_rtn*Srtn)/pow((rt),3))), DeltaR_dist_LRS_std)); 
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_O*kb*Tcf))));
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                                type[i]     = 0;
                            end
                            state[i] = $rdist_uniform(dr_rand_seed,0,1)>0.5;
                            delta_R_ref = delta_R_ref + delta_R[i]*state[i];
                            last_time[i] = $abstime;
                            p[i] = 0;
                        end
                        for(i = n+1; i <= maximum_number_defects ; i = i + 1) begin
                            pos[i] = 0;
                            delta_R[i] = 0;
                            tau_c[i] = 0;
                            tau_e[i] = 0;
                            state[i] = 0;
                            last_time[i] = 0;
                            p[i] = 0;
                            type[i] = 0;
                        end
                        if(n>1)begin    // to prevent divide by 0
                            f_correction = R/delta_R_ref;
                            delta_R_ref = R;
                            for(i = 1; i <= n ; i = i+1) begin
                                delta_R[i] = delta_R[i]*f_correction;                        
                            end
                        end
                end  
            end            
        end

        //Differential equations auxiliary functions        
        Sp=-ceil((floor(V(b_TB)/(abs(V(b_TB))+10e-25))-1)/2); // Sp = 1 when Vtb < 0 else Sp = 0
        Sn = 1 - Sp; // Sn = 1 when Vtb >= 0 else Sn = 0        
        
        //Bound step computation
        tstep = (0.1/(1e-1+abs(ddt_x*tstep_param)));
        $bound_step(max(tstep, Sp * min_time_step_vneg + Sn * min_time_step_vpos)); //trick used to dynamically increase the time resolution on demand
            
        // RESET variability
        V(N_noise_x) <+ white_noise(Wnoise_param_x);
        Vtb = V(b_TB);
        V(N_dvdt) <+ Sp*1e-11*ddt(Vtb); // The factor 1e-11 is used to avoid derivative value explosion
        ddt_vtb = V(N_dvdt);
        
        if(abs(ddt_x) > ddt_x_clip_th) begin   // ddt_x_clip remains = 1 as long as the RESET event has not ended
            ddt_x_clip =  1;
        end else if((ddt_x_clip == 1)&&(ddt_vtb<0)) begin
            ddt_x_clip =  1;
        end else begin
            ddt_x_clip = 0;
        end
        
        sig_wn_x = Sp * V(N_noise_x) * ddt_x_clip;
        sig_wn_x = abs(sig_wn_x)> max_x_noise_amplitude ? max_x_noise_amplitude*sig_wn_x/abs(sig_wn_x) : sig_wn_x; 
        
        //Variables update
        barrier = VB(b_a)+sig_wn_x;
        Tcf = VT(b_b);
        Tbar = VT(b_c);                
        R_lrs = rho*(t_ox/S_var);    
        Rbar = (beta*R_lrs*(exp(barrier/l)-1)*exp(Ea/(kb*(Tbar+1e-15))));
        Rcf = (R_lrs*(t_ox-barrier)/t_ox)*(1+alpha*(Tcf-Tmeas));
        R = Rbar + Rcf;
        Vbar = Vtb * (Rbar/(0.5*exp(abs(Vtb)/V0))) / (Rcf + Rbar/(0.5*exp(abs(Vtb)/V0)));
        Vcf = Vtb * Rcf / (Rcf + Rbar/(0.5*exp(abs(Vtb)/V0)));
        
        // SET event detection
        // The detection is caused by the crossing of a threshold (th_set) by the barrier time derivative 
        flag_set = 0;
        @(cross( -ddt_x - th_set,-1 )) flag_set=1;
        
        // SET Variability update
        // At the SET event instant, the conductive filament cross section is varied randomly  
        V(N_noise_s) <+ white_noise(Wnoise_param_s);
        sig_wn_s = Sn * V(N_noise_s);
        sig_wn_s = abs(sig_wn_s)> max_s_noise_amplitude ? max_s_noise_amplitude*sig_wn_s/abs(sig_wn_s) : sig_wn_s;
        S_var = flag_set == 1 ? S0 + sig_wn_s/S0 : S_var;     
        
        // Set of differential equations        
        x_b = a*pow(barrier,b);            
        ddt_x = (Sp*(c0*(exp(-(Ead+(g-x_b)*Vtb/t_ox)/(kb*(Tcf+1e-15))) ))-Sn*barrier*c0*(exp(-(Eag-gg*Vbar/(barrier+0.0001))/(kb*(Tcf+1e-15))))); 
        
        IB(b_a)<+ ddt_x; 
        IB(b_a)<+ ddt(-VB(b_a));    
        
        ddt_Tcf = (1/Cpcf)*(Rcf * Vtb*Vtb/((Rcf + Rbar / (0.5*exp(abs(Vtb)/V0)))*(Rcf + Rbar / (0.5*exp(abs(Vtb)/V0)))) - kcf * (Tcf-T0)-kex*(Tcf-Tbar));
        IT(b_b)<+ ddt_Tcf;
        IT(b_b)<+ ddt(-Tcf);        
        
        ddt_Tbar = (1/Cpb)*((Rbar/(0.5*exp(abs(Vtb)/V0))) * Vtb*Vtb/((Rcf + Rbar / (0.5*exp(abs(Vtb)/V0)))*(Rcf + Rbar / (0.5*exp(abs(Vtb)/V0)))) - kbar * (Tbar-T0)-kex*(Tbar-Tcf));
        IT(b_c)<+ ddt_Tbar;
        IT(b_c)<+ ddt(-Tbar);
                
        // Output current update                    
        II = V0*sinh(Vtb/V0)/R;
        I(b_MB)<+ II;                
        
        /*******************************
         * RTN section
         *******************************/
        if ((RTN_ON == 1) && analysis("tran")) begin
        // Scaling of the inputs from the RRAM model
            x = barrier*1e-9;   // (nm) => (m)
            Srtn = S_var*1e-18; // (nm^2) => (m^2)
            
            // When the barrier thickness is changing, a random number of defects is generated.
            //
            // During a RESET event, the oxygen ions defects are randomly distributed along the barrier length. Each defect is assigned randomly distributed 
            // relaxation and thermal ionization energies (which are used to compute their respective capture and emission times) and a randomly distributed resistance    
            // variation caused by the defects. 
            //
            // During a SET event, the same procedure used for the RESET event is followed although considering both oxygen ions and oxygen vacancy defects.
                        
            if (abs(ddt_x*1e-9) > dxdt_th) begin
                delta_R_ref = 0;
                if (x > 1e-10) begin    // RESET defect update
                    N_O = max(0.1,x * Srtn * O_ions_density);// Avg. Number of O Ions in vol. x*S . The max function prevents errors when the barrier becomes slightly negative. 
                    n = $rdist_poisson(rtn_rand_seed, N_O); // Number of defects random generation
                    if (n > maximum_number_defects) begin // limiting the maximum number of defects
                        n = maximum_number_defects;
                    end
                    
                    for(i = 1; i <= n ; i = i+1) begin
                        Erel_O = Erel0_O + $rdist_uniform(Erel_rand_seed,-Delta_Erel_O,Delta_Erel_O);
                        Et_O = Et0_O + $rdist_uniform(Et_rand_seed,-Delta_Et_O,Delta_Et_O);        
                        pos[i] = x*$rdist_uniform(pos_rand_seed,0,1);        
                        delta_R[i] = Rbar*exp($rdist_normal(dr_rand_seed, DeltaR_dist_HRS_mean, DeltaR_dist_HRS_std));
                        tau_c[i] = 1/(const0 * Nc *exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/x),2)/(4*Erel_O*kb*Tcf))));                        
                        tau_e[i] = 1/(const0 * Nc *exp(-(x-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                        state[i] = $rdist_uniform(dr_rand_seed,0,1)>0.5; //random initial state
                        last_time[i] = $abstime;
                        p[i] = 0;
                        type[i] = 0;
                        delta_R_ref = delta_R_ref + delta_R[i]*state[i];
                    end
                    for(i = n+1; i <= maximum_number_defects ;i = i + 1) begin
                        pos[i] = 0;
                        delta_R[i] = 0;
                        tau_c[i] = 0;
                        tau_e[i] = 0; 
                        state[i] = 0;
                        last_time[i] = 0;
                        p[i] = 0;
                        type[i] = 0;
                    end
                    if(n>1)begin      // to prevent divide by 0
                        f_correction = R/delta_R_ref;
                        delta_R_ref = R;
                        for(i = 1; i <= n ; i = i+1) begin
                            delta_R[i] = delta_R[i]*f_correction;                        
                        end
                    end
                end else if (x <= 1e-10) begin // SET defects update

                        N_V     = max(0.1,t_ox_rtn *`M_PI *(pow((rt),2)+2*rt*sqrt(Srtn/`M_PI))* V_density);        //Avg. Number of O Vacancies in vol. t_ox*pi*(r_t^2+2rcf*r_t)
                        n     = $rdist_poisson(rtn_rand_seed, N_V); // Number of defects random generation
                        if (n > maximum_number_defects) begin
                            n = maximum_number_defects;
                        end
                        for(i = 1; i <= n ; i = i + 1) begin
                            if (i % 2 == 0) begin
                                Erel_V         = Erel0_V + $rdist_uniform(Erel_rand_seed,-Delta_Erel_V,Delta_Erel_V);
                                Et_V         = Et0_V + $rdist_uniform(Et_rand_seed,-Delta_Et_V,Delta_Et_V);
                                pos[i]         = t_ox_rtn*$rdist_uniform(pos_rand_seed,0,1);
                                delta_R[i]     = R_lrs * exp($rdist_normal(dr_rand_seed, ln(1/(2+(2*t_ox_rtn*Srtn)/pow((rt),3))), DeltaR_dist_LRS_std));
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_V-(Et_V-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_V*kb*Tcf))));                                
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_V/(4*kb*Tcf)));
                                type[i]     = 1;
                            end else begin
                                Erel_O         = Erel0_O + $rdist_uniform(Erel_rand_seed,-Delta_Erel_O,Delta_Erel_O);
                                Et_O         = Et0_O + $rdist_uniform(Et_rand_seed,-Delta_Et_O,Delta_Et_O);
                                pos[i]         = t_ox_rtn*$rdist_uniform(pos_rand_seed,0,1);
                                delta_R[i]     = R_lrs * exp($rdist_normal(dr_rand_seed, ln(1/(2+(2*t_ox_rtn*Srtn)/pow((rt),3))), DeltaR_dist_LRS_std)); 
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_O*kb*Tcf))));                            
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                                type[i]     = 0;
                            end
                            state[i] = $rdist_uniform(dr_rand_seed,0,1)>0.5;
                            delta_R_ref = delta_R_ref + delta_R[i]*state[i];
                            last_time[i] = $abstime;
                            p[i] = 0;
                        end
                        for(i = n+1; i <= maximum_number_defects ; i = i + 1) begin
                            pos[i] = 0;
                            delta_R[i] = 0;
                            tau_c[i] = 0;
                            tau_e[i] = 0;
                            state[i] = 0;
                            last_time[i] = 0;
                            p[i] = 0;
                            type[i] = 0;
                        end
                        if(n>1)begin  // to prevent divide by 0
                            f_correction = R/delta_R_ref;
                            delta_R_ref = R;
                            for(i = 1; i <= n ; i = i+1) begin
                                delta_R[i] = delta_R[i]*f_correction;                        
                            end
                        end
                end
            end else begin // Defects' capture and emission times update due to voltage and/or temperature variations
                
                if (x > 1e-10) begin // Device in HRS
                    for(i = 1; i <= n ; i = i+1) begin           
                        tau_c[i] = 1/(const0 * Nc *exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/x),2)/(4*Erel_O*kb*Tcf))));                    
                        tau_e[i] = 1/(const0 * Nc *exp(-(x-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                    end
                    
                end else begin  // Device in LRS                
                    for(i = 1; i <= n ; i = i + 1) begin
                            if (i % 2 == 0) begin 
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_V-(Et_V-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_V*kb*Tcf))));
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_V/(4*kb*Tcf)));
                            end else begin 
                                tau_c[i] = 1/(const0 * Nc * exp(-pos[i]/lambda_c)*exp(-(pow(Erel_O-(Et_O-phi+Vtb*pos[i]/t_ox_rtn),2)/(4*Erel_O*kb*Tcf))));                                
                                tau_e[i] = 1/(const0 * Nc * exp(-(t_ox_rtn-pos[i])/lambda_e)*exp(-Erel_O/(4*kb*Tcf)));
                            end
                    
                        end
                end
            
            
            end

            // RTN Waveform formation, Transition Management
            // Each defect is randomly activated or de-activated in relation to its last transition time and capture and emission times.
            // When a defect is active, it does not contribute to the current, thus its resistance contributions is accumulated in the variable Delta_R.
            
            Delta_R = 0;
            for(i = 1; i <= n; i = i + 1) begin
                if (state[i] == 0) begin        
                    tau = tau_c[i];                
                end else begin
                    tau=tau_e[i];
                end
                p[i] = 1 - exp(-($abstime - last_time[i])/tau); // Transition probability
                
                if (p[i] > $rdist_uniform(trans_rand_seed,0,1)) begin
                    last_time[i] = $abstime;
                    if (state[i] == 0) begin
                        state[i] = 1;
                    end else begin
                        state[i] = 0;
                    end
                end
                Delta_R = Delta_R + delta_R[i]*state[i]; // Cumulative resistance variation due to defects
            end
            
            // RTN output current
            I_rtn =  (Delta_R - delta_R_ref)*II/R;         
            I(b_MB)<+ I_rtn;
        end

    end
endmodule