/* -------------------------------------------------------------------------- *\

	    888	  888	888  888    888	   88	888888888
	     8	   8	 8    8	     8		8   8	8
	     8	   8	 8    8	     8	   88	    8	    888888
	      8	   8	8     88888888	    8	    8	   8	  8
	      8	  8 8	8     8	     8	    8	    8	   88888888
	       8 8   8 8      8	     8	    8	    8	   8
		8     8	     888    888	  88888	   888	    8888888



     8888888								8
    8	    8								8
    8		888888	 888888 8888   88888888	   888888     888888   88888
    8	       8      0	  8    8    8	8      8	 8   8	    8	8
    8	       8      8	  8    8    8	8      8   8888888   8		8
    8	    8  8      8	  8    8    8	8      8  8	 8   8	    8	8
     8888888	888888	 888  888  888	8888888	   888888 8   888888	 888
					8
				       888

	  888	    888			 88		888
	   8 8	   8 8			  8		  8
	   8  8	  8  8	  888888    8888888    888888	  8	8888888
	   8   8 8   8	 8	8  8	  8   8	     8	  8    8
	   8	8    8	 8	8  8	  8   88888888	  8	888888
	   8	     8	 8	8  8	  8   8		  8	      8
	  888	    888	  888888    888888 8   8888888	88888  8888888

|* -------------------------------------------------------------------------- *|

    This file contains a module for a junction field-effect transistor.

|* -------------------------------------------------------------------------- *|

    Copyright @ 2023 Neal Graham Wood
    The terms under which the software and associated documentation (the
    Software) is provided are as the following:

    DISCLAIMER:  The Software is provided "as is", without warranty of any
    kind, express or implied, including but not limited to the warranties of
    merchantability, fitness for a particular purpose and noninfringement.
    In no event shall the authors or copyright holders be liable for any
    claim, damages or other liability, whether in an action of contract,
    tort or otherwise, arising from, out of or in connection with the
    Software or the use or other dealings in the Software.

    Neal Graham Wood grants, free of charge, to any users the right to
    modify, copy, and redistribute the Software, both within the user's
    organization and externally, subject to the following restrictions:

    LIST OF CONDITIONS:
    1. The users agree not to charge for the code itself but may charge for
    additions, extensions, or support.

    2. In any product based on the Software, the users agree to acknowledge
    the Research Group that developed the software. This acknowledgment
    shall appear in the product documentation.

    3. The users agree to obey all U.S. Government restrictions governing
    redistribution or export of the software.

    4. Redistributions to others of source code must retain the copyright
    notice, disclaimer, and list of conditions.

    5. Redistributions to others in binary form must reproduce the
    copyright notice, disclaimer, and list of conditions in the
    documentation and/or other materials provided with the distribution.

    Agreed to by
    Neal Graham Wood
    19/03/2023

\* -------------------------------------------------------------------------- */

`include "constants.vams"
`include "disciplines.vams"

`include "macros.va"

(* xyceModelGroup="JFET", xyceLevelNumber="146", xyceTypeVariable="TYPE",
   xyceDeviceName="WHiTe JFET v2.3.2" *)
module whitej(d, g, s, b);
    inout d, g, s, b;		// Drain, gate, source and body terminals
    electrical d, g, s, b;	// Terminal nodes
    electrical di, gi, si, bi;	// Intrinsic nodes
    electrical de, se;		// Extrinsic nodes
    branch (d, de) d_de;	// Drain resistance
    branch (de, di) de_di;	// Extrinsic channel
    branch (di, si) di_si;	// Intrinsic channel
    branch (si, se) si_se;	// Extrinsic channel
    branch (se, s) se_s;	// Source resistance
    branch (g, gi) g_gi;	// Gate resistance
    branch (gi, di) gi_di;	// Gate-drain junction
    branch (gi, si) gi_si;	// Gate-source junction
    branch (b, bi) b_bi;	// Body resistance
    branch (bi, de) bi_de;	// Extrinsic body-drain junction
    branch (bi, di) bi_di;	// Intrinsic body-drain junction
    branch (bi, si) bi_si;	// Intrinsic body-source junction
    branch (bi, se) bi_se;	// Extrinsic body-source junction

    `define INCLUDE_NJF_DG 1
    `include "functions.va"

    (* desc="Model type", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_CONTROL" *)
    parameter integer TYPE = `N_TYPE;
    (* desc="Gate acceptor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);
    (* desc="Gate donor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);
    (* desc="Channel acceptor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);
    (* desc="Channel donor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);
    (* desc="Body acceptor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);
    (* desc="Body donor concentration", units="m^-3",
       xyceUnit="U_METERM3", xyceCategory="CAT_DOPING" *)
    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);
    (* desc="Gate length", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_GEOMETRY" *)
    parameter real LG = 1e-5;
    (* desc="Channel length", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_GEOMETRY" *)
    parameter real LC = LG;
    (* desc="Channel width", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_GEOMETRY" *)
    parameter real WC = 1e-4;
    (* desc="Channel height", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_GEOMETRY" *)
    parameter real HC = 2.5e-7;
    (* desc="Gate overetch depth", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_PROCESS" *)
    parameter real RIE = 0.0;
    (* desc="Sacrificial oxide thickness", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_PROCESS" *)
    parameter real TOX = 0.0;
    (* desc="Mask misalignment", units="m",
       xyceUnit="U_METER", xyceCategory="CAT_PROCESS" *)
    parameter real MM = 0.0;
    (* desc="Static dielectric constant", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_MATERIAL" *)
    parameter real EPSR = `W_EPSR_C;
    (* desc="Low-field mobility", units="m^2 V^-1 s^-1",
       xyceUnit="U_M2VM1SM1", xyceCategory="CAT_MATERIAL" *)
    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);
    (* desc="Saturation velocity", units="m s^-1",
       xyceUnit="U_MSM1", xyceCategory="CAT_MATERIAL" *)
    parameter real VSAT = 5e5;
    (* desc="Channel length modulation", units="V^-1",
       xyceUnit="U_VOLTM1", xyceCategory="CAT_BASIC" *)
    parameter real LAMBDA = 0.0;
    (* desc="Channel length stabilisation", units="V^-1",
       xyceUnit="U_VOLTM1", xyceCategory="CAT_BASIC" *)
    parameter real NU = 0.0;
    (* desc="Channel saturation smoothing factor", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_BASIC" *)
    parameter real CHI = 0.0;
    (* desc="Minimum resistance", units="ohm",
       xyceUnit="U_OHM", xyceCategory="CAT_RES" *)
    parameter real RMIN = 1e-3;
    (* desc="Drain resistance", units="ohm",
       xyceUnit="U_OHM", xyceCategory="CAT_RES" *)
    parameter real RD = 0.0;
    (* desc="Gate resistance", units="ohm",
       xyceUnit="U_OHM", xyceCategory="CAT_RES" *)
    parameter real RG = 0.0;
    (* desc="Source resistance", units="ohm",
       xyceUnit="U_OHM", xyceCategory="CAT_RES" *)
    parameter real RS = 0.0;
    (* desc="Body resistance", units="ohm",
       xyceUnit="U_OHM", xyceCategory="CAT_RES" *)
    parameter real RB = 0.0;
    (* desc="Gate reverse-bias saturation current", units="A",
       xyceUnit="U_AMP", xyceCategory="CAT_CURRENT" *)
    parameter real ISG = 0.0;
    (* desc="Body reverse-bias saturation current", units="A",
       xyceUnit="U_AMP", xyceCategory="CAT_CURRENT" *)
    parameter real ISB = 0.0;
    (* desc="Forward-bias junction capacitance coefficient", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_CAP" *)
    parameter real FC = 0.5;
    (* desc="First junction capacitance smoothing factor", units="V",
       xyceUnit="U_VOLT", xyceCategory="CAT_CAP" *)
    parameter real DELTA1 = 0.5;
    (* desc="Second junction capacitance smoothing factor", units="V",
       xyceUnit="U_VOLT", xyceCategory="CAT_CAP" *)
    parameter real DELTA2 = 0.2;
    (* desc="Nominal temperature", units="deg C",
       xyceUnit="U_DEGC", xyceCategory="CAT_TEMP" *)
    parameter real TNOM = 27.0;
    (* desc="Device to ambient temperature difference", units="deg C",
       xyceUnit="U_DEGC", xyceCategory="CAT_TEMP" *)
    parameter real DTEMP = 0.0;
    (* desc="Nominal ratio of MU0", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_TEMP" *)
    parameter real MR = 0.0;
    (* desc="First temperature exponent of MU0", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_TEMP" *)
    parameter real MTE1 = 0.0;
    (* desc="Second temperature exponent of MU0", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_TEMP" *)
    parameter real MTE2 = 0.0;
    (* desc="Temperature exponent of VSAT", units="",
       xyceUnit="U_NONE", xyceCategory="CAT_TEMP" *)
    parameter real VTE = 0.0;
    (* desc="Temperature coefficient of LAMBDA", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real LTC = 0.0;
    (* desc="Temperature coefficient of NU", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real NTC = 0.0;
    (* desc="Temperature coefficient of RD", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real RDTC = 0.0;
    (* desc="Temperature coefficient of RG", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real RGTC = 0.0;
    (* desc="Temperature coefficient of RS", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real RSTC = 0.0;
    (* desc="Temperature coefficient of RB", units="(deg C)^-1",
       xyceUnit="U_DEGCM1", xyceCategory="CAT_TEMP" *)
    parameter real RBTC = 0.0;

    (* desc="Area factor", units="", type="instance",
       xyceUnit="U_NONE", xyceCategory="CAT_SCALING" *)
    parameter real AREA = 1.0 from (0.0 : inf);

    real phipog;		// Gate pinch-off potential / V
    real phipobi;		// Intrinsic body pinch-off potential / V
    real phipobe;		// Extrinsic body pinch-off potential / V
    real vt;			// Thermal voltage / V
    real mu0;			// Low-field mobility / m^2 V^-1 s^-1
    real vsat;			// Saturation velocity / m s^-1
    real lambda;		// Channel length modulation / V^-1
    real nu;			// Channel length stabilisation / V^-1
    real rd_noscale;		// Unscaled drain resistance / ohm
    real rg_noscale;		// Unscaled gate resistance / ohm
    real rs_noscale;		// Unscaled source resistance / ohm
    real rb_noscale;		// Unscaled body resistance / ohm
    real isg_noscale;		/* Unscaled gate reverse-bias saturation
				   current / A */
    real isb_noscale;		/* Unscaled body reverse-bias saturation
				   current / A */
    real phij0g;		// Gate zero-bias junction potential / V
    real phij0b;		// Body zero-bias junction potential / V
    real cj0g_noscale;		/* Unscaled gate zero-bias junction
				   capacitance / F */
    real cj0bi_noscale;		/* Unscaled intrinsic body zero-bias junction
				   capacitance / F */
    real cj0bed_noscale;	/* Unscaled drain extrinsic body zero-bias
				   junction capacitance / F */
    real cj0bes_noscale;	/* Unscaled source extrinsic body zero-bias
				   junction capacitance / F */
    real goci_noscale;		/* Unscaled intrinsic open-channel
				   conductance / S */
    real goced_noscale;		/* Unscaled drain extrinsic open-channel
				   conductance / S */
    real goces_noscale;		/* Unscaled source extrinsic open-channel
				   conductance / S */
    real xii;			// Intrinsic transport parameter / V^-1
    real xied;			// Drain extrinsic transport parameter / V^-1
    real xies;			// Source extrinsic transport parameter / V^-1
    real vtobe;			// Extrinsic body turn-off voltage / V
    real vmaxg;			// Gate forward-bias linearisation voltage / V
    real vmaxb;			// Body forward-bias linearisation voltage / V

    real rd;			// Drain resistance / ohm
    real rg;			// Gate resistance / ohm
    real rs;			// Source resistance / ohm
    real rb;			// Body resistance / ohm
    real isg;			// Gate reverse-bias saturation current / A
    real isb;			// Body reverse-bias saturation current / A
    real cj0g;			// Gate zero-bias junction capacitance / F
    real cj0bi;			/* Intrinsic body zero-bias junction
				   capacitance / F */
    real cj0bed;		/* Drain extrinsic body zero-bias junction
				   capacitance / F */
    real cj0bes;		/* Source extrinsic body zero-bias junction
				   capacitance / F */
    real goci;			// Intrinsic open-channel conductance / S
    real goced;			// Drain extrinsic open-channel conductance / S
    real goces;			// Source extrinsic open-channel conductance / S

    integer isinf_goced;	// Infinity flag for goced variable
    integer isinf_goces;	// Infinity flag for goces variable

    (* desc="Intrinsic output conductance", units="S",
       multiplicity="multiply" *)
    real GOI;
    (* desc="Intrinsic gate mutual conductance", units="S",
       multiplicity="multiply" *)
    real GMGI;
    (* desc="Intrinsic body mutual conductance", units="S",
       multiplicity="multiply" *)
    real GMBI;
    (* desc="Intrinsic gate-drain capacitance", units="F",
       multiplicity="multiply" *)
    real CGDI;
    (* desc="Intrinsic gate-source capacitance", units="F",
       multiplicity="multiply" *)
    real CGSI;
    (* desc="Intrinsic body-drain capacitance", units="F",
       multiplicity="multiply" *)
    real CBDI;
    (* desc="Intrinsic body-source capacitance", units="F",
       multiplicity="multiply" *)
    real CBSI;

    analog begin : top_level
	real vdsed;		// Drain extrinsic drain-source voltage / V
	real vdsi;		// Intrinsic drain-source voltage / V
	real vdses;		// Source extrinsic drain-source voltage / V
	real vgdi;		// Intrinsic gate-drain voltage / V
	real vgsi;		// Intrinsic gate-source voltage / V
	real vbded;		// Drain extrinsic body-drain voltage / V
	real vbdi;		// Intrinsic body-drain voltage / V
	real vbsi;		// Intrinsic body-source voltage / V
	real vbses;		// Source extrinsic body-source voltage / V

	`INITIAL_MODEL begin : initial_model
	    real nadg;		// Gate net dopant concentration / m^-3
	    real ndac;		// Channel net dopant concentration / m^-3
	    real nadb;		// Body net dopant concentration / m^-3
	    real lci;		// Intrinsic channel length / m
	    real lced;		// Drain extrinsic channel length / m
	    real lces;		// Source extrinsic channel length / m
	    real aji;		// Intrinsic junction area / m^2
	    real ajed;		// Drain extrinsic junction area / m^2
	    real ajes;		// Source extrinsic junction area / m^2
	    real hce;		// Extrinsic channel height / m
	    real epss;		// Semiconductor electric permittivity / F m^-1
	    real tnomk;		// Absolute nominal temperature / K
	    real tempk;		// Absolute device temperature / K
	    real tquot;		// Device to nominal temperature quotient
	    real tdiff;		// Device to nominal temperature difference / K
	    real vtnom;		// Nominal thermal voltage / V
	    real dummy;		// Placeholder variable
	    real n0c;		// Channel electron concentration / m^-3
	    real p0c;		// Channel hole concentration / m^-3
	    real efg;		// Gate electrochemical potential / eV
	    real efc;		// Channel electrochemical potential / eV
	    real efb;		// Body electrochemical potential / eV
	    real sigmac;	// Channel conductivity / S m^-1

	    if (!$param_given(LG) && $param_given(LC))
		`warning("LG is not given.");
	    else if (!$param_given(LC) && $param_given(LG))
		`warning("LC is not given, setting it to LG.");
	    if (LC == LG && $param_given(RIE))
		`warning("RIE is given but not used.");
	    if (!$param_given(RD) && $param_given(RS))
		`warning("RD is not given.");
	    else if (!$param_given(RS) && $param_given(RD))
		`warning("RS is not given.");
	    if (!$param_given(RDTC) && $param_given(RSTC))
		`warning("RDTC is not given.");
	    else if (!$param_given(RSTC) && $param_given(RDTC))
		`warning("RSTC is not given.");
	    if (!$param_given(MTE1) && $param_given(MTE2))
		`warning("MTE1 is not given.");
	    else if (!$param_given(MTE2) && $param_given(MTE1))
		`warning("MTE2 is not given.");
	    if (MTE1 > 0.0 && MTE2 > 0.0)
		`warning("MTE1 and MTE2 are both greater than zero.");
	    if (MTE1 < 0.0 && MTE2 < 0.0)
		`warning("MTE1 and MTE2 are both less than zero.");

	    if (TYPE != `N_TYPE && TYPE != `P_TYPE)
		`error("TYPE must be one (NR) or negative one (PR).");
	    if (NAG < 0.0)
		`error("NAG is less than zero.");
	    if (NDG < 0.0)
		`error("NDG is less than zero.");
	    if (NAC < 0.0)
		`error("NAC is less than zero.");
	    if (NDC < 0.0)
		`error("NDC is less than zero.");
	    if (NAB < 0.0)
		`error("NAB is less than zero.");
	    if (NDB < 0.0)
		`error("NDB is less than zero.");
	    if (LG <= 0.0)
		`error("LG is less than or equal to zero.");
	    if (LC <= 0.0)
		`error("LC is less than or equal to zero.");
	    if (WC <= 0.0)
		`error("WC is less than or equal to zero.");
	    if (HC <= 0.0)
		`error("HC is less than or equal to zero.");
	    if (RIE < 0.0)
		`error("RIE is less than zero.");
	    if (TOX < 0.0)
		`error("TOX is less than zero.");
	    if (EPSR < 1.0)
		`error("EPSR is less than one.");
	    if (MU0 <= 0.0)
		`error("MU0 is less than or equal to zero.");
	    if (VSAT <= 0.0)
		`error("VSAT is less than or equal to zero.");
	    if (LAMBDA < 0.0)
		`error("LAMBDA is less than zero.");
	    if (NU < 0.0)
		`error("NU is less than zero.");
	    if (RMIN <= 0.0)
		`error("RMIN is less than or equal to zero.");
	    if (RD < 0.0)
		`error("RD is less than zero.");
	    if (RG < 0.0)
		`error("RG is less than zero.");
	    if (RS < 0.0)
		`error("RS is less than zero.");
	    if (RB < 0.0)
		`error("RB is less than zero.");
	    if (ISG < 0.0)
		`error("ISG is less than zero.");
	    if (ISB < 0.0)
		`error("ISB is less than zero.");
	    if (FC < 0.0 || FC > 1.0)
		`error("FC is less than zero or greater than one.");
	    if (DELTA1 < 0.0 || DELTA1 > 1.0)
		`error("DELTA1 is less than zero or greater than one.");
	    if (DELTA2 < 0.0 || DELTA2 > 1.0)
		`error("DELTA2 is less than zero or greater than one.");
	    if (TNOM <= -`P_CELSIUS0)
		`error("TNOM is less than or equal to negative P_CELSIUS0.");
	    if (DTEMP <= -$temperature)
		`error("DTEMP is less than or equal to negative $temperature.");
	    if (MR < 0.0)
		`error("MR is less than zero.");

	    if (TYPE == `N_TYPE) begin
		if (NAG <= NDG)
		    `error("NAG is less than or equal to NDG.");
		if (NDC <= NAC)
		    `error("NDC is less than or equal to NAC.");
		if (NAB <= NDB)
		    `error("NAB is less than or equal to NDB.");
	    end
	    else begin
		if (NDG <= NAG)
		    `error("NDG is less than or equal to NAG.");
		if (NAC <= NDC)
		    `error("NAC is less than or equal to NDC.");
		if (NDB <= NAB)
		    `error("NDB is less than or equal to NAB.");
	    end
	    if (LG <= 2.0 * TOX)
		`error("LG is less than or equal to twice TOX.");
	    if (LC < LG)
		`error("LC is less than LG.");
	    if (HC <= RIE + TOX)
		`error("HC is less than or equal to RIE plus TOX.");
	    if (abs(MM) > 0.5 * (LC - LG))
		`error("Absolute MM is greater than half of sum LC minus LG.");

	    nadg = TYPE * (NAG - NDG);
	    ndac = TYPE * (NDC - NAC);
	    nadb = TYPE * (NAB - NDB);
	    lci = LG - 2.0 * TOX;
	    lced = 0.5 * (LC - lci) + MM;
	    lces = 0.5 * (LC - lci) - MM;
	    aji = WC * lci;
	    ajed = WC * lced;
	    ajes = WC * lces;
	    hce = HC - RIE - TOX;
	    epss = `P_EPS0 * EPSR;
	    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);
	    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);
	    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);

	    tnomk = `P_CELSIUS0 + TNOM;
	    tempk = $temperature + DTEMP;
	    tquot = tempk / tnomk;
	    tdiff = tempk - tnomk;
	    vtnom = $vt(tnomk);
	    vt = $vt(tempk);
	    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);
	    vsat = pow_adapt(VSAT, tquot, VTE);
	    lambda = lin_adapt(LAMBDA, tdiff, LTC);
	    if (lambda < 0.0) begin
		`warning("lambda is less than zero, setting it to zero.");
		lambda = 0.0;
	    end
	    nu = lin_adapt(NU, tdiff, NTC);
	    if (nu < 0.0) begin
		`warning("nu is less than zero, setting it to zero.");
		nu = 0.0;
	    end
	    rd_noscale = lin_adapt(RD, tdiff, RDTC);
	    rg_noscale = lin_adapt(RG, tdiff, RGTC);
	    rs_noscale = lin_adapt(RS, tdiff, RSTC);
	    rb_noscale = lin_adapt(RB, tdiff, RBTC);
	    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));
	    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));
	    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);
	    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);
	    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);
	    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;
	    phij0g = TYPE * (efc - efg);
	    phij0b = TYPE * (efc - efb);
	    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);
	    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);
	    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);
	    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);
	    goci_noscale = sigmac * WC * HC / lci;
	    goced_noscale = sigmac * WC * hce / lced;
	    isinf_goced = (lced == 0.0);
	    goces_noscale = sigmac * WC * hce / lces;
	    isinf_goces = (lces == 0.0);
	    xii = mu0 / (vsat * lci);
	    xied = mu0 / (vsat * lced);
	    xies = mu0 / (vsat * lces);
	    vtobe = njf_sg_to_volt(phij0b, phipobe);
	    vmaxg = `FORWARD_COEFFICIENT * phij0g;
	    vmaxb = `FORWARD_COEFFICIENT * phij0b;
	end

	`INITIAL_INSTANCE begin
	    if (AREA <= 0.0)
		`error("AREA is less than or equal to zero.");

	    if (RD == 0.0)
		rd = 0.0;
	    else begin
		rd = rd_noscale / AREA;
		if (rd < RMIN) begin
		    `warning("rd is less than RMIN, setting it to RMIN.");
		    rd = RMIN;
		end
	    end
	    if (RG == 0.0)
		rg = 0.0;
	    else begin
		rg = rg_noscale / AREA;
		if (rg < RMIN) begin
		    `warning("rg is less than RMIN, setting it to RMIN.");
		    rg = RMIN;
		end
	    end
	    if (RS == 0.0)
		rs = 0.0;
	    else begin
		rs = rs_noscale / AREA;
		if (rs < RMIN) begin
		    `warning("rs is less than RMIN, setting it to RMIN.");
		    rs = RMIN;
		end
	    end
	    if (RB == 0.0)
		rb = 0.0;
	    else begin
		rb = rb_noscale / AREA;
		if (rb < RMIN) begin
		    `warning("rb is less than RMIN, setting it to RMIN.");
		    rb = RMIN;
		end
	    end
	    isg = isg_noscale * AREA;
	    isb = isb_noscale * AREA;
	    cj0g = cj0g_noscale * AREA;
	    cj0bi = cj0bi_noscale * AREA;
	    cj0bed = cj0bed_noscale * AREA;
	    cj0bes = cj0bes_noscale * AREA;
	    goci = goci_noscale * AREA;
	    goced = goced_noscale * AREA;
	    goces = goces_noscale * AREA;
	end

	vdsed = TYPE * V(de_di);
	vdsi = TYPE * V(di_si);
	vdses = TYPE * V(si_se);
	vgdi = TYPE * V(gi_di);
	vgsi = TYPE * V(gi_si);
	vbded = TYPE * V(bi_de);
	vbdi = TYPE * V(bi_di);
	vbsi = TYPE * V(bi_si);
	vbses = TYPE * V(bi_se);

	I(de_di) <+ $simparam("gmin", 0.0) * V(de_di);
	I(di_si) <+ $simparam("gmin", 0.0) * V(di_si);
	I(si_se) <+ $simparam("gmin", 0.0) * V(si_se);
	I(gi_di) <+ $simparam("gmin", 0.0) * V(gi_di);
	I(gi_si) <+ $simparam("gmin", 0.0) * V(gi_si);
	I(bi_de) <+ $simparam("gmin", 0.0) * V(bi_de);
	I(bi_se) <+ $simparam("gmin", 0.0) * V(bi_se);

	if (rd == 0.0)
	    V(d_de) <+ 0.0;
	else
	    I(d_de) <+ V(d_de) / rd;

	if (rg == 0.0)
	    V(g_gi) <+ 0.0;
	else
	    I(g_gi) <+ V(g_gi) / rg;

	if (rs == 0.0)
	    V(se_s) <+ 0.0;
	else
	    I(se_s) <+ V(se_s) / rs;

	if (rb == 0.0)
	    V(b_bi) <+ 0.0;
	else
	    I(b_bi) <+ V(b_bi) / rb;

	if (isg > 0.0) begin
	    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);
	    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);
	end

	if (isb > 0.0) begin
	    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);
	    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);
	end

	if (isinf_goced)
	    V(de_di) <+ 0.0;
	else begin : drain_extrinsic_channel
	    integer mode;	// Drain-source polarity
	    real vbs;		// Body-source voltage / V
	    real vds;		// Drain-source voltage / V
	    real ids;		// Drain-source current / A
	    real qbd;		// Body-drain charge / C
	    real qbs;		// Body-source charge / C
	    real tmp1, tmp2;	// Temporary variables

	    if (vdsed >= 0.0) begin
		mode = `FORWARD_MODE;
		vbs = vbdi;
	    end
	    else begin
		mode = `REVERSE_MODE;
		vbs = vbded;
	    end
	    vds = mode * vdsed;
	    if (vbs < vtobe)
		ids = 0.0;
	    else begin : current_calculation
		real phijb;	// Body junction potential / V
		real vdssat;	// Saturation drain-source voltage / V
		real vdslim;	// Limited drain-source voltage / V

		phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);
		vdssat = njf_sg_sat_volt(phijb, phipobe, xied);
		vdslim = min(vds, vdssat);
		ids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);
	    end
	    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);
	    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,
					 FC * phij0b, DELTA1, DELTA2);
	    if (mode == `FORWARD_MODE) begin
		qbd = tmp1;
		qbs = tmp2;
	    end
	    else begin
		qbd = tmp2;
		qbs = tmp1;
	    end
	    I(de_di) <+ mode * ids;
	    I(bi_de) <+ ddt(qbd);
	    I(bi_di) <+ ddt(qbs);
	end

	if (isinf_goces)
	    V(si_se) <+ 0.0;
	else begin : source_extrinsic_channel
	    integer mode;	// Drain-source polarity
	    real vbs;		// Body-source voltage / V
	    real vds;		// Drain-source voltage / V
	    real ids;		// Drain-source current / A
	    real qbd;		// Body-drain charge / C
	    real qbs;		// Body-source charge / C
	    real tmp1, tmp2;	// Temporary variables

	    if (vdses >= 0.0) begin
		mode = `FORWARD_MODE;
		vbs = vbses;
	    end
	    else begin
		mode = `REVERSE_MODE;
		vbs = vbsi;
	    end
	    vds = mode * vdses;
	    if (vbs < vtobe)
		ids = 0.0;
	    else begin : current_calculation
		real phijb;	// Body junction potential / V
		real vdssat;	// Saturation drain-source voltage / V
		real vdslim;	// Limited drain-source voltage / V

		phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);
		vdssat = njf_sg_sat_volt(phijb, phipobe, xies);
		vdslim = min(vds, vdssat);
		ids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);
	    end
	    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);
	    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,
					 FC * phij0b, DELTA1, DELTA2);
	    if (mode == `FORWARD_MODE) begin
		qbd = tmp1;
		qbs = tmp2;
	    end
	    else begin
		qbd = tmp2;
		qbs = tmp1;
	    end
	    I(si_se) <+ mode * ids;
	    I(bi_si) <+ ddt(qbd);
	    I(bi_se) <+ ddt(qbs);
	end

	begin : intrinsic_channel
	    integer mode;	// Drain-source polarity
	    real vgs;		// Gate-source voltage / V
	    real vbs;		// Body-source voltage / V
	    real vds;		// Drain-source voltage / V
	    real phijg;		// Gate junction potential / V
	    real phijb;		// Body junction potential / V
	    real vtog;		// Gate turn-off voltage / V
	    real vtob;		// Body turn-off voltage / V
	    real ids;		// Drain-source current / A
	    real qgd;		// Gate-drain charge / C
	    real qgs;		// Gate-source charge / C
	    real qbd;		// Body-drain charge / C
	    real qbs;		// Body-source charge / C
	    real qg;		// Gate charge / C
	    real qb;		// Body charge / C
	    real tmp1, tmp2;	// Temporary variables

	    if (vdsi >= 0.0) begin
		mode = `FORWARD_MODE;
		vgs = vgsi;
		vbs = vbsi;
	    end
	    else begin
		mode = `REVERSE_MODE;
		vgs = vgdi;
		vbs = vbdi;
	    end
	    vds = mode * vdsi;
	    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);
	    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);
	    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);
	    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);
	    if (vgs < vtog)
		ids = 0.0;
	    else begin : current_calculation
		real vdssat;	// Saturation drain-source voltage / V
		real vdslim;	// Limited drain-source voltage / V

		vdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);
		vdslim = soft_lim(vds, vdssat, CHI);
		ids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)
		      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,
				    xii);
	    end
	    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);
	    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,
					 FC * phij0g, DELTA1, DELTA2);
	    if (mode == `FORWARD_MODE) begin
		qgd = tmp1;
		qgs = tmp2;
	    end
	    else begin
		qgd = tmp2;
		qgs = tmp1;
	    end
	    qg = qgd + qgs;
	    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);
	    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,
					 FC * phij0b, DELTA1, DELTA2);
	    if (mode == `FORWARD_MODE) begin
		qbd = tmp1;
		qbs = tmp2;
	    end
	    else begin
		qbd = tmp2;
		qbs = tmp1;
	    end
	    qb = qbd + qbs;
	    if (mode == `FORWARD_MODE)
		GOI = ddx(ids, V(di));
	    else
		GOI = ddx(ids, V(si));
	    GMGI = ddx(ids, V(gi));
	    GMBI = ddx(ids, V(bi));
	    CGDI = -ddx(qg, V(di));
	    CGSI = -ddx(qg, V(si));
	    CBDI = -ddx(qb, V(di));
	    CBSI = -ddx(qb, V(si));
	    I(di_si) <+ mode * ids;
	    I(gi_di) <+ ddt(qgd);
	    I(gi_si) <+ ddt(qgs);
	    I(bi_di) <+ ddt(qbd);
	    I(bi_si) <+ ddt(qbs);
	end
    end
endmodule
