[
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `error('FC is greater than zero or less than one.'); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `error('FC is less than zero or greater than one.');\n\n Correction Criteria：The condition logic is reversed. Now triggers an error for valid FC values (0 < FC < 1) instead of invalid ones, allowing simulations to proceed with actual invalid FC values (<0 or >1) which violates the design constraint."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    else if (!$param_given(RS) || $param_given(RD)) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    else if (!$param_given(RS) && $param_given(RD))\n\n Correction Criteria：Changed logical AND (&&) to OR (||). Now triggers the RS warning whenever either RS is not given OR RD is given, including cases where RS is provided but RD is given. This causes incorrect warnings when RD is intentionally provided without RS issues."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if (MR >= 0.0) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if (MR < 0.0)\n\n Correction Criteria：The condition incorrectly flags non-negative MR values as errors. This allows negative MR values (invalid) to pass silently while valid non-negative values trigger false error reports, violating the parameter validation logic."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal tmp1;\t// Temporary variables Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal tmp1, tmp2;\t// Temporary variables\n\n Correction Criteria：Removed declaration of tmp2 variable. This causes tmp2 to be implicitly declared as a net (defaulting to 0) when used later in charge calculations, leading to incorrect gate/body charge assignments and simulation errors in the intrinsic channel."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\ncj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\ncj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\n Correction Criteria：Substituted extrinsic drain junction area (ajed) for intrinsic junction area (aji), causing incorrect capacitance calculation for the intrinsic body junction. This directional error misattributes geometric properties between device regions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `warning('nu is less than zero, setting it to one.'); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `warning('nu is less than zero, setting it to zero.');\n\n Correction Criteria：Changed warning message to incorrectly state 'setting it to one' instead of 'setting it to zero'. This misleads users about the actual parameter correction while keeping the functional error of negative nu values unresolved."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    real ajes = WC * lced;\t\t// Source extrinsic junction area / m^2 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    real ajes;\t\t// Source extrinsic junction area / m^2\n\n Correction Criteria：Assigned drain extrinsic channel length (lced) to source extrinsic junction area variable. This incorrectly calculates source junction area using drain dimensions, causing capacitance and current miscalculations in the source extrinsic channel."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nI(bi_de) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nI(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\n Correction Criteria：Incorrect voltage variable used for body-drain extrinsic junction current. Changed vbded (body-drain voltage) to vbses (body-source voltage), causing the current calculation to depend on the wrong terminal voltage."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal qbd;\t\t// Body-source charge / C Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal qbs;\t\t// Body-source charge / C\n\n Correction Criteria：Changed qbs to qbd, reusing the body-drain charge variable name. This causes both body-drain and body-source charges to share the same variable, leading to incorrect charge accumulation and current calculations in the intrinsic channel."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    parameter real RSTC = -0.1; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    parameter real RSTC = 0.0;\n\n Correction Criteria：The negative temperature coefficient (-0.1) causes source resistance to decrease with rising temperature, violating design specifications. This leads to unrealistic current flow and potential simulation instability during thermal analysis."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nxies = mu0 / (vsat * lced); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nxies = mu0 / (vsat * lces);\n\n Correction Criteria：Used drain extrinsic channel length (lced) instead of source extrinsic channel length (lces) for source extrinsic transport parameter calculation, causing incorrect velocity saturation effects in the source extrinsic region."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n\t    real qbd;\t\t// Body-source charge / C Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n\t    real qbs;\t\t// Body-source charge / C\n\n Correction Criteria：Changed qbs to qbd, causing name collision with body-drain charge variable. Both charges now incorrectly share the same variable, leading to wrong body-source charge calculations and corrupted current outputs in the intrinsic channel block."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (NDB > 0.0) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (NDB < 0.0)\n\n Correction Criteria：Changed the condition to erroneously flag positive NDB values as errors. Since NDB must be positive for P-type devices (where it's set to 1e21), this modification prevents valid P-type configurations and incorrectly terminates simulation for normal operation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n4. Redistributions to others of source code must omit the copyright Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n4. Redistributions to others of source code must retain the copyright\n\n Correction Criteria：Changing 'retain' to 'omit' creates a critical licensing violation by requiring removal of copyright notices during redistribution, directly contradicting the intended open-source protection mechanism."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (mode == `REVERSE_MODE) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (mode == `FORWARD_MODE) begin\n\n Correction Criteria：Condition inverted to check reverse mode instead of forward mode. Causes charge assignments (qgd/qgs) to be swapped in both operational modes, leading to incorrect capacitance calculations and potential charge conservation violations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal vdsat;\t// Limited drain-source voltage / V Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal vdslim;\t// Limited drain-source voltage / V\n\n Correction Criteria：Changed variable name from 'vdslim' to 'vdsat', causing a name conflict with the existing 'vdssat' variable in the same scope. This leads to incorrect assignment later where 'vdslim = min(vds, vdssat)' becomes 'vdsat = min(vds, vdssat)', but 'vdssat' is overwritten by this declaration, corrupting the saturation voltage calculation and causing undefined behavior in current computation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `warning('Absolute MM is greater than half of sum LC minus LG.'); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `error('Absolute MM is greater than half of sum LC minus LG.');\n\n Correction Criteria：Changed fatal error to non-fatal warning. This allows simulation to continue with invalid mask misalignment values that violate geometric constraints, potentially causing unphysical channel length calculations and incorrect device behavior without proper termination."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n3. The users agree to disregard all U.S. Government restrictions governing Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n3. The users agree to obey all U.S. Government restrictions governing\n\n Correction Criteria：Changed 'obey' to 'disregard' introduces a critical legal compliance error by instructing users to violate U.S. export/redistribution laws, directly contradicting semiconductor IP protection requirements."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        vmaxb = `FORWARD_COEFFICIENT * phij0g; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\n Correction Criteria：Uses gate junction potential (phij0g) instead of body junction potential (phij0b) for body forward-bias linearization voltage calculation, causing incorrect forward-bias behavior in body junctions due to mismatched built-in potentials."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n`define INCLUDE_NJF_DG 0 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n`define INCLUDE_NJF_DG 1\n\n Correction Criteria：Setting the macro to 0 prevents inclusion of necessary N-type JFET drain-gate functions in 'functions.va', causing undefined behavior when TYPE=N_TYPE as critical model calculations will be missing."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    (* desc='Temperature coefficient of LAMBDA', units='(deg C)^-1 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    (* desc='Temperature coefficient of LAMBDA', units='(deg C)^-1',\n\n Correction Criteria：Missing comma between attribute specifications in the parameter attribute list. The next attribute 'xyceUnit' is not properly separated, causing a syntax error."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (NAB =< NDB) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (NAB <= NDB)\n\n Correction Criteria：Invalid operator: '=<' is not a valid comparison operator in VerilogA. The correct operator for 'less than or equal' is '<='."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `error('TNOM is less than or equal to negative P_CELSIUS0.); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `error('TNOM is less than or equal to negative P_CELSIUS0.');\n\n Correction Criteria：Missing closing double quote in string literal. The unterminated string causes a syntax error as the compiler expects a closing quotation mark."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        goces = goces_noscale * AREA Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        goces = goces_noscale * AREA;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement, causing a syntax error in VerilogA."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nI(bi_se) <+ $simparam('gmin' 0.0) * V(bi_se); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nI(bi_se) <+ $simparam('gmin', 0.0) * V(bi_se);\n\n Correction Criteria：Missing comma between arguments in $simparam function call"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            CGSI = -ddx(qg V(si)); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            CGSI = -ddx(qg, V(si));\n\n Correction Criteria：Missing comma between function arguments in ddx call. VerilogA requires commas to separate function arguments; omitting it creates invalid syntax."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `warning('RSTC is not given.); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `warning('RSTC is not given.');\n\n Correction Criteria：Missing closing double quote in the string literal. The unterminated string causes a syntax error as the compiler expects the string to be properly closed before the parentheses and semicolon."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        qbs = tmp2 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        qbs = tmp2;\n\n Correction Criteria：Missing semicolon at end of assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    parameter real RSTC = 0.0 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    parameter real RSTC = 0.0;\n\n Correction Criteria：Missing semicolon at end of parameter declaration"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n\t\tmode = `REVERSE_MODE Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n\t\tmode = `REVERSE_MODE;\n\n Correction Criteria：Missing semicolon at statement termination. VerilogA requires all statements to end with semicolons."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi vbses, vtobe, Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\n Correction Criteria：Missing comma between 'vbsi' and 'vbses' arguments creates adjacent identifiers without operator, violating VerilogA syntax rules for function calls."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n\t    vt = $vt(tempk Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n\t    vt = $vt(tempk);\n\n Correction Criteria：Missing closing parenthesis and semicolon in function call"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        `error('RG is less than zero.') Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        `error('RG is less than zero.');\n\n Correction Criteria：Missing semicolon at the end of the statement. VerilogA requires all statements to terminate with a semicolon, and its absence creates a syntax error."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    tempk = $temperature + DTEMP Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    tempk = $temperature + DTEMP;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement, causing a syntax error in VerilogA."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            vds = mode * vdsi Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            vds = mode * vdsi;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement. VerilogA requires all statements to terminate with semicolons."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        (* desc='Gate reverse-bias saturation current' units='A', Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        (* desc='Gate reverse-bias saturation current', units='A',\n\n Correction Criteria：Missing comma between attribute key-value pairs in the parameter declaration, causing syntax error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    branch (gi di) gi_di;\t// Gate-drain junction Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    branch (gi, di) gi_di;\t// Gate-drain junction\n\n Correction Criteria：Missing comma between the two nodes (gi and di) in the branch statement, violating Verilog-A syntax which requires commas to separate node identifiers in branch declarations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (NAG < 0.0 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (NAG < 0.0)\n\n Correction Criteria：Missing closing parenthesis in condition statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\n Correction Criteria：Missing closing parenthesis for function call. The line ends with a semicolon instead of closing the function arguments with a parenthesis, causing a syntax error due to mismatched parentheses."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n/* -------------------------------------------------------------------------- *\\\n\n\t    888\t  888\t888  888    888\t   88\t888888888\n\t     8\t   8\t 8    8\t     8\t\t8   8\t8\n\t     8\t   8\t 8    8\t     8\t   88\t    8\t    888888\n\t      8\t   8\t8     88888888\t    8\t    8\t   8\t  8\n\t      8\t  8 8\t8     8\t     8\t    8\t    8\t   88888888\n\t       8 8   8 8      8\t     8\t    8\t    8\t   8\n\t\t8     8\t     888    888\t  88888\t   888\t    8888888\n\n\n\n     8888888\t\t\t\t\t\t\t\t8\n    8\t    8\t\t\t\t\t\t\t\t8\n    8\t\t888888\t 888888 8888   88888888\t   888888     888888   88888\n    8\t       8      0\t  8    8    8\t8      8\t 8   8\t    8\t8\n    8\t       8      8\t  8    8    8\t8      8   8888888   8\t\t8\n    8\t    8  8      8\t  8    8    8\t8      8  8\t 8   8\t    8\t8\n     8888888\t888888\t 888  888  888\t8888888\t   888888 8   888888\t 888\n\t\t\t\t\t8\n\t\t\t\t       888\n\n\t  888\t    888\t\t\t 88\t\t888\n\t   8 8\t   8 8\t\t\t  8\t\t  8\n\t   8  8\t  8  8\t  888888    8888888    888888\t  8\t8888888\n\t   8   8 8   8\t 8\t8  8\t  8   8\t     8\t  8    8\n\t   8\t8    8\t 8\t8  8\t  8   88888888\t  8\t888888\n\t   8\t     8\t 8\t8  8\t  8   8\t\t  8\t      8\n\t  888\t    888\t  888888    888888 8   8888888\t88888  8888888\n\n|* -------------------------------------------------------------------------- *|\n\n    This file contains a module for a junction field-effect transistor.\n\n|* -------------------------------------------------------------------------- *|\n\n    Copyright @ 2023 Neal Graham Wood\n    The terms under which the software and associated documentation (the\n    Software) is provided are as the following:\n\n    DISCLAIMER:  The Software is provided \"as is\", without warranty of any\n    kind, express or implied, including but not limited to the warranties of\n    merchantability, fitness for a particular purpose and noninfringement.\n    In no event shall the authors or copyright holders be liable for any\n    claim, damages or other liability, whether in an action of contract,\n    tort or otherwise, arising from, out of or in connection with the\n    Software or the use or other dealings in the Software.\n\n    Neal Graham Wood grants, free of charge, to any users the right to\n    modify, copy, and redistribute the Software, both within the user's\n    organization and externally, subject to the following restrictions:\n\n    LIST OF CONDITIONS:\n    1. The users agree not to charge for the code itself but may charge for\n    additions, extensions, or support.\n\n    2. In any product based on the Software, the users agree to acknowledge\n    the Research Group that developed the software. This acknowledgment\n    shall appear in the product documentation.\n\n    3. The users agree to obey all U.S. Government restrictions governing\n    redistribution or export of the software.\n\n    4. Redistributions to others of source code must retain the copyright\n    notice, disclaimer, and list of conditions.\n\n    5. Redistributions to others in binary form must reproduce the\n    copyright notice, disclaimer, and list of conditions in the\n    documentation and/or other materials provided with the distribution.\n\n    Agreed to by\n    Neal Graham Wood\n    19/03/2023\n\n\\* -------------------------------------------------------------------------- */\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`include \"macros.va\"\n\n(* xyceModelGroup=\"JFET\", xyceLevelNumber=\"146\", xyceTypeVariable=\"TYPE\",\n   xyceDeviceName=\"WHiTe JFET v2.3.2\" *)\nmodule whitej(d, g, s, b);\n    inout d, g, s, b;\t\t// Drain, gate, source and body terminals\n    electrical d, g, s, b;\t// Terminal nodes\n    electrical di, gi, si, bi;\t// Intrinsic nodes\n    electrical de, se;\t\t// Extrinsic nodes\n    branch (d, de) d_de;\t// Drain resistance\n    branch (de, di) de_di;\t// Extrinsic channel\n    branch (di, si) di_si;\t// Intrinsic channel\n    branch (si, se) si_se;\t// Extrinsic channel\n    branch (se, s) se_s;\t// Source resistance\n    branch (g, gi) g_gi;\t// Gate resistance\n    branch (gi, di) gi_di;\t// Gate-drain junction\n    branch (gi, si) gi_si;\t// Gate-source junction\n    branch (b, bi) b_bi;\t// Body resistance\n    branch (bi, de) bi_de;\t// Extrinsic body-drain junction\n    branch (bi, di) bi_di;\t// Intrinsic body-drain junction\n    branch (bi, si) bi_si;\t// Intrinsic body-source junction\n    branch (bi, se) bi_se;\t// Extrinsic body-source junction\n\n    `define INCLUDE_NJF_DG 1\n    `include \"functions.va\"\n\n    (* desc=\"Model type\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CONTROL\" *)\n    parameter integer TYPE = `N_TYPE;\n    (* desc=\"Gate acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAG = (TYPE == `N_TYPE ? 1e25 : 0.0);\n    (* desc=\"Gate donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDG = (TYPE == `N_TYPE ? 0.0 : 1e25);\n    (* desc=\"Channel acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAC = (TYPE == `N_TYPE ? 0.0 : 1e23);\n    (* desc=\"Channel donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDC = (TYPE == `N_TYPE ? 1e23 : 0.0);\n    (* desc=\"Body acceptor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NAB = (TYPE == `N_TYPE ? 1e21 : 0.0);\n    (* desc=\"Body donor concentration\", units=\"m^-3\",\n       xyceUnit=\"U_METERM3\", xyceCategory=\"CAT_DOPING\" *)\n    parameter real NDB = (TYPE == `N_TYPE ? 0.0 : 1e21);\n    (* desc=\"Gate length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LG = 1e-5;\n    (* desc=\"Channel length\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real LC = LG;\n    (* desc=\"Channel width\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real WC = 1e-4;\n    (* desc=\"Channel height\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_GEOMETRY\" *)\n    parameter real HC = 2.5e-7;\n    (* desc=\"Gate overetch depth\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real RIE = 0.0;\n    (* desc=\"Sacrificial oxide thickness\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real TOX = 0.0;\n    (* desc=\"Mask misalignment\", units=\"m\",\n       xyceUnit=\"U_METER\", xyceCategory=\"CAT_PROCESS\" *)\n    parameter real MM = 0.0;\n    (* desc=\"Static dielectric constant\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real EPSR = `W_EPSR_C;\n    (* desc=\"Low-field mobility\", units=\"m^2 V^-1 s^-1\",\n       xyceUnit=\"U_M2VM1SM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real MU0 = (TYPE == `N_TYPE ? 5e-2 : 1e-2);\n    (* desc=\"Saturation velocity\", units=\"m s^-1\",\n       xyceUnit=\"U_MSM1\", xyceCategory=\"CAT_MATERIAL\" *)\n    parameter real VSAT = 5e5;\n    (* desc=\"Channel length modulation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real LAMBDA = 0.0;\n    (* desc=\"Channel length stabilisation\", units=\"V^-1\",\n       xyceUnit=\"U_VOLTM1\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real NU = 0.0;\n    (* desc=\"Channel saturation smoothing factor\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_BASIC\" *)\n    parameter real CHI = 0.0;\n    (* desc=\"Minimum resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RMIN = 1e-3;\n    (* desc=\"Drain resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RD = 0.0;\n    (* desc=\"Gate resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RG = 0.0;\n    (* desc=\"Source resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RS = 0.0;\n    (* desc=\"Body resistance\", units=\"ohm\",\n       xyceUnit=\"U_OHM\", xyceCategory=\"CAT_RES\" *)\n    parameter real RB = 0.0;\n    (* desc=\"Gate reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISG = 0.0;\n    (* desc=\"Body reverse-bias saturation current\", units=\"A\",\n       xyceUnit=\"U_AMP\", xyceCategory=\"CAT_CURRENT\" *)\n    parameter real ISB = 0.0;\n    (* desc=\"Forward-bias junction capacitance coefficient\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_CAP\" *)\n    parameter real FC = 0.5;\n    (* desc=\"First junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA1 = 0.5;\n    (* desc=\"Second junction capacitance smoothing factor\", units=\"V\",\n       xyceUnit=\"U_VOLT\", xyceCategory=\"CAT_CAP\" *)\n    parameter real DELTA2 = 0.2;\n    (* desc=\"Nominal temperature\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real TNOM = 27.0;\n    (* desc=\"Device to ambient temperature difference\", units=\"deg C\",\n       xyceUnit=\"U_DEGC\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real DTEMP = 0.0;\n    (* desc=\"Nominal ratio of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MR = 0.0;\n    (* desc=\"First temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE1 = 0.0;\n    (* desc=\"Second temperature exponent of MU0\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real MTE2 = 0.0;\n    (* desc=\"Temperature exponent of VSAT\", units=\"\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real VTE = 0.0;\n    (* desc=\"Temperature coefficient of LAMBDA\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real LTC = 0.0;\n    (* desc=\"Temperature coefficient of NU\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real NTC = 0.0;\n    (* desc=\"Temperature coefficient of RD\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RDTC = 0.0;\n    (* desc=\"Temperature coefficient of RG\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RGTC = 0.0;\n    (* desc=\"Temperature coefficient of RS\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RSTC = 0.0;\n    (* desc=\"Temperature coefficient of RB\", units=\"(deg C)^-1\",\n       xyceUnit=\"U_DEGCM1\", xyceCategory=\"CAT_TEMP\" *)\n    parameter real RBTC = 0.0;\n\n    (* desc=\"Area factor\", units=\"\", type=\"instance\",\n       xyceUnit=\"U_NONE\", xyceCategory=\"CAT_SCALING\" *)\n    parameter real AREA = 1.0 from (0.0 : inf);\n\n    real phipog;\t\t// Gate pinch-off potential / V\n    real phipobi;\t\t// Intrinsic body pinch-off potential / V\n    real phipobe;\t\t// Extrinsic body pinch-off potential / V\n    real vt;\t\t\t// Thermal voltage / V\n    real mu0;\t\t\t// Low-field mobility / m^2 V^-1 s^-1\n    real vsat;\t\t\t// Saturation velocity / m s^-1\n    real lambda;\t\t// Channel length modulation / V^-1\n    real nu;\t\t\t// Channel length stabilisation / V^-1\n    real rd_noscale;\t\t// Unscaled drain resistance / ohm\n    real rg_noscale;\t\t// Unscaled gate resistance / ohm\n    real rs_noscale;\t\t// Unscaled source resistance / ohm\n    real rb_noscale;\t\t// Unscaled body resistance / ohm\n    real isg_noscale;\t\t/* Unscaled gate reverse-bias saturation\n\t\t\t\t   current / A */\n    real isb_noscale;\t\t/* Unscaled body reverse-bias saturation\n\t\t\t\t   current / A */\n    real phij0g;\t\t// Gate zero-bias junction potential / V\n    real phij0b;\t\t// Body zero-bias junction potential / V\n    real cj0g_noscale;\t\t/* Unscaled gate zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bi_noscale;\t\t/* Unscaled intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed_noscale;\t/* Unscaled drain extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real cj0bes_noscale;\t/* Unscaled source extrinsic body zero-bias\n\t\t\t\t   junction capacitance / F */\n    real goci_noscale;\t\t/* Unscaled intrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goced_noscale;\t\t/* Unscaled drain extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real goces_noscale;\t\t/* Unscaled source extrinsic open-channel\n\t\t\t\t   conductance / S */\n    real xii;\t\t\t// Intrinsic transport parameter / V^-1\n    real xied;\t\t\t// Drain extrinsic transport parameter / V^-1\n    real xies;\t\t\t// Source extrinsic transport parameter / V^-1\n    real vtobe;\t\t\t// Extrinsic body turn-off voltage / V\n    real vmaxg;\t\t\t// Gate forward-bias linearisation voltage / V\n    real vmaxb;\t\t\t// Body forward-bias linearisation voltage / V\n\n    real rd;\t\t\t// Drain resistance / ohm\n    real rg;\t\t\t// Gate resistance / ohm\n    real rs;\t\t\t// Source resistance / ohm\n    real rb;\t\t\t// Body resistance / ohm\n    real isg;\t\t\t// Gate reverse-bias saturation current / A\n    real isb;\t\t\t// Body reverse-bias saturation current / A\n    real cj0g;\t\t\t// Gate zero-bias junction capacitance / F\n    real cj0bi;\t\t\t/* Intrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bed;\t\t/* Drain extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real cj0bes;\t\t/* Source extrinsic body zero-bias junction\n\t\t\t\t   capacitance / F */\n    real goci;\t\t\t// Intrinsic open-channel conductance / S\n    real goced;\t\t\t// Drain extrinsic open-channel conductance / S\n    real goces;\t\t\t// Source extrinsic open-channel conductance / S\n\n    integer isinf_goced;\t// Infinity flag for goced variable\n    integer isinf_goces;\t// Infinity flag for goces variable\n\n    (* desc=\"Intrinsic output conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GOI;\n    (* desc=\"Intrinsic gate mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMGI;\n    (* desc=\"Intrinsic body mutual conductance\", units=\"S\",\n       multiplicity=\"multiply\" *)\n    real GMBI;\n    (* desc=\"Intrinsic gate-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGDI;\n    (* desc=\"Intrinsic gate-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CGSI;\n    (* desc=\"Intrinsic body-drain capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBDI;\n    (* desc=\"Intrinsic body-source capacitance\", units=\"F\",\n       multiplicity=\"multiply\" *)\n    real CBSI;\n\n    analog begin : top_level\n\treal vdsed;\t\t// Drain extrinsic drain-source voltage / V\n\treal vdsi;\t\t// Intrinsic drain-source voltage / V\n\treal vdses;\t\t// Source extrinsic drain-source voltage / V\n\treal vgdi;\t\t// Intrinsic gate-drain voltage / V\n\treal vgsi;\t\t// Intrinsic gate-source voltage / V\n\treal vbded;\t\t// Drain extrinsic body-drain voltage / V\n\treal vbdi;\t\t// Intrinsic body-drain voltage / V\n\treal vbsi;\t\t// Intrinsic body-source voltage / V\n\treal vbses;\t\t// Source extrinsic body-source voltage / V\n\n\t`INITIAL_MODEL begin : initial_model\n\t    real nadg;\t\t// Gate net dopant concentration / m^-3\n\t    real ndac;\t\t// Channel net dopant concentration / m^-3\n\t    real nadb;\t\t// Body net dopant concentration / m^-3\n\t    real lci;\t\t// Intrinsic channel length / m\n\t    real lced;\t\t// Drain extrinsic channel length / m\n\t    real lces;\t\t// Source extrinsic channel length / m\n\t    real aji;\t\t// Intrinsic junction area / m^2\n\t    real ajed;\t\t// Drain extrinsic junction area / m^2\n\t    real ajes;\t\t// Source extrinsic junction area / m^2\n\t    real hce;\t\t// Extrinsic channel height / m\n\t    real epss;\t\t// Semiconductor electric permittivity / F m^-1\n\t    real tnomk;\t\t// Absolute nominal temperature / K\n\t    real tempk;\t\t// Absolute device temperature / K\n\t    real tquot;\t\t// Device to nominal temperature quotient\n\t    real tdiff;\t\t// Device to nominal temperature difference / K\n\t    real vtnom;\t\t// Nominal thermal voltage / V\n\t    real dummy;\t\t// Placeholder variable\n\t    real n0c;\t\t// Channel electron concentration / m^-3\n\t    real p0c;\t\t// Channel hole concentration / m^-3\n\t    real efg;\t\t// Gate electrochemical potential / eV\n\t    real efc;\t\t// Channel electrochemical potential / eV\n\t    real efb;\t\t// Body electrochemical potential / eV\n\t    real sigmac;\t// Channel conductivity / S m^-1\n\n\t    if (!$param_given(LG) && $param_given(LC))\n\t\t`warning(\"LG is not given.\");\n\t    else if (!$param_given(LC) && $param_given(LG))\n\t\t`warning(\"LC is not given, setting it to LG.\");\n\t    if (LC == LG && $param_given(RIE))\n\t\t`warning(\"RIE is given but not used.\");\n\t    if (!$param_given(RD) && $param_given(RS))\n\t\t`warning(\"RD is not given.\");\n\t    else if (!$param_given(RS) && $param_given(RD))\n\t\t`warning(\"RS is not given.\");\n\t    if (!$param_given(RDTC) && $param_given(RSTC))\n\t\t`warning(\"RDTC is not given.\");\n\t    else if (!$param_given(RSTC) && $param_given(RDTC))\n\t\t`warning(\"RSTC is not given.\");\n\t    if (!$param_given(MTE1) && $param_given(MTE2))\n\t\t`warning(\"MTE1 is not given.\");\n\t    else if (!$param_given(MTE2) && $param_given(MTE1))\n\t\t`warning(\"MTE2 is not given.\");\n\t    if (MTE1 > 0.0 && MTE2 > 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both greater than zero.\");\n\t    if (MTE1 < 0.0 && MTE2 < 0.0)\n\t\t`warning(\"MTE1 and MTE2 are both less than zero.\");\n\n\t    if (TYPE != `N_TYPE && TYPE != `P_TYPE)\n\t\t`error(\"TYPE must be one (NR) or negative one (PR).\");\n\t    if (NAG < 0.0)\n\t\t`error(\"NAG is less than zero.\");\n\t    if (NDG < 0.0)\n\t\t`error(\"NDG is less than zero.\");\n\t    if (NAC < 0.0)\n\t\t`error(\"NAC is less than zero.\");\n\t    if (NDC < 0.0)\n\t\t`error(\"NDC is less than zero.\");\n\t    if (NAB < 0.0)\n\t\t`error(\"NAB is less than zero.\");\n\t    if (NDB < 0.0)\n\t\t`error(\"NDB is less than zero.\");\n\t    if (LG <= 0.0)\n\t\t`error(\"LG is less than or equal to zero.\");\n\t    if (LC <= 0.0)\n\t\t`error(\"LC is less than or equal to zero.\");\n\t    if (WC <= 0.0)\n\t\t`error(\"WC is less than or equal to zero.\");\n\t    if (HC <= 0.0)\n\t\t`error(\"HC is less than or equal to zero.\");\n\t    if (RIE < 0.0)\n\t\t`error(\"RIE is less than zero.\");\n\t    if (TOX < 0.0)\n\t\t`error(\"TOX is less than zero.\");\n\t    if (EPSR < 1.0)\n\t\t`error(\"EPSR is less than one.\");\n\t    if (MU0 <= 0.0)\n\t\t`error(\"MU0 is less than or equal to zero.\");\n\t    if (VSAT <= 0.0)\n\t\t`error(\"VSAT is less than or equal to zero.\");\n\t    if (LAMBDA < 0.0)\n\t\t`error(\"LAMBDA is less than zero.\");\n\t    if (NU < 0.0)\n\t\t`error(\"NU is less than zero.\");\n\t    if (RMIN <= 0.0)\n\t\t`error(\"RMIN is less than or equal to zero.\");\n\t    if (RD < 0.0)\n\t\t`error(\"RD is less than zero.\");\n\t    if (RG < 0.0)\n\t\t`error(\"RG is less than zero.\");\n\t    if (RS < 0.0)\n\t\t`error(\"RS is less than zero.\");\n\t    if (RB < 0.0)\n\t\t`error(\"RB is less than zero.\");\n\t    if (ISG < 0.0)\n\t\t`error(\"ISG is less than zero.\");\n\t    if (ISB < 0.0)\n\t\t`error(\"ISB is less than zero.\");\n\t    if (FC < 0.0 || FC > 1.0)\n\t\t`error(\"FC is less than zero or greater than one.\");\n\t    if (DELTA1 < 0.0 || DELTA1 > 1.0)\n\t\t`error(\"DELTA1 is less than zero or greater than one.\");\n\t    if (DELTA2 < 0.0 || DELTA2 > 1.0)\n\t\t`error(\"DELTA2 is less than zero or greater than one.\");\n\t    if (TNOM <= -`P_CELSIUS0)\n\t\t`error(\"TNOM is less than or equal to negative P_CELSIUS0.\");\n\t    if (DTEMP <= -$temperature)\n\t\t`error(\"DTEMP is less than or equal to negative $temperature.\");\n\t    if (MR < 0.0)\n\t\t`error(\"MR is less than zero.\");\n\n\t    if (TYPE == `N_TYPE) begin\n\t\tif (NAG <= NDG)\n\t\t    `error(\"NAG is less than or equal to NDG.\");\n\t\tif (NDC <= NAC)\n\t\t    `error(\"NDC is less than or equal to NAC.\");\n\t\tif (NAB <= NDB)\n\t\t    `error(\"NAB is less than or equal to NDB.\");\n\t    end\n\t    else begin\n\t\tif (NDG <= NAG)\n\t\t    `error(\"NDG is less than or equal to NAG.\");\n\t\tif (NAC <= NDC)\n\t\t    `error(\"NAC is less than or equal to NDC.\");\n\t\tif (NDB <= NAB)\n\t\t    `error(\"NDB is less than or equal to NAB.\");\n\t    end\n\t    if (LG <= 2.0 * TOX)\n\t\t`error(\"LG is less than or equal to twice TOX.\");\n\t    if (LC < LG)\n\t\t`error(\"LC is less than LG.\");\n\t    if (HC <= RIE + TOX)\n\t\t`error(\"HC is less than or equal to RIE plus TOX.\");\n\t    if (abs(MM) > 0.5 * (LC - LG))\n\t\t`error(\"Absolute MM is greater than half of sum LC minus LG.\");\n\n\t    nadg = TYPE * (NAG - NDG);\n\t    ndac = TYPE * (NDC - NAC);\n\t    nadb = TYPE * (NAB - NDB);\n\t    lci = LG - 2.0 * TOX;\n\t    lced = 0.5 * (LC - lci) + MM;\n\t    lces = 0.5 * (LC - lci) - MM;\n\t    aji = WC * lci;\n\t    ajed = WC * lced;\n\t    ajes = WC * lces;\n\t    hce = HC - RIE - TOX;\n\t    epss = `P_EPS0 * EPSR;\n\t    phipog = njf_sg_po_pot(nadg, ndac, epss, HC);\n\t    phipobi = njf_sg_po_pot(nadb, ndac, epss, HC);\n\t    phipobe = njf_sg_po_pot(nadb, ndac, epss, hce);\n\n\t    tnomk = `P_CELSIUS0 + TNOM;\n\t    tempk = $temperature + DTEMP;\n\t    tquot = tempk / tnomk;\n\t    tdiff = tempk - tnomk;\n\t    vtnom = $vt(tnomk);\n\t    vt = $vt(tempk);\n\t    mu0 = dual_pow_adapt(MU0, MR, tquot, MTE1, MTE2);\n\t    vsat = pow_adapt(VSAT, tquot, VTE);\n\t    lambda = lin_adapt(LAMBDA, tdiff, LTC);\n\t    if (lambda < 0.0) begin\n\t\t`warning(\"lambda is less than zero, setting it to zero.\");\n\t\tlambda = 0.0;\n\t    end\n\t    nu = lin_adapt(NU, tdiff, NTC);\n\t    if (nu < 0.0) begin\n\t\t`warning(\"nu is less than zero, setting it to zero.\");\n\t\tnu = 0.0;\n\t    end\n\t    rd_noscale = lin_adapt(RD, tdiff, RDTC);\n\t    rg_noscale = lin_adapt(RG, tdiff, RGTC);\n\t    rs_noscale = lin_adapt(RS, tdiff, RSTC);\n\t    rb_noscale = lin_adapt(RB, tdiff, RBTC);\n\t    isg_noscale = ISG * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    isb_noscale = ISB * exp(`W_EG0 * (1.0 / vtnom - 1.0 / vt));\n\t    dummy = ionisation(NDG, NAG, tempk, dummy, dummy, efg);\n\t    dummy = ionisation(NDC, NAC, tempk, n0c, p0c, efc);\n\t    dummy = ionisation(NDB, NAB, tempk, dummy, dummy, efb);\n\t    sigmac = `P_Q * (TYPE == `N_TYPE ? n0c : p0c) * mu0;\n\t    phij0g = TYPE * (efc - efg);\n\t    phij0b = TYPE * (efc - efb);\n\t    cj0g_noscale = pnj_cap(nadg, ndac, epss, phij0g, aji);\n\t    cj0bi_noscale = pnj_cap(nadb, ndac, epss, phij0b, aji);\n\t    cj0bed_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajed);\n\t    cj0bes_noscale = pnj_cap(nadb, ndac, epss, phij0b, ajes);\n\t    goci_noscale = sigmac * WC * HC / lci;\n\t    goced_noscale = sigmac * WC * hce / lced;\n\t    isinf_goced = (lced == 0.0);\n\t    goces_noscale = sigmac * WC * hce / lces;\n\t    isinf_goces = (lces == 0.0);\n\t    xii = mu0 / (vsat * lci);\n\t    xied = mu0 / (vsat * lced);\n\t    xies = mu0 / (vsat * lces);\n\t    vtobe = njf_sg_to_volt(phij0b, phipobe);\n\t    vmaxg = `FORWARD_COEFFICIENT * phij0g;\n\t    vmaxb = `FORWARD_COEFFICIENT * phij0b;\n\tend\n\n\t`INITIAL_INSTANCE begin\n\t    if (AREA <= 0.0)\n\t\t`error(\"AREA is less than or equal to zero.\");\n\n\t    if (RD == 0.0)\n\t\trd = 0.0;\n\t    else begin\n\t\trd = rd_noscale / AREA;\n\t\tif (rd < RMIN) begin\n\t\t    `warning(\"rd is less than RMIN, setting it to RMIN.\");\n\t\t    rd = RMIN;\n\t\tend\n\t    end\n\t    if (RG == 0.0)\n\t\trg = 0.0;\n\t    else begin\n\t\trg = rg_noscale / AREA;\n\t\tif (rg < RMIN) begin\n\t\t    `warning(\"rg is less than RMIN, setting it to RMIN.\");\n\t\t    rg = RMIN;\n\t\tend\n\t    end\n\t    if (RS == 0.0)\n\t\trs = 0.0;\n\t    else begin\n\t\trs = rs_noscale / AREA;\n\t\tif (rs < RMIN) begin\n\t\t    `warning(\"rs is less than RMIN, setting it to RMIN.\");\n\t\t    rs = RMIN;\n\t\tend\n\t    end\n\t    if (RB == 0.0)\n\t\trb = 0.0;\n\t    else begin\n\t\trb = rb_noscale / AREA;\n\t\tif (rb < RMIN) begin\n\t\t    `warning(\"rb is less than RMIN, setting it to RMIN.\");\n\t\t    rb = RMIN;\n\t\tend\n\t    end\n\t    isg = isg_noscale * AREA;\n\t    isb = isb_noscale * AREA;\n\t    cj0g = cj0g_noscale * AREA;\n\t    cj0bi = cj0bi_noscale * AREA;\n\t    cj0bed = cj0bed_noscale * AREA;\n\t    cj0bes = cj0bes_noscale * AREA;\n\t    goci = goci_noscale * AREA;\n\t    goced = goced_noscale * AREA;\n\t    goces = goces_noscale * AREA;\n\tend\n\n\tvdsed = TYPE * V(de_di);\n\tvdsi = TYPE * V(di_si);\n\tvdses = TYPE * V(si_se);\n\tvgdi = TYPE * V(gi_di);\n\tvgsi = TYPE * V(gi_si);\n\tvbded = TYPE * V(bi_de);\n\tvbdi = TYPE * V(bi_di);\n\tvbsi = TYPE * V(bi_si);\n\tvbses = TYPE * V(bi_se);\n\n\tI(de_di) <+ $simparam(\"gmin\", 0.0) * V(de_di);\n\tI(di_si) <+ $simparam(\"gmin\", 0.0) * V(di_si);\n\tI(si_se) <+ $simparam(\"gmin\", 0.0) * V(si_se);\n\tI(gi_di) <+ $simparam(\"gmin\", 0.0) * V(gi_di);\n\tI(gi_si) <+ $simparam(\"gmin\", 0.0) * V(gi_si);\n\tI(bi_de) <+ $simparam(\"gmin\", 0.0) * V(bi_de);\n\tI(bi_se) <+ $simparam(\"gmin\", 0.0) * V(bi_se);\n\n\tif (rd == 0.0)\n\t    V(d_de) <+ 0.0;\n\telse\n\t    I(d_de) <+ V(d_de) / rd;\n\n\tif (rg == 0.0)\n\t    V(g_gi) <+ 0.0;\n\telse\n\t    I(g_gi) <+ V(g_gi) / rg;\n\n\tif (rs == 0.0)\n\t    V(se_s) <+ 0.0;\n\telse\n\t    I(se_s) <+ V(se_s) / rs;\n\n\tif (rb == 0.0)\n\t    V(b_bi) <+ 0.0;\n\telse\n\t    I(b_bi) <+ V(b_bi) / rb;\n\n\tif (isg > 0.0) begin\n\t    I(gi_di) <+ TYPE * pnj_curr(isg, vgdi, vt, vmaxg);\n\t    I(gi_si) <+ TYPE * pnj_curr(isg, vgsi, vt, vmaxg);\n\tend\n\n\tif (isb > 0.0) begin\n\t    I(bi_de) <+ TYPE * pnj_curr(isb, vbded, vt, vmaxb);\n\t    I(bi_se) <+ TYPE * pnj_curr(isb, vbses, vt, vmaxb);\n\tend\n\n\tif (isinf_goced)\n\t    V(de_di) <+ 0.0;\n\telse begin : drain_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsed >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbdi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbded;\n\t    end\n\t    vds = mode * vdsed;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xied);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goced, vdslim, phijb, phipobe, xied);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bed, vbded, vbdi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bed, phij0b, vbded, vbdi, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(de_di) <+ mode * ids;\n\t    I(bi_de) <+ ddt(qbd);\n\t    I(bi_di) <+ ddt(qbs);\n\tend\n\n\tif (isinf_goces)\n\t    V(si_se) <+ 0.0;\n\telse begin : source_extrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdses >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvbs = vbses;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvbs = vbsi;\n\t    end\n\t    vds = mode * vdses;\n\t    if (vbs < vtobe)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal phijb;\t// Body junction potential / V\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tphijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t\tvdssat = njf_sg_sat_volt(phijb, phipobe, xies);\n\t\tvdslim = min(vds, vdssat);\n\t\tids = TYPE * njf_sg_curr(goces, vdslim, phijb, phipobe, xies);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bes, vbsi, vbses, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bes, phij0b, vbsi, vbses, vtobe,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    I(si_se) <+ mode * ids;\n\t    I(bi_si) <+ ddt(qbd);\n\t    I(bi_se) <+ ddt(qbs);\n\tend\n\n\tbegin : intrinsic_channel\n\t    integer mode;\t// Drain-source polarity\n\t    real vgs;\t\t// Gate-source voltage / V\n\t    real vbs;\t\t// Body-source voltage / V\n\t    real vds;\t\t// Drain-source voltage / V\n\t    real phijg;\t\t// Gate junction potential / V\n\t    real phijb;\t\t// Body junction potential / V\n\t    real vtog;\t\t// Gate turn-off voltage / V\n\t    real vtob;\t\t// Body turn-off voltage / V\n\t    real ids;\t\t// Drain-source current / A\n\t    real qgd;\t\t// Gate-drain charge / C\n\t    real qgs;\t\t// Gate-source charge / C\n\t    real qbd;\t\t// Body-drain charge / C\n\t    real qbs;\t\t// Body-source charge / C\n\t    real qg;\t\t// Gate charge / C\n\t    real qb;\t\t// Body charge / C\n\t    real tmp1, tmp2;\t// Temporary variables\n\n\t    if (vdsi >= 0.0) begin\n\t\tmode = `FORWARD_MODE;\n\t\tvgs = vgsi;\n\t\tvbs = vbsi;\n\t    end\n\t    else begin\n\t\tmode = `REVERSE_MODE;\n\t\tvgs = vgdi;\n\t\tvbs = vbdi;\n\t    end\n\t    vds = mode * vdsi;\n\t    phijg = soft_max(phij0g - vgs, 0.0, `FORWARD_SMOOTHING);\n\t    phijb = soft_max(phij0b - vbs, 0.0, `FORWARD_SMOOTHING);\n\t    vtog = njf_dg_to_volt(phij0g, phipog, phijb, phipobi);\n\t    vtob = njf_dg_to_volt(phij0b, phipobi, phijg, phipog);\n\t    if (vgs < vtog)\n\t\tids = 0.0;\n\t    else begin : current_calculation\n\t\treal vdssat;\t// Saturation drain-source voltage / V\n\t\treal vdslim;\t// Limited drain-source voltage / V\n\n\t\tvdssat = njf_dg_sat_volt(phijg, phipog, phijb, phipobi, xii);\n\t\tvdslim = soft_lim(vds, vdssat, CHI);\n\t\tids = TYPE * gca_curr_coef(vds, vdssat, lambda, nu)\n\t\t      * njf_dg_curr(goci, vdslim, phijg, phipog, phijb, phipobi,\n\t\t\t\t    xii);\n\t    end\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0g, vgdi, vgsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0g, phij0g, vgdi, vgsi, vtog,\n\t\t\t\t\t FC * phij0g, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqgd = tmp1;\n\t\tqgs = tmp2;\n\t    end\n\t    else begin\n\t\tqgd = tmp2;\n\t\tqgs = tmp1;\n\t    end\n\t    qg = qgd + qgs;\n\t    tmp1 = TYPE * njf_sg_gd_chrg(cj0bi, vbdi, vbsi, DELTA1);\n\t    tmp2 = TYPE * njf_sg_gs_chrg(cj0bi, phij0b, vbdi, vbsi, vtob,\n\t\t\t\t\t FC * phij0b, DELTA1, DELTA2);\n\t    if (mode == `FORWARD_MODE) begin\n\t\tqbd = tmp1;\n\t\tqbs = tmp2;\n\t    end\n\t    else begin\n\t\tqbd = tmp2;\n\t\tqbs = tmp1;\n\t    end\n\t    qb = qbd + qbs;\n\t    if (mode == `FORWARD_MODE)\n\t\tGOI = ddx(ids, V(di));\n\t    else\n\t\tGOI = ddx(ids, V(si));\n\t    GMGI = ddx(ids, V(gi));\n\t    GMBI = ddx(ids, V(bi));\n\t    CGDI = -ddx(qg, V(di));\n\t    CGSI = -ddx(qg, V(si));\n\t    CBDI = -ddx(qb, V(di));\n\t    CBSI = -ddx(qb, V(si));\n\t    I(di_si) <+ mode * ids;\n\t    I(gi_di) <+ ddt(qgd);\n\t    I(gi_si) <+ ddt(qgs);\n\t    I(bi_di) <+ ddt(qbd);\n\t    I(bi_si) <+ ddt(qbs);\n\tend\n    end\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (EPSR < 1.0 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (EPSR < 1.0)\n\n Correction Criteria：Missing closing parenthesis ')' for the condition expression in the if statement."
      }
    ]
  }
]