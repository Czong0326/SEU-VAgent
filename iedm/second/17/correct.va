`include "discipline.h"
`include"constants.h"


// $Date: 1997/08/28 05:53:32 $
// $Revision: 1.1 $
//
//
// Based on the OVI Verilog-A Language Reference Manual, version 1.0 1996
//
//

`define PI  	3.14159265358979323846264338327950288419716939937511
`define ABSTOL_TIME 1e-12



//--------------------
// power_meter
//
// -  Power meter
//
// iin:		input for current passing through the meter [V,A]
// vp_iout:	positive voltage sending terminal and output for current
//              passing through the meter [V,A]
// vn:		negative voltage sensing terminal [V,A]
// pout:	measured impedance converted to a voltage [V]
// va_out:	measured apparent power [W]
// pf_out:	measured power factor []
//
// INSTANCE parameters
//    tstart      = time to wait before starting measurement [s]
//    bw          = bw of rms filters (a first order filter) [Hz]
//    log_to_file = whether to log the results to a file; yes or no []
//    filename    = The name of the file in which the results are logged []
//
// MODEL parameters
//    {none}
//
// In order to measure the power being dissipated in a 2 port device,
// this meter should be placed in the netlist so that the current flowing
// into the device passes between 'iin' and 'vp_iout' first,
// that 'vp_iout' is connected to the positive terminal of the device and
// that 'vn' is connected to the negative terminal of the device.
//
// The measured power is the average over time of the product of the voltage
// across and the current through the device. This average is calculated by
// integrating the VI product and dividing by time and passing the result
// through a first order filter with bandwidth 'bw'.
// 
// The apparent power is calculated by finding the rms values of the current
// and voltage first and filtering them with a first order filter of
// bandwidth, 'bw'. The apparent power is the product of the voltage and
// current rms values.
//
// The purpose of the filtering is to remove ripple.
// It is recommended that the 'bw' be set to a low value in order to
// produce accurate measurements and that at least 10 input ac cycles be
// allowed before the power_meter is considered settled. Also allow time
// for the filters to settle.
//
// This meter requires accurate integration so it is desirable that the
// integration method is set to 'gear2only' in the netlist
//

nature P_Power
	abstol = 1n;
	huge = 100M;
	units = "Watts";
	access = Pow;
endnature

nature PowerFactor
	abstol = 1m;
	units = "{none}";
	huge = 100M;
	access = PF;
endnature

discipline power_current
	potential P_Power;
	flow Current;
enddiscipline

discipline power_factor_current
	potential PowerFactor;
	flow Current;
enddiscipline
	
(* instrument_module *)
module power_meter(iin,vp_iout,vn,pout, va_out, pf_out);
electrical iin, vp_iout, vn;
power_current pout;
power_current va_out;
power_factor_current pf_out;
parameter real tstart = 0 from [0:inf);
parameter real bw = 10 from (0:inf);
parameter integer log_to_file = 0;

   electrical v_ifilt1, v_ifilt2;
   electrical v_vfilt1, v_vfilt2;
   electrical v_pfilt1, v_pfilt2;
   electrical vgnd;

   svcvs  #(.poles({-2*`PI*bw,0}) ) irms_filter (v_ifilt2,vgnd,v_ifilt1,vgnd);
   svcvs  #(.poles({-2*`PI*bw,0}) ) vrms_filter (v_vfilt2,vgnd,v_vfilt1,vgnd);
   svcvs  #(.poles({-2*`PI*bw,0}) ) power_filter (v_pfilt2,vgnd,v_pfilt1,vgnd);

   integer out_file;

   real temp_var;

   real vin_val;
   real iin_val;

   real v_vfilt1_val;
   real v_ifilt1_val;
   real v_pfilt1_val;

   real irms;
   real vrms;

   real integ_vin_sqd; // Need to integrate squares of vin,iin because 
   real integ_iin_sqd; //  impedance measurement is based on rms values

   real integ_iin_vin; // Need this to calculate real power

   real pout_val;	// measured real power
   real va_out_val;	// measured apparent power
   real pf_out_val;    // measured power factor angle

   real input_expr;


   analog begin
      @ ( initial_step ) begin
         if (log_to_file) begin
             out_file = $fopen( "%C:r.dat" );
             $fstrobe(out_file,"# Generated by Spectre from module `%M'");
         end
      end

      V(vgnd) <+ 0;

      // so that device is not intrusive
      V(iin,vp_iout) <+ 0;

      vin_val = V(vp_iout,vn);
      iin_val = I(iin,vp_iout);

      // vrms calculation 
      //
      if ($abstime > tstart)
          input_expr = vin_val*vin_val;
      else
	  input_expr = 0;
      integ_vin_sqd  = idt(input_expr,0);

      if ($abstime > tstart) begin
         if (($abstime-tstart) > `ABSTOL_TIME) begin	// to avoid div by zero error
            v_vfilt1_val = sqrt(integ_vin_sqd/($abstime-tstart));
         end
      end else begin
          v_vfilt1_val = 0;
      end

      V(v_vfilt1) <+ v_vfilt1_val;
      vrms = V(v_vfilt2);

      // irms calculation 
      //
      if ($abstime > tstart) 
	   input_expr = iin_val*iin_val;
      else
	   input_expr = 0.0;
      integ_iin_sqd  = idt(input_expr,0 );
      if ($abstime > tstart) begin

         if (($abstime-tstart) > `ABSTOL_TIME) begin	// to avoid div by zero error
            v_ifilt1_val = sqrt(integ_iin_sqd/($abstime-tstart));
         end
      end else begin
          v_ifilt1_val = 0;
      end

      V(v_ifilt1) <+ v_ifilt1_val;
      irms = V(v_ifilt2);

      // apparent power calculation
      va_out_val = irms*vrms;

      // real power calculation 
      //
      if ($abstime > tstart) 
	    input_expr = iin_val*vin_val;
      else
	    input_expr = 0;
      integ_iin_vin  = idt(input_expr,0);
      if ($abstime > tstart) begin

         if (($abstime- tstart) > `ABSTOL_TIME) begin	// to avoid div by zero error
            v_pfilt1_val = integ_iin_vin/($abstime-tstart);
         end
      end else begin
          v_ifilt1_val = 0;
      end

      V(v_pfilt1) <+ v_pfilt1_val;
      pout_val = V(v_pfilt2);


      // pf_out_val calculation
      //
      if ( va_out_val > pout.potential.abstol )  begin
         temp_var        = pout_val/va_out_val;
         temp_var        = max(temp_var,-1);
         temp_var        = min(temp_var,1);
         pf_out_val = temp_var;
      end else begin
         pf_out_val = 0;
      end

      if (log_to_file) begin
         $fstrobe(out_file, "%-.10g\t%-.10g\t%-.10g\t%-f",
                             $abstime, pout_val, va_out_val, pf_out_val);
      end

      Pow(pout)    <+ pout_val;
      Pow(va_out)  <+ va_out_val;
      PF(pf_out) <+ pf_out_val;

      @ ( final_step ) begin
         if (log_to_file) $fclose(out_file);
      end
   end
endmodule
