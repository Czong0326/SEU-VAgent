// *****************************************************************************************
// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****
// *****************************************************************************************

// *******************************************************************
// Copyright @ 2014 Stanford University (Stanford)
// The terms under which the software and associated documentation (the Software) is provided are as the following:
// The Software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.
// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:
// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.
// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.
// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.
// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.

// Agreed to by 
// H.-S. Philip Wong, Stanford University
// May 4, 2014
// *******************************************************************

// *******************************************************************
// Developer:
// Chi-Shuen (Vince) Lee
// Stanford University
// Email: chishuen@stanford.edu
// *******************************************************************

// *******************************************************************
// Revision Log
// *******************************************************************
// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee
// Remove unused variables and hidden state
// change the module name to be consistent with the file name
// change limexp() to exp() in all the non-genvar for-loops
// *******************************************************************
// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee
// Remove duplicate variables
// Modify the charge model to avoid differentiation problem at 
// vds = 0
// *******************************************************************
// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee
// Cosmetic update
// *******************************************************************
// 04/15/2014  by Chi-Shuen (Vince) Lee
// Create VSCNFET model Version 1.0.0
// *******************************************************************

// Equation numbers reference (included in the same package): 
// Stanford University Virtual-Source Carbon Nanotube Field-Effect 
// Transistors Model Version 1.0.1 Technical User's Manual

`include "constants.vams"
`include "disciplines.vams"

`define NMOS 1
`define PMOS -1

`define  SMALL_VALUE  (1e-20)

module vscnfet_1_0_1(D,G,S);
    inout D, G, S;
    electrical D, G, S;
    electrical Di, Si;  // Internal nodes
    
    // Version
    parameter real version    = 1.01 from (0:inf);
    // NMOS or PMOS
    parameter integer FETtype = `NMOS from [-1:1] exclude 0;
    // Geometry and design parameters
    parameter real Lg         = 10e-9 from (0:inf);        // gate length
    parameter real Lc         = 11e-9 from (0:inf);        // Contact length
    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length
    parameter real W          = 1000e-9 from (0:inf);      // Device width
    parameter real Hg         = 15e-9 from (0:inf);        // Gate height
    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness
    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant
    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material
    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer
    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate
    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter
    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform
    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)
    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage
    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening
    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance
    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.
    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling
    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on
    
    // CarrierDensity: carrier density in CNT, analytical approximation
    analog function real CarrierDensity;
        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi
        real Eg, Ef;
        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;
        integer i;
        begin
            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;
            n      = 0;
            P_1_vt = 1/$vt;
            Evh[0] = Eg/2;
            Evh[1] = Eg;
            for (i = 0;i<2;i = i+1) begin
                x     = exp((Evh[i]-Ef)*P_1_vt);
                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;
                a0    = 1/(1+x);
                a1    = -x*P_1_vt/((1+x)*(1+x));
                del   = Ef + $vt*ln(1+x);
                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);
                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));
                fsmo  = 1/(1+pow(x,-1.3));
                n     = n + (n1*fsmo + n2*(1-fsmo));
            end
            CarrierDensity = n;
        end
    endfunction  // CarrierDensity
    
    // CapGAA: Capacitance of a gate-all-around structure
    analog function real CapGAA;
        input d, tox, kox;
        real d, tox, kox;
        begin
            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)
        end
    endfunction // CapGAA
    
    // CapTopGate: Capacitance of a top-gate structure
    analog function real CapTopGate;
        input s, d, tox, kox, Ncnt, scmod;
        real s, d, tox, kox;
        integer Ncnt, scmod;
        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;
        begin
            ksub  = 3.9;
            r     = d/2;
            h     = tox + r;
            n1    = `M_PI*`P_EPS0*kox;
            c1    = (kox-ksub)/(kox+ksub);
            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)
            if ( scmod == 0 ) begin
                CapTopGate = cgc_s*Ncnt;
            end else begin
                if ( Ncnt == 1 ) begin
                    CapTopGate = cgc_s;
                end else begin
                    sq_h2_r2   = sqrt(h*h-r*r);
                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));
                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));
                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)
                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)
                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)
                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)
                end
            end
        end
    endfunction // CapTopGate
    
    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.
    analog function real CNTMobility;
        input Lg, d;
        real Lg, d;
        real mu0, lmu, cmu; // Empirical fitting parameters
        begin
            mu0         = 0.135;
            lmu         = 66.2e-9;
            cmu         = 1.5;
            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)
        end
    endfunction // CNTMobility
    
    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder
    analog function real ScaleLength_GAA;
        input kch, kox, d, tox;
        real kch, kox, d, tox;
        real z0, del, del2, b;
        begin 
            z0              = 2.4048;
            del             = d*z0/(d+2*tox);
            del2            = del*del;
            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)
            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)
        end
    endfunction // ScaleLength_GAA
    
    // CNTVelocity: virtual source velocity
    analog function real CNTVelocity;
        input d, Lg;
        real d, Lg;
        real vB0, d0, mfpv, vB; // Empirical fitting parameters
        begin
            vB0         = 4.1e5;
            d0          = 1.2e-9;
            mfpv        = 440e-9;
            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)
            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)
        end
    endfunction // CNTVelocity
    
    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]
    // Based on transmission line model
    analog function real ContactRes;     // Eq. (20) and (21)
        input Lc, d, Rcmod;
        real Lc, d;
        integer Rcmod;
        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;
        begin
            rq  = 6.4707e3;
            mfp = 380e-9;
            if ( Rcmod == 0 ) begin
                ContactRes = rq/2;
            end else begin
                if ( Rcmod == 1 ) begin
                    gco  = 490;
                    E00  = 0.032;
                    Eg   = 0.852/(d*1e9);
                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact
                    gc   = gco*exp(-phib/E00);
                end else begin
                    gc = 2e3;
                end
                beta       = gc*rq/2;
                gamma      = sqrt(2/mfp*beta+beta*beta);
                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); 
            end
        end
    endfunction // ContactRes
    
    // ExtensionRes: Source/Drain extension resistance
    // An empirical function fitted to low-bias Landauer formula
    analog function real ExtensionRes;    // Eq. (23)
        input Lext, n, d;
        real Lext, n, d;
        real rsd0, npow, dpow;  // Empirical fitting parameters
        begin
            rsd0         = 35;
            npow         = 2.1;
            dpow         = 2;
            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));
        end
    endfunction // ExtensionRes
    
    // SDTProb: Calculate S-D tunneling probability
    analog function real SDTProb;    // Eq. (26)-(32)
        input Et,El,Ei,L,Eg,lambda;
        real Et,El,Ei,L,Eg,lambda;
        real a, b, x0, x1, zeta, zeta2, y0, y1;
        real rb, z, theta;
        begin
            a = -(Et-El)/(exp(L/lambda)-1);   
            b = Et-a;
            if (Et > Ei+Eg) begin
                x0 = -1;
            end else begin
                x0 = 1-2*(a+b-Ei)/Eg;
            end
            x1    = 1;
            zeta  = 2*(b-Ei)/Eg-1;
            zeta2 = zeta*zeta;
            
            if (zeta2 >= 1) begin
                // first part of the integration of sqrt(1-x^2)/(x+zeta)  
                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);
                z  = zeta*x0+1;
                if (z == 0) begin
                    theta = -`M_PI/2;
                end else begin
                    if (z > 0) begin
                        theta = atan(rb)-`M_PI;
                    end else begin
                        theta = atan(rb);
                    end
                end 
                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);
                
                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) 
                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);
                z  = zeta*x1+1;
                if (z == 0) begin
                    theta = -`M_PI/2;
                end else begin
                    if (z > 0) begin
                        theta = atan(rb)-`M_PI;
                    end else begin
                        theta = atan(rb);
                    end
                end 
                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)
                SDTProb = (y1-y0)*lambda;
            end else begin
                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)
                SDTProb = y0*lambda;
            end
        end
    endfunction // SDTProb
    
    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]
    // Returned qs and qd are always >= 0
    analog function real TerminalCharge;
        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;
        output qd;
        integer Ncnt;
        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;
        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;
        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;
        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;
        begin
            Eg     = 0.852/(d*1e9);
            nb     = 1.5;
            alphab = 3.5;
            avt    = alpha*$vt;
            bvt    = alphab*$vt;
            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)
            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)
            cinv   = cox*cqeff/(cox+cqeff);
            cqinf  = 3.2e-10*Ncnt;
            cinvb  = cox*cqinf/(cox+cqinf);
            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)
            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)
            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)
            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)
            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)
            vgt    = qcha/cinv;                                                     // Eq. (45.4)
            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)
            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)
            eta    = 1-Fsatq;                                                       // Eq. (45.1)
            eta2   = eta*eta;
            eta3   = eta2*eta;
            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)
            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)
            zeta   = 1.0;
            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)
            kqb2   = kqb*kqb;
            sq_kqb = sqrt(kqb);
            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);
            if ( vdsi < tol ) begin
                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);
                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);
            end else begin 
                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)
                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)
            end
            Fsatq2         = Fsatq*Fsatq;
            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)
            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;
            TerminalCharge = qs;
        end
    endfunction // TerminalCharge
    
    // CapFringe: one-sided fringe capacitance (top-gate) [F]
    analog function real CapFringe;
        input Lext, tox, kspa, d, s, Ncnt, scmod;
        integer scmod;
        real Lext, tox, kspa, d, s, Ncnt;
        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;
        begin
            tao1 = 2.5;
            tao2 = 2;
            h    = tox+d/2;
            sr   = 0.5;
            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;
            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);
            if ( Ncnt == 1 || scmod == 0 ) begin
                CapFringe = A/B*Ncnt;
            end else if ( Ncnt == 2 ) begin
                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);
            end else begin
                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);
                alpha     = exp((Ncnt-3)/tao2/Ncnt);
                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);
                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;
                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;
            end
        end
    endfunction // CapFringe
    
    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]
    analog function real CapGateToContact;
        input Lext, Lg, Hg, kspa, W;
        real Lext, Lg, Hg, kspa, W;
        real tao, alpha;
        begin
            alpha            = 1;
            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));
            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;
        end
    endfunction // CapGateToContact
    
    // Local variable
    integer dir; // Direction of current flow
    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;
    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;
    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param
    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables
    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;
    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;
    // Local variable: source-to-drain tunneling
    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;
    integer N_tun;
    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;
    real Lof_dt, Lh, psys;
    // Local variable: band-to-band tunneling
    real Ibtbt, lam_btb;
    real Ew, zeta;
    
    analog begin
        // Bias calculation
        vd  = V(D);
        vg  = V(G);
        vs  = V(S);
        vdi = V(Di);
        vsi = V(Si);
        
        vgsraw = FETtype*(vg-vsi);
        vgdraw = FETtype*(vg-vdi);
        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS
            vdsi = FETtype*(vdi-vsi);
            vgsi = vgsraw;
            dir  = 1;
        end
        else begin
            vdsi = FETtype*(vsi-vdi);
            vgsi = vgdraw;
            dir  = -1;
        end
        
        // Basic device variables
        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)
        vF    = 1e6;
        mfpv  = 440e-9;
        h_bar = `P_H/`M_PI/2;
        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate
        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions
        
        // Virtual source parameters
        vtha = 0.0;
        if ( Geomod == 1) begin  // GAA
            cox = CapGAA(d,tox,kox)*Ncnt;
        end else if ( Geomod == 2 ) begin  // Top-gate with screening
            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );
        end else begin  // Top-gate without screening
            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );
        end
        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)
        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)
        mu    = CNTMobility(Lg,d);                // carrier mobility
                                                  // short-channel effects
        lambda = ScaleLength_GAA(kch,kox,d,tox);
        lof    = tox/3;
        lt     = Lg+lof*2;
        expeta = exp(-lt/lambda/2);
        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)
        dibl   = expeta;                // DIBL;  Eq. (13.2)
        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)
        vxo    = CNTVelocity( d,Lg );   // virtual source velocity
                                        // Series resistance per CNFET per side
        if ( Rcmod == 0 ) begin
            rs = Rs0/Ncnt;
        end else begin
            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;
        end
        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage
        alpha = 3.5;                         // Default value
        beta  = 1.8;                         // Default value
        nd    = 0;                           // Default value
        
        // Virtual Source Current
        alpha_vt  = alpha*$vt;
        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)
        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)
        nss       = n0+nd*vdsi;
        nss_vt    = nss*$vt;
        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)
        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)
        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)
        vds_vdsat = vdsi/vdsat;
        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)
        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)

        I(Di,Si) <+ Ivs;
        
        
        // Direct Source-to-Drain Tunneling
        phi_on  = 0.05;
        N_tun   = 100;
        ScatFac = mfpv/(mfpv+2*Lg);
        
        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)
        Lh     = Lg/2+Lof_dt;
        aEt    = 0.05;
        psys   = 0.0;
        if ( SDTmod == 0 ) begin
            Idsdt = 0;
        end else begin
            Idsdt = 0;
            if ( SDTmod == 1 ) begin
                if ( Qxo == 0 ) begin
                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;
                end else begin
                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;
                end
            end else begin
                Qmin = limexp((Efsd-Eg+phi_on)/$vt);
                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;
            end
            Et0   = Eg/2-psys;
            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;
            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.
            dE    = (Eitop+Efsd)/N_tun;
            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin
                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );
                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );
                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));
                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));
                Idsdt = Idsdt+Ii;
            end
            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;
        end
        I(Di,Si) <+ Idsdt;
        
        // Junction Band-to-Band Tunneling
        Ibtbt   = 0;
        lam_btb = (0.092*kspa+2.13)*1e-9;
        
        if (vdsi > Eg && BTBTmod == 1) begin
            Ew = vdsi-Eg;
            dE = Ew/N_tun;
            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin
                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)
                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)
                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)
                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)
                Ibtbt = Ibtbt+Ii;
            end
            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;
        end
        I(Di,Si) <+ Ibtbt;
        
        // ******** Series Resistance ********
        if (rs > 0) begin
            I(D,Di) <+ (vd-vdi)/rs;
            I(Si,S) <+ (vsi-vs)/rs;
        end else begin
            V(D,Di) <+ 0.0;
            V(Si,S) <+ 0.0;
        end
        
        // ******** Terminal Charge ********
        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0
        if ( dir == 1 ) begin
            qsi = FETtype*qs;
            qdi = FETtype*qd;
        end else begin
            qsi = FETtype*qd;
            qdi = FETtype*qs;
        end
        I(S,G) <+ ddt(qsi);
        I(D,G) <+ ddt(qdi);
        
        // ******** Parasitic Capacitance ********
        if ( Geomod == 2 ) begin 
            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);
        end else begin
            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);
        end
        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);
        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;
        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;
        I(S,G) <+ ddt(qspar);
        I(D,G) <+ ddt(qdpar);
        
    end // analog
    
    
endmodule
