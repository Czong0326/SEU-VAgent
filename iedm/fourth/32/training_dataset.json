[
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        tbd   = SDTProb( Et,-Efsd+vdsi,Ei,Lh,Eg,lambda ); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n\n Correction Criteria：Changed the sign of vdsi from minus to plus. This incorrectly increases the drain-side energy barrier by vdsi instead of decreasing it, violating the voltage drop physics and undercalculating tunneling current."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        real Lext, Lg, Hg, kspa; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        real Lext, Lg, Hg, kspa, W;\n\n Correction Criteria：Removed 'W' from the variable declaration list. This causes the function to lose access to the device width parameter, making the capacitance calculation (cgtc = CapGateToContact(...)) use an undefined 'W' value. This results in incorrect parasitic capacitance values and potential simulation errors due to undefined variables."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nqdi = qs; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nqdi = FETtype*qs;\n\n Correction Criteria：Missing FETtype multiplier for PMOS charge sign correction. In the else branch (dir=-1), the drain charge (qdi) must be multiplied by FETtype (-1 for PMOS) to maintain correct charge polarity. Without this, PMOS devices will have inverted drain charge signs, distorting terminal charge calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        if (rs < 0) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        if (rs > 0) begin\n\n Correction Criteria：Changed resistance check from positive to negative. Since resistance values are always non-negative, this condition will never be true. This error disables the series resistance branch even when resistance is present, causing incorrect current modeling."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nif (zeta2 <= 1) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nif (zeta2 >= 1) begin\n\n Correction Criteria：Changed the condition from 'zeta2 >= 1' to 'zeta2 <= 1', reversing the logical branch selection for tunneling probability calculation. This causes the SDTProb function to use the complex integration path (Eq 32.1) for small |zeta| values and the simplified path (Eq 32.2) for large |zeta| values, inverting the proper mathematical behavior for source-drain tunneling."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        nsd   = CarrierDensity(Eg,Efsd-Eg/2);  // Doping density in S/D extensions Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n\n Correction Criteria：Changed Fermi level calculation from Efsd+Eg/2 to Efsd-Eg/2. This incorrectly positions the Fermi level below the valence band instead of above it, violating the design assumption that Efsd is measured from the conduction band edge. This will cause negative carrier density calculations and break series resistance computations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter integer Geomod  = 1 from [1:2];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n\n Correction Criteria：The valid range for Geomod is reduced from [1:3] to [1:2], excluding value 3. This prevents users from selecting the top-gate without screening structure (Geomod=3), causing the model to clamp or reject this valid configuration."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nIdsdt = Idsdt - Ii; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nIdsdt = Idsdt+Ii;\n\n Correction Criteria：Changed '+' to '-' in the accumulation of S-D tunneling current components. This inverts the sign of each tunneling contribution, causing the total tunneling current to flow in the opposite direction and violating the physical behavior described in Eq. (24) of the model."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nLof_dt = (0.0263*kspa+0.056)/tox;    // Eq. (33) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nLof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n\n Correction Criteria：Division replaces multiplication, making Lof_dt inversely proportional to tox instead of proportional. This inverts the physical relationship where fringe length should increase with oxide thickness, causing significant errors in tunneling calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nvdsat     = vdsats*(1-Ff)-$vt*Ff;                                         // Eq (1.5) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nvdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n\n Correction Criteria：Changed '+' to '-' in vdsat calculation. This inverts the thermal voltage contribution, causing underestimation of saturation voltage in subthreshold region and potential negative vdsat values during diffusion-dominated transport."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Ffb    = 1/(1+exp((vgsi-(vthb+bvt/2))/bvt));                            // Eq. (1.2) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n\n Correction Criteria：Changed the offset term from subtraction to addition. Original used (vthb - bvt/2) to set the transition point, but modification uses (vthb + bvt/2). This shifts the smoothing function threshold by bvt (~90mV at room temp), causing incorrect charge calculations in the subthreshold region and affecting the entire IV characteristic."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\ngamma      = sqrt(2/mfp*beta - beta*beta); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\ngamma      = sqrt(2/mfp*beta+beta*beta);\n\n Correction Criteria：Changed the '+' to '-' in the gamma calculation. This makes the expression under the square root potentially negative for certain parameter values, causing NaN errors during simulation. The original additive term ensured positive values for physical consistency in contact resistance modeling."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            cqinf  = 3.2e-10/Ncnt; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            cqinf  = 3.2e-10*Ncnt;\n\n Correction Criteria：Changed multiplication to division, causing inversion charge quantum capacitance (cqinf) to decrease with increasing CNT count (Ncnt) instead of increasing. This violates the physical principle that total quantum capacitance should scale with the number of parallel conduction paths."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nIi    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt));    // Eq. (24) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nIi    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n\n Correction Criteria：Removed closing parenthesis for the second Fermi function, causing incorrect Fermi level calculation in BTBT current. This makes the exponent term '((Ei-Efsd)/$vt' instead of '((Ei-Efsd)/$vt)', disrupting the tunneling probability calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nif ( Qxo != 0 ) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nif ( Qxo == 0 ) begin\n\n Correction Criteria：The condition is inverted. When Qxo is zero, the logarithmic formula is incorrectly used instead of the safe fallback, causing ln(0) → -∞ in psys calculation and invalid tunneling current."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nmodule vscnfet_1_0_1(D,S,G); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nmodule vscnfet_1_0_1(D,G,S);\n\n Correction Criteria：Swapped gate (G) and source (S) terminals in port order. This reverses gate and source connections, causing incorrect biasing and terminal functions since gate controls channel while source is the reference terminal."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nfor ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei-dE ) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nfor ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n\n Correction Criteria：Changed loop increment from +dE to -dE. This reverses the energy integration direction, causing the loop to start at -Efsd+dE/2 and move downward (away from Eitop) instead of upward. The loop will either run indefinitely (if Eitop is very low) or skip all valid energies, resulting in zero SDT current calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    Ibtbt   = 1e-9; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    Ibtbt   = 0;\n\n Correction Criteria：Initializes band-to-band tunneling current with 1nA offset instead of zero, introducing constant error in BTBT current calculation under enabled conditions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nrs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nss,d))/Ncnt; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nrs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n\n Correction Criteria：Changed nsd (doping density) to nss (subthreshold slope factor) in ExtensionRes, causing incorrect carrier density input for source/drain extension resistance calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nA    = sr*2*`M_PI*kspa*`P_EPS0/Lext; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nA    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n\n Correction Criteria：Changed multiplication by Lext to division, inverting the physical relationship where fringe capacitance should increase with longer extensions but now decreases instead."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real Efsd       = 0.258 from (-0.2,0.5);     // Fermi level to the band edge at source/drain (eV) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n\n Correction Criteria：Replaced colon with comma in range expression, causing syntax error. Verilog-A range specifier requires colon (':') between min/max values."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        I(Di,Si) <+ Ibtbt Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        I(Di,Si) <+ Ibtbt;\n\n Correction Criteria：Missing semicolon at the end of the statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        endfuncton  // CarrierDensity Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        endfunction  // CarrierDensity\n\n Correction Criteria：Misspelled 'endfunction' keyword as 'endfuncton' causing unrecognized directive error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nIdsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nIdsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n\n Correction Criteria：Missing semicolon at end of statement causes syntax error in assignment"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            dpow         := 2; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            dpow         = 2;\n\n Correction Criteria：Invalid assignment operator ':=' used instead of '='. VerilogA requires '=' for variable assignments."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        real Lc d; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        real Lc, d;\n\n Correction Criteria：Missing comma between variable declarations in a real type statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real Vfb        = 0 from (-inf:inf)         // Flat band voltage Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n\n Correction Criteria：Missing semicolon at the end of the parameter declaration. VerilogA requires all statements to terminate with a semicolon."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n                B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n                B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n\n Correction Criteria：Missing closing parenthesis for the acosh function call and pow arguments"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2)  // Doping density in S/D extensions Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        CapFringe = A/B*Ncnt Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        CapFringe = A/B*Ncnt;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement, which is required to terminate statements in VerilogA"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n            d0          = 1.2e-9 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n            d0          = 1.2e-9;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        vdi = V(Di) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        vdi = V(Di);\n\n Correction Criteria：Missing semicolon at end of statement. VerilogA requires all statements to end with a semicolon."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        A    = sr*2*`M_PI*kspa*`P_EPS0*Lext Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement, causing unterminated expression."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\ndE = Ew/N_tun Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\ndE = Ew/N_tun;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Lh     = Lg/2+Lof_dt Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Lh     = Lg/2+Lof_dt;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        real a, b, x0, x1, zeta zeta2, y0, y1; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n\n Correction Criteria：Missing comma between 'zeta' and 'zeta2', causing a syntax error where two identifiers appear consecutively without an operator or separator."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        theta = atan(rb; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        theta = atan(rb);\n\n Correction Criteria：Missing closing parenthesis in function call to atan, resulting in unmatched parentheses syntax error."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nn2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nn2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n\n Correction Criteria：Missing closing parenthesis for the ln function call. The expression inside ln should be properly closed with parentheses."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n                if (z > 0 begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n                if (z > 0) begin\n\n Correction Criteria：Missing closing parenthesis ')' in the condition of the if statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n// *****************************************************************************************\n// **** Stanford Virtual-Source Carbon Nanotube Field-Effect Transistor (VSCNFET) Model ****\n// *****************************************************************************************\n\n// *******************************************************************\n// Copyright @ 2014 Stanford University (Stanford)\n// The terms under which the software and associated documentation (the Software) is provided are as the following:\n// The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n// Stanford grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the users organization and externally, subject to the following restrictions:\n// 1. The users agree not to charge for the Stanford code itself but may charge for additions, extensions, or support.\n// 2. In any product based on the Software, the users agree to acknowledge the Stanford Nanoelectronics Research Group of Prof. H.-S. Philip Wong that developed the software and cite the relevant publications that form the basis of the Software. This acknowledgment shall appear in the product documentation.\n// 3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n// 4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n\n// Agreed to by \n// H.-S. Philip Wong, Stanford University\n// May 4, 2014\n// *******************************************************************\n\n// *******************************************************************\n// Developer:\n// Chi-Shuen (Vince) Lee\n// Stanford University\n// Email: chishuen@stanford.edu\n// *******************************************************************\n\n// *******************************************************************\n// Revision Log\n// *******************************************************************\n// 04/01/2015  version = 1.0.1  by Chi-Shuen (Vince) Lee\n// Remove unused variables and hidden state\n// change the module name to be consistent with the file name\n// change limexp() to exp() in all the non-genvar for-loops\n// *******************************************************************\n// 02/27/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Remove duplicate variables\n// Modify the charge model to avoid differentiation problem at \n// vds = 0\n// *******************************************************************\n// 01/20/2015  version = 1.0.0  by Chi-Shuen (Vince) Lee\n// Cosmetic update\n// *******************************************************************\n// 04/15/2014  by Chi-Shuen (Vince) Lee\n// Create VSCNFET model Version 1.0.0\n// *******************************************************************\n\n// Equation numbers reference (included in the same package): \n// Stanford University Virtual-Source Carbon Nanotube Field-Effect \n// Transistors Model Version 1.0.1 Technical User's Manual\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\n`define NMOS 1\n`define PMOS -1\n\n`define  SMALL_VALUE  (1e-20)\n\nmodule vscnfet_1_0_1(D,G,S);\n    inout D, G, S;\n    electrical D, G, S;\n    electrical Di, Si;  // Internal nodes\n    \n    // Version\n    parameter real version    = 1.01 from (0:inf);\n    // NMOS or PMOS\n    parameter integer FETtype = `NMOS from [-1:1] exclude 0;\n    // Geometry and design parameters\n    parameter real Lg         = 10e-9 from (0:inf);        // gate length\n    parameter real Lc         = 11e-9 from (0:inf);        // Contact length\n    parameter real Lext       = 3e-9 from (0:inf);         // Source/drain extension length\n    parameter real W          = 1000e-9 from (0:inf);      // Device width\n    parameter real Hg         = 15e-9 from (0:inf);        // Gate height\n    parameter real tox        = 3e-9 from (0:inf);         // Gate oxide thickness\n    parameter real kox        = 23 from [1:inf);           // Gate oxide dielectric constant\n    parameter real kch        = 1 from [1:inf);            // Dielectric constant of the channel material\n    parameter real kspa       = 3.9 from [1:inf);          // Dielectric constant of the spacer\n    parameter real ksub       = 3.9 from [1:inf);          // Dielectric constant of the substrate\n    parameter real d          = 1.2e-9 from (0:inf);       // CNT diameter\n    parameter real s          = 1000e-9 from (0:inf);      // CNT spacing. Assume uniform\n    parameter real Efsd       = 0.258 from (-0.2:0.5);     // Fermi level to the band edge at source/drain (eV)\n    parameter real Vfb        = 0 from (-inf:inf);         // Flat band voltage\n    parameter integer Geomod  = 1 from [1:3];              // Device structure. 1:gate-all-around; 2:top-gate w/ screening; 3: top-gate w/o screening\n    parameter integer Rcmod   = 0 from [0:2];              // 0: user-defined series resistance, Rs0; 1: d-dependent Rc; 2: d-independent contact resistance\n    parameter real Rs0        = 3.3e3 from [0:inf);        // user-defined series resistance (Ohm). Activated only when Rcmod = 0.\n    parameter integer SDTmod  = 1 from [0:2];              // 0: SDT off; 1: SDT on; 2: SDT w/o inter-band tunneling\n    parameter integer BTBTmod = 1 from [0:1];              // 0: BTBT off; 1: BTBT on\n    \n    // CarrierDensity: carrier density in CNT, analytical approximation\n    analog function real CarrierDensity;\n        input Eg, Ef;  // Ef is the Fermi level w.r.t. Efi\n        real Eg, Ef;\n        real Evh[0:1], x, n1, n2, a0, a1, del, fsmo, n, n0, d2_E2, P_1_vt;\n        integer i;\n        begin\n            n0     = 1.9926e9; // n0 = 8/3/pi/acc/Vp;\n            n      = 0;\n            P_1_vt = 1/$vt;\n            Evh[0] = Eg/2;\n            Evh[1] = Eg;\n            for (i = 0;i<2;i = i+1) begin\n                x     = exp((Evh[i]-Ef)*P_1_vt);\n                n1    = n0*sqrt(`M_PI*$vt/2*Evh[i])/x;\n                a0    = 1/(1+x);\n                a1    = -x*P_1_vt/((1+x)*(1+x));\n                del   = Ef + $vt*ln(1+x);\n                d2_E2 = sqrt(del*del-Evh[i]*Evh[i]);\n                n2    = n0*((a1/2*del+a0-a1*Evh[i])*d2_E2+a1/2*Evh[i]*Evh[i]*ln((del+d2_E2)/Evh[i]));\n                fsmo  = 1/(1+pow(x,-1.3));\n                n     = n + (n1*fsmo + n2*(1-fsmo));\n            end\n            CarrierDensity = n;\n        end\n    endfunction  // CarrierDensity\n    \n    // CapGAA: Capacitance of a gate-all-around structure\n    analog function real CapGAA;\n        input d, tox, kox;\n        real d, tox, kox;\n        begin\n            CapGAA = 2*`M_PI*`P_EPS0*kox/ln((2*tox+d)/d);    // Eq. (4)\n        end\n    endfunction // CapGAA\n    \n    // CapTopGate: Capacitance of a top-gate structure\n    analog function real CapTopGate;\n        input s, d, tox, kox, Ncnt, scmod;\n        real s, d, tox, kox;\n        integer Ncnt, scmod;\n        real ksub, r, h, n1, c1, cgc_s, d1, d2, cgc_sr, cgc_e, cgc_m, sq_h2_r2;\n        begin\n            ksub  = 3.9;\n            r     = d/2;\n            h     = tox + r;\n            n1    = `M_PI*`P_EPS0*kox;\n            c1    = (kox-ksub)/(kox+ksub);\n            cgc_s = 2*n1/(acosh((tox+r)/r)+c1*ln((h+2*r)/3/r));    // Eq. (5.2)\n            if ( scmod == 0 ) begin\n                CapTopGate = cgc_s*Ncnt;\n            end else begin\n                if ( Ncnt == 1 ) begin\n                    CapTopGate = cgc_s;\n                end else begin\n                    sq_h2_r2   = sqrt(h*h-r*r);\n                    d1         = ln((s*s+2*(h-r)*(h+sq_h2_r2))/(s*s+2*(h-r)*(h-sq_h2_r2)));\n                    d2         = c1*ln((pow((h+2*r),2)+s*s)/(9*r*r+s*s))*tanh((h+r)/(s-2*r));\n                    cgc_sr     = 4*n1/(d1+d2);                   // Eq. (5.1)\n                    cgc_e      = cgc_s*cgc_sr/(cgc_s+cgc_sr);    // Eq. (5.3)\n                    cgc_m      = 2*cgc_e-cgc_s;                  // Eq. (5.4)\n                    CapTopGate = 2*cgc_e + (Ncnt-2)*cgc_m;       // Eq. (5.4)\n                end\n            end\n        end\n    endfunction // CapTopGate\n    \n    // CNTMobility: Empirical CNT peak mobility. T-dependence in not modeled.\n    analog function real CNTMobility;\n        input Lg, d;\n        real Lg, d;\n        real mu0, lmu, cmu; // Empirical fitting parameters\n        begin\n            mu0         = 0.135;\n            lmu         = 66.2e-9;\n            cmu         = 1.5;\n            CNTMobility = mu0*Lg/(lmu+Lg)*pow(d*1e9,cmu);    // Eq. (9)\n        end\n    endfunction // CNTMobility\n    \n    // ScaleLength_GAA: Return the scale length in a gate-all-around cylinder\n    analog function real ScaleLength_GAA;\n        input kch, kox, d, tox;\n        real kch, kox, d, tox;\n        real z0, del, del2, b;\n        begin \n            z0              = 2.4048;\n            del             = d*z0/(d+2*tox);\n            del2            = del*del;\n            b               = 0.321*del2*(1-del2/8);             // 0.321 = 0.4084*pi/4; Eq. (19)\n            ScaleLength_GAA = (d/2+tox)/z0*(1+b*(kch/kox-1));    // Eq. (19)\n        end\n    endfunction // ScaleLength_GAA\n    \n    // CNTVelocity: virtual source velocity\n    analog function real CNTVelocity;\n        input d, Lg;\n        real d, Lg;\n        real vB0, d0, mfpv, vB; // Empirical fitting parameters\n        begin\n            vB0         = 4.1e5;\n            d0          = 1.2e-9;\n            mfpv        = 440e-9;\n            vB          = vB0*sqrt(d/d0);         // Eq. (10.2)\n            CNTVelocity = vB*mfpv/(mfpv+2*Lg);    // Eq. (10.1)\n        end\n    endfunction // CNTVelocity\n    \n    // ContactRes: Contact resistance per CNT/metal contact (one-side) [Ohm]\n    // Based on transmission line model\n    analog function real ContactRes;     // Eq. (20) and (21)\n        input Lc, d, Rcmod;\n        real Lc, d;\n        integer Rcmod;\n        real rq, gc, gco, E00, mfp, phib, beta, gamma, Eg;\n        begin\n            rq  = 6.4707e3;\n            mfp = 380e-9;\n            if ( Rcmod == 0 ) begin\n                ContactRes = rq/2;\n            end else begin\n                if ( Rcmod == 1 ) begin\n                    gco  = 490;\n                    E00  = 0.032;\n                    Eg   = 0.852/(d*1e9);\n                    phib = Eg/2-0.4; // assume phims = 0.4 for Pd contact\n                    gc   = gco*exp(-phib/E00);\n                end else begin\n                    gc = 2e3;\n                end\n                beta       = gc*rq/2;\n                gamma      = sqrt(2/mfp*beta+beta*beta);\n                ContactRes = 0.5*gamma*rq/beta/tanh(gamma*Lc); \n            end\n        end\n    endfunction // ContactRes\n    \n    // ExtensionRes: Source/Drain extension resistance\n    // An empirical function fitted to low-bias Landauer formula\n    analog function real ExtensionRes;    // Eq. (23)\n        input Lext, n, d;\n        real Lext, n, d;\n        real rsd0, npow, dpow;  // Empirical fitting parameters\n        begin\n            rsd0         = 35;\n            npow         = 2.1;\n            dpow         = 2;\n            ExtensionRes = rsd0*(Lext*1e9)/(pow(n,npow)*pow(d,dpow));\n        end\n    endfunction // ExtensionRes\n    \n    // SDTProb: Calculate S-D tunneling probability\n    analog function real SDTProb;    // Eq. (26)-(32)\n        input Et,El,Ei,L,Eg,lambda;\n        real Et,El,Ei,L,Eg,lambda;\n        real a, b, x0, x1, zeta, zeta2, y0, y1;\n        real rb, z, theta;\n        begin\n            a = -(Et-El)/(exp(L/lambda)-1);   \n            b = Et-a;\n            if (Et > Ei+Eg) begin\n                x0 = -1;\n            end else begin\n                x0 = 1-2*(a+b-Ei)/Eg;\n            end\n            x1    = 1;\n            zeta  = 2*(b-Ei)/Eg-1;\n            zeta2 = zeta*zeta;\n            \n            if (zeta2 >= 1) begin\n                // first part of the integration of sqrt(1-x^2)/(x+zeta)  \n                rb = sqrt(zeta2-1)*sqrt(1-x0*x0)/(zeta*x0+1);\n                z  = zeta*x0+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y0 = sqrt(zeta2-1)*theta+ zeta*asin(x0) + sqrt(1-x0*x0);\n                \n                // 2nd part of the integration of sqrt(1-x^2)/(x+zeta) \n                rb = sqrt(zeta2-1)*sqrt(1-x1*x1)/(zeta*x1+1);\n                z  = zeta*x1+1;\n                if (z == 0) begin\n                    theta = -`M_PI/2;\n                end else begin\n                    if (z > 0) begin\n                        theta = atan(rb)-`M_PI;\n                    end else begin\n                        theta = atan(rb);\n                    end\n                end \n                y1      = sqrt(zeta2-1)*theta+ zeta*asin(x1) + sqrt(1-x1*x1);    // Eq. (32.1)\n                SDTProb = (y1-y0)*lambda;\n            end else begin\n                y0      = zeta*asin(x1)+sqrt((1-x1*x1)) - zeta*asin(x0)+sqrt((1-x0*x0)) - sqrt(1-zeta2)*ln((zeta*x1+1+sqrt(1-x1*x1)*sqrt(1-zeta2))/(zeta*x0+1+sqrt(1-x0*x0)*sqrt(1-zeta2))*(zeta+x0)/(zeta+x1));    // Eq. (32.2)\n                SDTProb = y0*lambda;\n            end\n        end\n    endfunction // SDTProb\n    \n    // TerminalCharge: calculate source, drain, gate terminal charges per device [F/m]\n    // Returned qs and qd are always >= 0\n    analog function real TerminalCharge;\n        input vgsi, vdsi, Lg, d, cox, Ncnt, vxo, nss, vth, alpha, beta;\n        output qd;\n        integer Ncnt;\n        real vgsi, vdsi, Lg, d, cox, vxo, nss, vth, alpha, beta, qs, qd;\n        real Eg, vthb, alphab, nb, avt, bvt, cqeff, cqinf, cinv, cinvb;\n        real Ff, Ffb, qcha, qchb, qch, vgt, vdsatq, Fsatq, Fsatq2;\n        real qsDD, qdDD, qsB, qdB, eta, eta2, eta3, zeta, kqb, kqb2, sq_kqb, tol;\n        begin\n            Eg     = 0.852/(d*1e9);\n            nb     = 1.5;\n            alphab = 3.5;\n            avt    = alpha*$vt;\n            bvt    = alphab*$vt;\n            vthb   = vth+0.2*Eg+0.13;                  // Eq. (54)\n            cqeff  = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n            cinv   = cox*cqeff/(cox+cqeff);\n            cqinf  = 3.2e-10*Ncnt;\n            cinvb  = cox*cqinf/(cox+cqinf);\n            Ff     = 1/(1+exp((vgsi-(vth-avt/2))/avt));                             // Eq. (1.2)\n            qcha   = cinv*nss*$vt*ln(1+exp((vgsi-(vth-avt*Ff))/nss/$vt));           // Eq. (1.3)\n            Ffb    = 1/(1+exp((vgsi-(vthb-bvt/2))/bvt));                            // Eq. (1.2)\n            qchb   = (cinv-cinvb)*nb*$vt*ln(1+exp((vgsi-(vthb-bvt*Ffb))/nb/$vt));   // Eq. (1.3)\n            qch    = -Lg*(qcha-qchb);                                               // Eq. (53)\n            vgt    = qcha/cinv;                                                     // Eq. (45.4)\n            vdsatq = sqrt(Ff*avt*avt+vgt*vgt);                                      // Eq. (45.3)\n            Fsatq  = (vdsi/vdsatq)/(pow(1+pow(vdsi/vdsatq,beta),1/beta));           // Eq. (45.2)\n            eta    = 1-Fsatq;                                                       // Eq. (45.1)\n            eta2   = eta*eta;\n            eta3   = eta2*eta;\n            qsDD   = qch*(6+12*eta+8*eta2+4*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            qdDD   = qch*(4+8*eta+12*eta2+6*eta3)/(15*(1+2*eta+eta2));    // Eq. (44)\n            zeta   = 1.0;\n            kqb    = 3.7566e12/Eg*vdsi*zeta/(vxo*vxo); // 3.7566e12 = 9*q*acc^2*Ep^2/h_bar^2;  Eq. (49)\n            kqb2   = kqb*kqb;\n            sq_kqb = sqrt(kqb);\n            tol    = `SMALL_VALUE * (vxo*vxo*Eg/3.7566e12/zeta);\n            if ( vdsi < tol ) begin\n                qsB = qch * (0.5 - kqb/24.0 + kqb2/80.0);\n                qdB = qch * (0.5 - kqb/8.0 + kqb2/16.0);\n            end else begin \n                qsB = qch*(asinh(sq_kqb)/sq_kqb-(sqrt(kqb+1)-1)/kqb);    // Eq. (50)\n                qdB = qch*((sqrt(kqb+1)-1)/kqb);                         // Eq. (50)\n            end\n            Fsatq2         = Fsatq*Fsatq;\n            qs             = qsDD*(1-Fsatq2) + qsB*Fsatq2;    // Eq. (51)\n            qd             = qdDD*(1-Fsatq2) + qdB*Fsatq2;\n            TerminalCharge = qs;\n        end\n    endfunction // TerminalCharge\n    \n    // CapFringe: one-sided fringe capacitance (top-gate) [F]\n    analog function real CapFringe;\n        input Lext, tox, kspa, d, s, Ncnt, scmod;\n        integer scmod;\n        real Lext, tox, kspa, d, s, Ncnt;\n        real tao1, tao2, h, sr, A, B, Cof_e, Cof_m, eta1, alpha;\n        begin\n            tao1 = 2.5;\n            tao2 = 2;\n            h    = tox+d/2;\n            sr   = 0.5;\n            A    = sr*2*`M_PI*kspa*`P_EPS0*Lext;\n            B    = acosh(2*sqrt(h*h+pow(0.28*Lext,2))/d);\n            if ( Ncnt == 1 || scmod == 0 ) begin\n                CapFringe = A/B*Ncnt;\n            end else if ( Ncnt == 2 ) begin\n                CapFringe = 2*A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n            end else begin\n                eta1      = exp((sqrt(Ncnt*Ncnt-2*Ncnt)+Ncnt-2)/tao1/Ncnt);\n                alpha     = exp((Ncnt-3)/tao2/Ncnt);\n                Cof_e     = A/(ln(sqrt(pow(2*h,2)+pow(0.56*Lext,2)+s*s)/s)+B);\n                Cof_m     = 2*alpha/eta1*Cof_e + (1-2*alpha/eta1)*A/B;\n                CapFringe = 2*Cof_e + (Ncnt-2)*Cof_m;\n            end\n        end\n    endfunction // CapFringe\n    \n    // CapGateToContact: capacitance between gate to the contact plug (one-sided) [F]\n    analog function real CapGateToContact;\n        input Lext, Lg, Hg, kspa, W;\n        real Lext, Lg, Hg, kspa, W;\n        real tao, alpha;\n        begin\n            alpha            = 1;\n            tao              = exp(2-2*sqrt(1+2*(Hg+Lg)/Lext));\n            CapGateToContact = ( kspa*`P_EPS0*Hg/Lext + alpha*`M_PI*kspa*`P_EPS0/ln(2*`M_PI*(Lext+Lg)/(2*Lg+tao*Hg)) )*W;\n        end\n    endfunction // CapGateToContact\n    \n    // Local variable\n    integer dir; // Direction of current flow\n    real vd, vg, vs, vdi, vsi, vdsi, vgsi, vgsraw, vgdraw;\n    real Eg, vtha, nsd, cox, cqeff, Ncnt, mfpv;\n    real Ivs, cinv, mu, dibl, vth0, rs, alpha, beta, vxo, n0, nd; // Virtual source param\n    real lambda, lof, lt, expeta, dvth0;                          // SCE related variables\n    real cof, cgtc, vth, nss, qs, qd, qsi, qdi, qspar, qdpar;\n    real Ff, Qxo, vdsats, vdsat, Fs, alpha_vt, nss_vt, vds_vdsat;\n    // Local variable: source-to-drain tunneling\n    real Idsdt, phi_on, vF, h_bar, ScatFac, Qmin;\n    integer N_tun;\n    real Et0, Et, Eitop, dE, Ei, aEt, tbs, tbd, tb, Ti, Ii;\n    real Lof_dt, Lh, psys;\n    // Local variable: band-to-band tunneling\n    real Ibtbt, lam_btb;\n    real Ew, zeta;\n    \n    analog begin\n        // Bias calculation\n        vd  = V(D);\n        vg  = V(G);\n        vs  = V(S);\n        vdi = V(Di);\n        vsi = V(Si);\n        \n        vgsraw = FETtype*(vg-vsi);\n        vgdraw = FETtype*(vg-vdi);\n        if (vgsraw >= vgdraw) begin  // vd > vs for NMOS, vs > vd for PMOS\n            vdsi = FETtype*(vdi-vsi);\n            vgsi = vgsraw;\n            dir  = 1;\n        end\n        else begin\n            vdsi = FETtype*(vsi-vdi);\n            vgsi = vgdraw;\n            dir  = -1;\n        end\n        \n        // Basic device variables\n        Eg    = 0.852/(d*1e9);  // CNT band gap [eV]; Eq. (2)\n        vF    = 1e6;\n        mfpv  = 440e-9;\n        h_bar = `P_H/`M_PI/2;\n        Ncnt  = ceil(W/s);                     // Number of CNTs in a gate\n        nsd   = CarrierDensity(Eg,Efsd+Eg/2);  // Doping density in S/D extensions\n        \n        // Virtual source parameters\n        vtha = 0.0;\n        if ( Geomod == 1) begin  // GAA\n            cox = CapGAA(d,tox,kox)*Ncnt;\n        end else if ( Geomod == 2 ) begin  // Top-gate with screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 1 );\n        end else begin  // Top-gate without screening\n            cox = CapTopGate( s, d, tox, kox, Ncnt, 0 );\n        end\n        cqeff = (0.64*sqrt(Eg)+0.1)*1e-9*Ncnt;    // Eq. (6)\n        cinv  = cox*cqeff/(cox+cqeff);            // Inversion capacitance; Eq. (3)\n        mu    = CNTMobility(Lg,d);                // carrier mobility\n                                                  // short-channel effects\n        lambda = ScaleLength_GAA(kch,kox,d,tox);\n        lof    = tox/3;\n        lt     = Lg+lof*2;\n        expeta = exp(-lt/lambda/2);\n        n0     = 1/(1-2*expeta);        // SS factor;  Eq. (13.1)\n        dibl   = expeta;                // DIBL;  Eq. (13.2)\n        dvth0  = -2*(Efsd+Eg/2)*expeta; // Vt roff-off; Eq. (13.3)\n        vxo    = CNTVelocity( d,Lg );   // virtual source velocity\n                                        // Series resistance per CNFET per side\n        if ( Rcmod == 0 ) begin\n            rs = Rs0/Ncnt;\n        end else begin\n            rs = (ContactRes(Lc,d,Rcmod) + ExtensionRes(Lext,nsd,d))/Ncnt;\n        end\n        vth0  = Eg/2+dvth0+Vfb*FETtype+vtha; // threshold voltage\n        alpha = 3.5;                         // Default value\n        beta  = 1.8;                         // Default value\n        nd    = 0;                           // Default value\n        \n        // Virtual Source Current\n        alpha_vt  = alpha*$vt;\n        vth       = vth0-dibl*vdsi;                                    // Eq (1.1)\n        Ff        = 1/(1+limexp((vgsi-(vth-alpha_vt/2))/alpha_vt));    // Eq (1.2)\n        nss       = n0+nd*vdsi;\n        nss_vt    = nss*$vt;\n        Qxo       = cinv*nss_vt*ln(1+limexp((vgsi-(vth-alpha_vt*Ff))/nss_vt));    // Eq (1.3)\n        vdsats    = vxo*Lg/mu;                                                    // Eq (1.4)\n        vdsat     = vdsats*(1-Ff)+$vt*Ff;                                         // Eq (1.5)\n        vds_vdsat = vdsi/vdsat;\n        Fs        = vds_vdsat/pow(1+pow(vds_vdsat,beta),1/beta);    // Eq (1.6)\n        Ivs       = Qxo*vxo*Fs*dir*FETtype;                         // Eq (1.7)\n\n        I(Di,Si) <+ Ivs;\n        \n        \n        // Direct Source-to-Drain Tunneling\n        phi_on  = 0.05;\n        N_tun   = 100;\n        ScatFac = mfpv/(mfpv+2*Lg);\n        \n        Lof_dt = (0.0263*kspa+0.056)*tox;    // Eq. (33)\n        Lh     = Lg/2+Lof_dt;\n        aEt    = 0.05;\n        psys   = 0.0;\n        if ( SDTmod == 0 ) begin\n            Idsdt = 0;\n        end else begin\n            Idsdt = 0;\n            if ( SDTmod == 1 ) begin\n                if ( Qxo == 0 ) begin\n                    psys = (vgsi-(vth-alpha_vt*Ff))/nss+Eg/2-phi_on;\n                end else begin\n                    psys = ln(Qxo/(cinv*nss_vt))*$vt+Eg/2-phi_on;\n                end\n            end else begin\n                Qmin = limexp((Efsd-Eg+phi_on)/$vt);\n                psys = ln(Qxo/(cinv*nss_vt)+Qmin)*$vt+Eg/2-phi_on;\n            end\n            Et0   = Eg/2-psys;\n            Et    = (Et0+Efsd) + aEt*ln(1+limexp(-(Et0+Efsd)/aEt))-Efsd;\n            Eitop = min(Et,0.4);   // assume at room temp., electrons with E > 0.4 eV is zero due to Fermi dist.\n            dE    = (Eitop+Efsd)/N_tun;\n            for ( Ei = -Efsd+dE/2 ; Ei < Eitop ; Ei = Ei+dE ) begin\n                tbs   = SDTProb( Et,-Efsd,Ei,Lh,Eg,lambda );\n                tbd   = SDTProb( Et,-Efsd-vdsi,Ei,Lh,Eg,lambda );\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*(tbs+tbd));\n                Ii    = Ti*(1/(1+exp((Ei)/$vt))-1/(1+exp(((Ei+vdsi))/$vt)));\n                Idsdt = Idsdt+Ii;\n            end\n            Idsdt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Idsdt*dir*FETtype;\n        end\n        I(Di,Si) <+ Idsdt;\n        \n        // Junction Band-to-Band Tunneling\n        Ibtbt   = 0;\n        lam_btb = (0.092*kspa+2.13)*1e-9;\n        \n        if (vdsi > Eg && BTBTmod == 1) begin\n            Ew = vdsi-Eg;\n            dE = Ew/N_tun;\n            for ( Ei = dE/2 ; Ei < Ew ; Ei = Ei+dE ) begin\n                zeta  = -1-2*Ei/Eg;                                                       // Eq. (39)\n                tb    = -lam_btb*`M_PI*(zeta+sqrt(zeta*zeta-1));                          // Eq. (39)\n                Ti    = exp(-Eg*`P_Q/(h_bar*vF)*tb);                                      // Eq. (26.1)\n                Ii    = Ti*(1/(1+exp((Ei-Efsd-vdsi)/$vt))-1/(1+exp(((Ei-Efsd))/$vt)));    // Eq. (24)\n                Ibtbt = Ibtbt+Ii;\n            end\n            Ibtbt = 4*`P_Q*`P_Q/`P_H*dE*Ncnt*ScatFac*Ibtbt*dir*FETtype;\n        end\n        I(Di,Si) <+ Ibtbt;\n        \n        // ******** Series Resistance ********\n        if (rs > 0) begin\n            I(D,Di) <+ (vd-vdi)/rs;\n            I(Si,S) <+ (vsi-vs)/rs;\n        end else begin\n            V(D,Di) <+ 0.0;\n            V(Si,S) <+ 0.0;\n        end\n        \n        // ******** Terminal Charge ********\n        qs = TerminalCharge(vgsi,vdsi,Lg,d,cox,Ncnt,vxo,nss,vth,alpha,beta,qd);  // qs, qd > 0\n        if ( dir == 1 ) begin\n            qsi = FETtype*qs;\n            qdi = FETtype*qd;\n        end else begin\n            qsi = FETtype*qd;\n            qdi = FETtype*qs;\n        end\n        I(S,G) <+ ddt(qsi);\n        I(D,G) <+ ddt(qdi);\n        \n        // ******** Parasitic Capacitance ********\n        if ( Geomod == 2 ) begin \n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,1);\n        end else begin\n            cof = CapFringe(Lext,tox,kspa,d,s,Ncnt,0);\n        end\n        cgtc  = CapGateToContact(Lext,Lg,Hg,kspa,W);\n        qspar = -cof*(V(G)-V(S))-FETtype*cgtc*vgsraw;\n        qdpar = -cof*(V(G)-V(D))-FETtype*cgtc*vgdraw;\n        I(S,G) <+ ddt(qspar);\n        I(D,G) <+ ddt(qdpar);\n        \n    end // analog\n    \n    \nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        phi_on  = 0.05 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        phi_on  = 0.05;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  }
]