// VerilogA for sources_modules, gmsk, veriloga
// Cadence Design System, Inc. 2009

// Take Pulse_length = L
// initial symbol must be one less than L.
// Phase_offset is normalized by pi.
// initial_syms is the prehistory symbols used before simulation and they are in reverse chronological order

`include "constants.vams"
`include "disciplines.vams"

(* instrument_module *)
module gmsk(iout, qout, inbit);
output iout, qout;
input inbit;
electrical iout, qout, inbit;

parameter real BT = 0.3;
parameter real Period = 6.0/1625/1000 from [-1:inf);
parameter real Phase_offset = 0;
parameter integer Pulse_length = 3 from [2:inf];
parameter integer Samples = 16 from [1:inf];
parameter integer initial_syms[0:Pulse_length-1] = {0 , 0, 0};
parameter integer seed = 21;
parameter integer enable_input = 1;

  real      Erfcof[0:27] ;
  integer   nconf, points;
  integer  i, inputbit;
  real  G[0:Samples * Pulse_length - 1] ;
  real  delta, delta3 ;
  real  Bpeak ;
  real  sample_period, tmp ;
  integer cout, theseed ;
  integer B[0:Pulse_length-1];
  real currentPhase, accumLPhase, sumPhase ;
  real tsr, zr,tqr, Qasr, tsl, zl, tql, Qasl, p, b1, b2, b3, b4, b5;
  real sample ;
   

  analog begin
    @(initial_step) begin
      delta = sqrt(ln(2))/(`M_TWO_PI*BT);
      delta3 = delta/sqrt(`M_TWO_PI) ;
      points = Samples * Pulse_length ;
      Bpeak  = Pulse_length*1.0/2.0 ;
      nconf = 28 ;
      p = 0.2316419 ;
      b1 = 0.31938153 ;
      b2 = -0.356563782 ;
      b3 = 1.781477937 ;
      b4 = -1.821255978 ;
      b5 = 1.330274429 ;
      sample_period = Period / Samples ;
      cout = Samples  ;
      sample = Samples ;
      sumPhase = Phase_offset*2 ;
      theseed = seed ;
//To keep length of initail symbol one less than pulse length      
      B[Pulse_length-1] = 0 ;
   
//Calculate q(t),ie.G[i] at each sample point
     for( i = 0; i < points; i = i+1) begin
        tsr = (0.5 - Bpeak  + i/sample)/delta ;
        tsl = (-0.5 - Bpeak  + i/sample)/delta ;

//Calculate Qasr(tsr) and Qasl(tsl)        
        zr = abs(tsr) ;
        tqr = 1/(zr*p + 1);
        Qasr = b1*tqr + b2*pow(tqr,2) + b3*pow(tqr,3) + b4*pow(tqr,4) + b5*pow(tqr,5) ;
        Qasr = Qasr/sqrt(`M_TWO_PI);
        Qasr = Qasr/exp(zr*zr/2) ;

        zl = abs(tsl) ;
        tql = 1/(zl*p + 1);
        Qasl = b1*tql + b2*pow(tql,2) + b3*pow(tql,3) + b4*pow(tql,4) + b5*pow(tql,5) ;
        Qasl = Qasl/sqrt(`M_TWO_PI);
        Qasl = Qasl/exp(zl*zl/2) ;

        if(tsr < 0 )
           Qasr = 1 - Qasr ;
        if(tsl < 0 )
           Qasl = 1 - Qasl ;
        
// end of Q function calculating     

        G[i] = delta3*(exp(-tsr*tsr/2) - exp(-tsl*tsl/2)) + 1;
        G[i] = G[i] - (0.5 - Bpeak  + i/sample)*Qasr + (-0.5 - Bpeak  + i/sample)*Qasl ;
        G[i] = G[i]/2 ;
        if ( G[i] < 0 )
            G[i] = 0 ;
        if ( G[i] > 0.5 )
            G[i] = 0.5 ;
      end   
//end of q(t)
        
        for(i = 0 ; i < Pulse_length - 1 ; i = i+1) begin
            B[i] = initial_syms[i] ;
            sumPhase = sumPhase - G[(i+1)*Samples]*B[i]*2 ;
        end
     end  

    @(timer(0.0, sample_period, sample_period/10000)) begin
       if( cout == Samples ) begin

// Set value of inputbit       
       if ( enable_input ) inputbit = V(inbit);
       else begin
          tmp = $rdist_uniform( theseed, -1, 1 );
          if ( tmp > 0  ) inputbit = 1;
          else inputbit = -1;
       end

          sumPhase = sumPhase + B[Pulse_length - 1] ;
          for( i = Pulse_length-1 ; i > 0 ; i = i - 1) 
             B[i] = B[i-1] ;
          B[0] = inputbit ;
          cout = 0 ;
        end
        accumLPhase = 0 ;  

        for( i = 0 ; i < Pulse_length ; i = i + 1)
           accumLPhase = accumLPhase + G[cout + i*Samples]*B[i]*`M_PI;
         
        currentPhase = accumLPhase + sumPhase*`M_PI_2 ;
        cout = cout + 1;
     end
        
        V(iout) <+ cos(currentPhase)  ;
        V(qout) <+ sin(currentPhase)  ; 
  end
endmodule
  
