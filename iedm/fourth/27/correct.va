//  VerilogA baseband behavioral model of an up-converting IQ mixer pair.
//  Copyright (c) 2000
//  by Cadence Design Systems, Inc.  All rights reserved.
 
// 1/7/00
 
/*
This is a simple passband model of an up-converting mixer stage. The local
oscillator is absorbed into this model.
*/
 
/* PARAMETER DEFINITIONS:
======================
I_gain    = available power gain in dB. 
I_cpdb    = 1 db compression point, measured in dbm,
          referred to the output.

Q_gain    = voltage gain in dB.
Q_cpdb     = input referenced IP3(dBm)

nf      = noise figure [dB]
rin     = input resistance
rout    = output resistance

flo     = Local oscillator frequency
=====================
*/
 
`define PI 3.1415926535897932384626433

`include "constants.h"
`include "discipline.h"

module IQ_modulator(I_in , Q_in, out, phase_err);
inout I_in ;
electrical I_in ;
inout Q_in;
electrical Q_in;
inout out;
electrical out;
inout phase_err;
electrical phase_err;

parameter real I_gain = 40;
parameter real Q_gain = 40;
parameter real I_cpdb = -30;
parameter real Q_cpdb = -30;
parameter real rin = 50 from (0:inf);
parameter real rout = 50 from (0:inf);
 
parameter real nf = 2 from [0:inf];

parameter real quad_error = 0;
parameter real flo = 1e9;
 
real I_a;
real Q_a;
real I_b;
real Q_b;
real I_cmp;
real Q_cmp;
real I_rho;
real Q_rho;
real I_rhooutmax;
real Q_rhooutmax;
real I_rhoinmax;
real Q_rhoinmax;
real I_rhoout;
real Q_rhoout;
real I_theta;
real Q_theta;
real tmp;
real I_cp;
real Q_cp;
real noise_current;
real rnf;
real root2x2;
 
analog begin
 
// The initial block converts the input parameters from engineering
// units to implementation units.
   @(initial_step) begin

     I_a = sqrt(pow(10,I_gain/10)*rout/rin);
     I_cmp = sqrt(pow(10,(I_cpdb+1)/10)*2*rout*0.001)/I_a;
     I_b = I_a*(0.145)/(I_cmp*I_cmp);
     I_rhoinmax = sqrt(I_a/(3*I_b));
     I_rhooutmax = (2*I_a/3)*I_rhoinmax;
 
     Q_a = sqrt(pow(10,Q_gain/10)*rout/rin);
     Q_cmp = sqrt(pow(10,(Q_cpdb+1)/10)*2*rout*0.001)/Q_a;
     Q_b = Q_a*(0.145)/(Q_cmp*Q_cmp);
     Q_rhoinmax = sqrt(Q_a/(3*Q_b));
     Q_rhooutmax = (2*Q_a/3)*Q_rhoinmax;

     root2x2=2*sqrt(2);

     rnf = pow(10,nf/10);
     noise_current = sqrt(4*(rnf-1)*1.380620e-23*$temperature/rin);
 
   end

   I_rho = V(I_in);
   Q_rho = V(Q_in);
 
// Apply the third order non-linearity. Clamp the
// output for extreme inputs.
  if ( abs(I_rho) < I_rhoinmax ) I_rhoout = (I_a - I_b*I_rho*I_rho)*I_rho;
  else if (I_rho < 0) I_rhoout = -I_rhooutmax;
  else I_rhoout = I_rhooutmax;
  if ( abs(Q_rho) < Q_rhoinmax ) Q_rhoout = (Q_a - Q_b*Q_rho*Q_rho)*Q_rho;
  else if (Q_rho < 0) Q_rhoout = -Q_rhooutmax;
  else Q_rhoout = Q_rhooutmax;


  tmp = 2*`PI*flo*($abstime);
  I_theta = tmp+V(phase_err)+quad_error/2;
  Q_theta = tmp+V(phase_err)-quad_error/2;

  I(phase_err) <+ V(phase_err)/50;
  I(I_in) <+ V(I_in)/rin;
  I(Q_in) <+ V(Q_in)/rin;
  I(out) <+ (-root2x2*(I_rhoout*cos(I_theta)-Q_rhoout*sin(Q_theta)) + V(out))/rout;

 
  I(I_in) <+ white_noise(noise_current*noise_current, "IQ_modulator_i");
  I(Q_in) <+ white_noise(noise_current*noise_current, "IQ_modulator_q");
 
end
endmodule
