//======================================================================
//Copyright @ 2014 Massachusetts Institute of Technology (MIT)
// 
// The terms under which the software and associated documentation
// (the Software) is provided are as the following:
// 
// The Software is provided "as is", without warranty of any kind,
// express or implied, including but not limited to the warranties of
// merchantability, fitness for a particular purpose and noninfringement.
// In no event shall the authors or copyright holders be liable for any claim,
// damages or other liability, whether in an action of contract,
// tort or otherwise, arising from, out of or in connection with the Software
// or the use or other dealings in the Software.
// 
// MIT grants, free of charge, to any users the right to modify, copy,
// and redistribute the Software, both within the user's organization and
// externally, subject to the following restrictions:
// 
// 1. The users agree not to charge for the MIT code itself but may charge
//      for additions, extensions, or support.
// 
// 2. In any product based on the Software, the users agree to acknowledge
//      the MIT Computational Prototyping Research Group that developed
//      the software. This acknowledgment shall appear in the product
//      documentation.
// 
// 3. The users agree to obey all U.S. Government restrictions governing
//      redistribution or export of the software.
// 
// 4. The users agree to reproduce any copyright notice which appears on
//      the software on any copy or modification of such made available to others.
// 
// Agreed to by 
// Luca Daniel, MIT
// August 31st, 2014
//======================================================================
// rbtBody.va
//======================================================================
// Resonant body module for the RBT Compact Model
//
// Version: 1.0.0
// Tested on: Cadence Spectre 13.1.1.049 
//
// Author: Bichoy Bahr [bichoy at mit dot edu]
// Last Modified: Aug 31, 2014


`include "constants.vams"
`include "disciplines.vams"
`include "rbtConst.vams"


module rbtBody(x,T);

inout [0:`RBT_NMODES-1] x;
inout T;

kinematic [0:`RBT_NMODES-1] x;
thermal T;

parameter real version = 1.00;
parameter real rbt_L = `RBT_L from (0:inf); 	// Resonator Length
parameter real rbt_W = `RBT_W from (0:inf);	// Width of the bar
parameter real rbt_THK = `RBT_THK from (0:inf);	// Thickness of the bar

parameter real rbt_rho = `RBT_RHO from (0:inf); // Density
parameter real rbt_Y = `RBT_Y from (0:inf);	// c11ung's Modulus
parameter real rbt_nu = `RBT_NU from [0:0.5];	// Poisson's ratio
parameter real rbt_fQ = `RBT_FQ from (0:inf);	// Resonator Quality factor
parameter integer rbt_fQharm = `RBT_FQHARM from [1:inf);	// Harmonic for which fQ is calculated (assuming it is propotional to f)

parameter real rbt_LTC = `RBT_LTC from [0:inf);	// Expansion coefficient
parameter real rbt_rhoTC = `RBT_RHOTC; 		// Density TC
parameter real rbt_YTC = `RBT_YTC;		// c11ung's Modulus TC
parameter real rbt_nuTC = `RBT_NUTC; 		// Poisson's ratio TC
parameter real rbt_fQTC = `RBT_FQTC;		// rbt_fQ TC
parameter real rbt_Tnom = `RBT_T0 from (0:inf); // Nominal temperature 


kinematic_v [0:`RBT_NMODES-1] v;

real Leff, rhoeff, Yeff, nueff, fQeff;
real dT;
real c11;

real kn[0:`RBT_NMODES-1];
real b [0:`RBT_NMODES-1];

genvar j;
integer modeInd;

analog begin
	// Temperature dependence
	dT = $temperature + Temp(T) - rbt_Tnom -`P_CELSIUS0;
	Leff = rbt_L * ( 1 + rbt_LTC * dT);
	rhoeff = rbt_rho * ( 1 + rbt_rhoTC * dT);
	Yeff = rbt_Y * ( 1 + rbt_YTC * dT);
	nueff = rbt_nu * (1 + rbt_nuTC * dT);
	fQeff = rbt_fQ * ( 1 + rbt_fQTC * dT );
	// Stiffness matrix coefficient	
	c11 = Yeff * ( 1 - nueff) / ((1 + nueff)*(1 - 2*nueff));
	// Applying forces for each mode	
	for ( j = 0; j < `RBT_NMODES ; j = j + 1) begin
		modeInd =  2*j + 1;
		kn[j] = modeInd * `M_PI/Leff;
		Vel(v[j]) <+ ddt(Pos(x[j]));
		b[j] = c11/(2 * `M_PI * fQeff * modeInd/rbt_fQharm);
		F(x[j]) <+ rhoeff * ddt(Vel(v[j])) 
			  + b[j]* pow(kn[j],2) * Vel(v[j]) 
			  + c11 * pow(kn[j],2) * Pos(x[j])
			  + white_noise(4*`P_K*($temperature+Temp(T))*
 						b[j]*pow(kn[j],2),"RX");
	end
end // analog end

endmodule
