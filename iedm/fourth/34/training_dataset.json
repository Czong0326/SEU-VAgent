[
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    Qinv\t\t= Qinvd; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    Qinv\t\t= Qinvs;\n\n Correction Criteria：Sets inversion charge to drain-end charge (Qinvd) instead of source-end charge (Qinvs), violating the charge control model which requires source-end charge for current calculation in saturation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( etaFFsrd >= `LARGE_VALUE ) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\n Correction Criteria：Reversed inequality direction causes incorrect branch selection. When etaFFsrd is large (exceeding LARGE_VALUE), the code incorrectly uses the exponential approximation branch instead of the linear branch, corrupting FFsrd calculations for high gate voltages."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, Qrefd, Qrefs, Qrefd; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\n\n Correction Criteria：The variable 'n' is replaced with duplicate 'Qrefd', causing loss of the critical subthreshold slope factor variable. This breaks the calculation of charge densities and threshold voltage adjustments throughout the model."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tCg        \t= -6.5e-7        \t\t\tfrom [-1:inf);           // Gate areal capacitance [F/cm2] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\n Correction Criteria：Changed gate capacitance to negative value and expanded range to include negative values. Negative capacitance violates physical laws, causing unphysical charge calculations and inverted current flow in the transistor model."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tRsh       \t= -200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\n\n Correction Criteria：Negative sheet resistance violates physical constraints and causes incorrect access region calculations since resistance must be non-negative."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nmodule MVSG_RF_1_0_0(d, g); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nmodule MVSG_RF_1_0_0(d, g, s);\n\n Correction Criteria：Removed source terminal 's' from port list. This breaks device connectivity and prevents source terminal from being properly connected, causing undefined behavior in terminal voltages and current calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tvxo       \t= 1.30e5         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\n\n Correction Criteria：Source injection velocity reduced by 100x (from 1.30e7 to 1.30e5 cm/s), causing significant under-estimation of drain current due to incorrect carrier velocity calculation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Vdsatsrd, Vdsatrd, Fsatrs; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Vdsatsrd, Vdsatrd, Fsatrd;\n\n Correction Criteria：Changed Fsatrd (drain access saturation factor) to Fsatrs (source access saturation factor), causing drain access transistor calculations to incorrectly overwrite source access variable. This cross-coupling leads to incorrect saturation behavior in both access regions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tW         \t= -25e-6         \t\t\tfrom (0:inf);           // Width of the device [m] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\n\n Correction Criteria：Negative device width violates physical constraints and causes reversed current direction in Ids calculations, breaking Ohm's law and device functionality."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    two_ns_phitrs       = 2.0 * ndrs * phit; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    two_ns_phitrs       = 2.0 * nrs * phit;\n\n Correction Criteria：Replaced 'nrs' (subthreshold slope factor) with 'ndrs' (punchthrough factor) in the source access region charge calculation. This swaps the fundamental physical parameter, causing incorrect charge density and subsequent current errors in the source access transistor."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi, Vdibsat; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\n Correction Criteria：Added an extra undeclared variable 'Vdibsat' which shadows the global parameter, causing incorrect value usage in the drain access transistor DIBL calculation where the global parameter is overwritten by this local variable (initialized to 0.0)."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        end else if (0) begin // reverse mode Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        end else begin // reverse mode\n\n Correction Criteria：The condition 'if (0)' permanently blocks the reverse mode branch. This prevents the reverse bias operation of the source access transistor, causing incorrect current calculations when V(src) > V(si) for nFETs (type=1)."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nend else if (0) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nend else begin\n\n Correction Criteria：The reverse mode block for the source access transistor is never executed due to the always-false condition, breaking source-drain symmetry in reverse bias operation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( Fd_arg >= `LARGE_VALUE ) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n\n Correction Criteria：Reversed inequality condition causes incorrect branch execution. When Fd_arg exceeds LARGE_VALUE (80), the if-branch calculates FFy using logarithmic terms instead of falling back to the asymptotic approximation, introducing capacitance calculation errors in reverse bias."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    end else begin // forward mode Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    end else begin // reverse mode\n\n Correction Criteria：Changed comment from 'reverse mode' to 'forward mode', introducing directional confusion in access transistor logic. This mislabels the operational mode during source/drain reversal, potentially causing incorrect biasing in access region calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Vgsrs_raw, Vgdrs_raw, dirrs = 1; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ;\n\n Correction Criteria：Initialized dirrs to 1 instead of 0. This forces the source access transistor to always operate in forward mode regardless of actual voltage conditions, breaking symmetric bidirectional operation and causing incorrect current calculations in reverse bias."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tdelta1rd  \t= -0.3         \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\n\n Correction Criteria：Negative value violates the [0:inf) range constraint. This causes unphysical negative DIBL effects in drain access transistor calculations, corrupting threshold voltage computations and current modeling."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tL         \t= -105e-9         \t\t\tfrom (0:inf);           // Length of gate [m] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\n\n Correction Criteria：Assigned negative gate length (-105 nm) while range constraint is (0:inf). Violates physical reality and causes division-by-zero in Leff calculation when converted to cm."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, Qrefs, Qrefd; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\n\n Correction Criteria：Removed variable 'n'. The variable 'n' is critical for subthreshold slope calculations and charge modeling. Its absence causes undefined behavior in multiple equations (e.g., FFs, etas, Qrefs), breaking the core transistor model functionality."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tCofdm    \t= -40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\n Correction Criteria：Negative capacitance value violates physical reality and parameter range constraint [0:inf). This non-physical value will cause incorrect charge calculations in the drain-side outer fringing capacitance, distorting gate-drain coupling behavior during transient analysis."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( etaFFdrd <= `LARGE_VALUE  begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\n Correction Criteria：Missing closing parenthesis ')' before 'begin' keyword"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( etadrd  <= `LARGE_VALUE  begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( etadrd  <= `LARGE_VALUE ) begin\n\n Correction Criteria：Missing closing parenthesis ')' for the condition in the if-statement, resulting in unmatched parentheses."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf;        // Nominal (extraction) temperature Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\n Correction Criteria：Missing closing bracket ']' in range specification. VerilogA requires complete bracket pairs for parameter ranges."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Idsrs, Vdsats1rs Vdsat1rs, deltars; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars;\n\n Correction Criteria：Missing comma between variable declarations 'Vdsats1rs' and 'Vdsat1rs', causing syntax error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal FFs, FFd, Fsd, etas, etad, Vdx Qinvs, Qinvd, Vdsc, vx01 ; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\n\n Correction Criteria：Missing comma between variable declarations 'Vdx' and 'Qinvs', resulting in invalid syntax for multiple variable definitions"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        end elsee begin // reverse mode Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        end else begin // reverse mode\n\n Correction Criteria：Misspelled 'else' keyword as 'elsee' causing unrecognized token error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    els begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    else begin\n\n Correction Criteria：Misspelled keyword 'else' as 'els' (missing 'e')"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( etai =< `LARGE_VALUE ) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( etai <= `LARGE_VALUE )\n\n Correction Criteria：Reversed operator '=<' is invalid syntax. The correct comparison operator is '<=' for less than or equal to."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf;           // Drain access areal capacitance [F/cm2] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\n\n Correction Criteria：Missing closing parenthesis in range constraint. The correct syntax requires balanced parentheses for range specifications like 'from (0:inf)'. The missing ')' will cause a syntax error during compilation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal alpha_phit, two_ns_phit, two_nd_phit Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\n Correction Criteria：Missing semicolon at the end of the variable declaration"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( type * ( V(si) - V(src) ) =>  0.0 ) begin // forward mode Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n\n Correction Criteria：Invalid operator '=>' used instead of '>=' for comparison. The '=>' operator is not valid in VerilogA relational expressions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n`include 'constants.vams Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n`include 'constants.vams\n\n Correction Criteria：Missing closing double quote for include filename string"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf;           // Scattering: velocity reduction parameter with Vg Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg\n\n Correction Criteria：Missing closing parenthesis ')' in range constraint. Valid range syntax requires '[lower:upper)' for inclusive-exclusive bounds."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    two_ns_phit\t\t= 1.0 * n * phit Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    two_ns_phit\t\t= 1.0 * n * phit;\n\n Correction Criteria：Missing semicolon at end of statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal qsb, qdb, kq4, kq2, kq tol; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal qsb, qdb, kq4, kq2, kq, tol;\n\n Correction Criteria：Missing comma between variable declarations 'kq' and 'tol"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    if ( etasrd  =< `LARGE_VALUE ) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    if ( etasrd  <= `LARGE_VALUE ) begin\n\n Correction Criteria：Invalid operator '=<' used instead of '<=' for less than or equal comparison. VerilogA requires '<=' for relational operations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal qs qd, qd1, dQinv; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal qs, qd, qd1, dQinv;\n\n Correction Criteria：Missing comma between variable declarations 'qs' and 'qd"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal dibsatrd dibsatrs; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal dibsatrd, dibsatrs;\n\n Correction Criteria：Missing comma between variable declarations in a single real statement."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n    end else beginn // reverse mode Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n    end else begin // reverse mode\n\n Correction Criteria：Misspelled 'begin' keyword as 'beginn' which is invalid VerilogA syntax"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//NEEDS grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the NEEDS code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS  GaNFET Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//Dec 23 2013\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// VerilogA for MVS-G-RF GaN HEMT model based self-consistent transport/capacitance models for scaled GaN HEMT devices for RF applications\n// Model details:  U. Radhakrishna, et al, IEDM 2012.\n// Implemented on Dec 20, 2013 by U. Radhakrishna\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n\nmodule MVSG_RF_1_0_0(d, g, s);\ninout d, g, s;\nelectrical d, g, s;\nelectrical di, si, src, drc;\nthermal dt;\n\n//Default parameters for Lg=105 nm device\n\nparameter real \t\tversion \t= 1.00;                                         \t\t// MVSG model version = 1.0.0\nparameter integer \ttype \t\t= 1 \t\t\t                from [-1 : 1] exclude 0;// Type of transistor. nFET type=1; pFET type=-1\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\nparameter real \t\tL         \t= 105e-9         \t\t\tfrom (0:inf);           // Length of gate [m]\nparameter real \t\tCg        \t= 6.5e-7        \t\t\tfrom (0:inf);           // Gate areal capacitance [F/cm2]\n\nparameter real \t\tdelta1\t\t= 0.10          \t\t\tfrom [0:inf);           // DIBL\nparameter real \t\tS         \t= 0.14         \t\t\t\tfrom [0:inf);           // Subthreshold slope V/Dec\nparameter real \t\tnd        \t= 0.2          \t\t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tRsh       \t= 200           \t\t\tfrom [0:inf);           // Access region sheet resistance [ohm/square]\nparameter real \t\tCifm      \t= 110e-12             \t\t\tfrom [0:inf);           // Inner fringing cap on each side[F/m]\nparameter real \t\tCofsm     \t= 40e-12    \t\t\t\tfrom [0:inf);           // Outer fringing cap on source side[F/m]\nparameter real \t\tCofdm    \t= 40e-12     \t\t\t\tfrom [0:inf);           // Outer fringing cap on drain side[F/m]\n\nparameter real \t\tvxo       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tmu0      \t= 1650          \t\t\tfrom [0:inf);           // Low field mobility [cm2/Vs]\nparameter real \t\tbeta            = 1.5             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tVtO      \t=-3.2894;        \t\t\t\t\t        // Threshold voltage [V]\nparameter real \t\talpha    \t= 3.5;              \t\t\t\t\t\t// Strong to weak inversion transistion parameter//fixed... not to be changed\nparameter real \t\tmc        \t= 5e0           \t\t\tfrom [0:inf);           // Effective mass parameter\n\nparameter real \t\tLgs       \t= 0.46e-6        \t\t\tfrom [0:inf);           // Source access region length [m]\nparameter real \t\tLgd       \t= 0.46e-6       \t\t\tfrom [0:inf);           // Drain access region length [m]\nparameter real \t\tvzeta     \t= 3e-3          \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\n\nparameter real \t\tepsilon   \t= 2.3           \t\t\tfrom [0:inf); \t\t// Self heating mobility parameter (fixed)\nparameter real \t\tvtheta    \t= 0.05           \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg (dont activate unless necessary)\nparameter real \t\tmtheta    \t= 0             \t\t\tfrom [0:inf);           // Scattering: mobility reduction parameter with Vg\nparameter real          lamda           = 0\t\t\t                from [0:inf);           // CLM parameter [1/V]\nparameter real \t\tRc        \t= 0.0240          \t\t\tfrom [0:inf);           // Contact resistance on each side [ohm-cm]\n\nparameter real \t\tRth       \t= 10           \t\t\t\tfrom [0:inf);           // Thermal resistance (To be kept equal to zeta)\nparameter real \t\tCth       \t= 0             \t\t\tfrom [0:inf);           // Thermal capacitance\nparameter real \t\tTnom      \t= 27.0          \t\t\tfrom [-100:inf);        // Nominal (extraction) temperature\n\nparameter real \t\tvxord       \t= 1.30e7         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrd     \t= -2.0;\t         \t\t\t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrd      \t= 5.0e-7         \t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rd  \t= 1.3          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rd  \t= 0.30          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tVdibsat  \t= 2.0          \t\t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrd       \t= 0.35         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tzeta      \t= 0.0\t\t \t\t\tfrom [0:inf);           // Self heating parameter (scalable)\nparameter real \t\tbetard    \t= 1.3           \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\nparameter real \t\tvthetard  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrd      \t= 0*0.80             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\n\nparameter real \t\tvxors       \t= vxord         \t\t\tfrom [0:inf);           // Source injection velocity [cm/s]\nparameter real \t\tVtOrs     \t= VtOrd;\t\t         \t\t\t\t// Threshold voltage of drain access transistor[V]\nparameter real \t\tCgrs      \t= Cgrd    \t\t\t\tfrom (0:inf);           // Drain access areal capacitance [F/cm2]\nparameter real \t\tdelta1rs  \t= delta1rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tdelta2rs  \t= delta2rd          \t\t\tfrom [0:inf);           // DIBL for drain access transitor\nparameter real \t\tSrs       \t= Srd         \t\t\t\tfrom [0:inf);           // Subthreshold slope for drain access transitor [V/Dec]\nparameter real \t\tvthetars  \t= 0.05             \t\t\tfrom [0:inf);           // Scattering: velocity reduction parameter with Vg \nparameter real \t\tndrs      \t= ndrd             \t\t\tfrom [0:inf);           // Punchthrough factor affects slope change in subthreshold\nparameter real \t\tbetars      \t= betard             \t\t\tfrom [0:inf);           // Linear to saturation transition parameter\n\n`define  SMALL_VALUE  (1e-10)\n`define  LARGE_VALUE  (80)  \n\nreal Leff, Wg, Wgacc, Ls, Ld, Lmeff, phit;\nreal FFs, FFd, Fsd, etas, etad, Vdx, Qinvs, Qinvd, Vdsc, vx01 ;\nreal Ec1, A, B, Vds_smooth, qsv1,qdv1, dvg, VtOb, n, Qrefs, Qrefd;\nreal Qinv, Vdsats, Vdsat, Fsat;\nreal v, dir, Qsif, Qdif, Qsov, Qdov, vx0, mu;\nreal Rs, Fs, Fd, Fscc, Fdcc, Qscc, Qdcc, FFx, FFy;\nreal Cofs, Cofd, Cif;\nreal n_phit, Fs_arg, Fd_arg;\nreal me, kFsatq, Ap, Bp, Ecs;\nreal qsv, qdv, kvsatq, Qg, Qb, Qs, Qd, Qinvx, Qinvy;\nreal qs, qd, qd1, dQinv; \nreal Qinvi, etai, Fsatq;\nreal qsb, qdb, kq4, kq2, kq, tol;\nreal qsc, qdc, den, t, alp, Vdsatq, Vgt, beta1;\nreal Tsh, T, TambK, Tfac,  Tvfac, TnomK, Ids,Vdsats1, Vdsat1, delta;\nreal Vgs_raw,  Vgd_raw, dvg_raw;\nreal alpha_phit, two_ns_phit, two_nd_phit;\n\nreal Ldtot, Vgsrd_raw, Vgdrd_raw, dirrd  ; \nreal FFsrd, FFdrd, Fsdrd, etasrd, etaFFsrd, etadrd, etaFFdrd, Vdxrd, Qinvsrd,Qinvdrd, Vdscrd, vx01rd ; \nreal VtObrd, nrd, Qrefsrd, Qrefdrd; \nreal Vdsatsrd, Vdsatrd, Fsatrd; \nreal vrd, vx0rd, murd, Tfacrd;   \nreal Vdsi, Vgsi, Vgdi;  \nreal Idsrd, Vdsats1rd, Vdsat1rd, deltard; \nreal two_ns_phitrd, two_nd_phitrd, Vdsrdi, Vgsrdi;\n\nreal Vgsrs_raw, Vgdrs_raw, dirrs  ; \nreal FFsrs, FFdrs, Fsdrs, etasrs, etaFFsrs, etadrs, etaFFdrs, Vdxrs, Qinvsrs,Qinvdrs, Vdscrs, vx01rs ; \nreal VtObrs, nrs, Qrefsrs, Qrefdrs; \nreal Vdsatsrs, Vdsatrs, Fsatrs; \nreal vrs, vx0rs, murs, Tfacrs;    \nreal Idsrs, Vdsats1rs, Vdsat1rs, deltars; \nreal two_ns_phitrs, two_nd_phitrs, Vdsrsi, Vgsrsi;\nreal dibsatrd, dibsatrs;\n\nanalog begin\n\n    //Conversion of lengths from [m] to [cm]\n    Wg         \t\t= W * 100.0;\n    Leff       \t\t= L * 100.0;\n    Ls         \t\t= Lgs * 100.0;\n    Ldtot      \t\t= Lgd * 100.0;\n    Ld\t       \t\t= Ldtot;\n    Cofs       \t\t= Cofsm / 100.0;\n    Cofd       \t\t= Cofdm / 100.0;\n    Cif        \t\t= Cifm / 100.0; \n\n    //If-statments for Vdsi,Vgsi,dir\n    //Conditional statements to be put to enable source drain symmetry\n\n    Vgs_raw    \t\t= type * ( V(g)-V(si) );\n    Vgd_raw    \t\t= type * ( V(g)-V(di) );\n    if ( Vgs_raw >=  Vgd_raw ) begin // forward mode\n    \tVdsi       \t= type * ( V(di)-V(si) );\n    \tVgsi       \t= Vgs_raw;\n\tdir        \t= 1;\n    end else begin // reverse mode\n    \tVdsi       \t= type * ( V(si)-V(di) );\n    \tVgsi       \t= Vgd_raw;\n    \tdir        \t= -1;\n    end\n\n    Vgsrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(src) );\n    Vgdrs_raw  \t\t= type * ( VtOrs + 1.0 / ( Rsh * Cgrs * mu0 ) - V(si) );\n    if ( type * ( V(si) - V(src) ) >=  0.0 ) begin // forward mode\n    \tVdsrsi     \t= type * ( V(si)-V(src) );\n    \tVgsrsi     \t= Vgsrs_raw;\n\tdirrs      \t= 1;\n    end else begin // reverse mode\n    \tVdsrsi     \t= type * ( V(src)-V(si) );\n    \tVgsrsi     \t= Vgdrs_raw;\n    \tdirrs      \t= -1;\n    end\n\n\n    Vgsrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(di) );\n    Vgdrd_raw  = type * ( VtOrd + 1.0 / ( Rsh * Cgrd * mu0 ) - V(drc) );\n    if ( type * ( V(drc) - V(di) ) >=  0.0 ) begin // forward mode\n    \tVdsrdi     \t= type * ( V(drc)-V(di) );\n    \tVgsrdi     \t= Vgsrd_raw;\n\tdirrd      \t= 1;\n    end else begin // reverse mode\n    \tVdsrdi     \t= type * ( V(di)-V(drc) );\n    \tVgsrdi     \t= Vgdrd_raw;\n    \tdirrd      \t= -1;\n    end\n\n    //Temperature dependant expressions\n    TambK      \t\t= $temperature;\n    TnomK      \t\t= Tnom + `P_CELSIUS0;\n    Tsh       \t\t= Temp(dt);\n    T\t       \t\t= TambK + Tsh;\n    Tfac       \t\t= pow( T/TnomK , epsilon );\n    Tfacrd     \t\t= Tfac;\n    Tfacrs     \t\t= Tfac;\n    Tvfac      \t\t= ( 1.0 + vzeta * TnomK ) / ( 1.0 + vzeta * T );\n    phit       \t\t= $vt(T);\n\n    //The calculation of DC current\n    alpha_phit \t\t= alpha * phit;\n    delta      \t\t= delta1 * Vdsi;\n    n          \t\t= S / ( 2.3 * phit ) + nd * Vdsi; \n    VtOb       \t\t= VtO;    \n    FFs        \t\t= 1.0 / ( 1 + exp( ( Vgsi - ( VtOb - delta - alpha_phit / 2.0 ) ) / ( n * alpha_phit ) ) );\n    two_ns_phit\t\t= 1.0 * n * phit;\n    Qrefs      \t\t= Cg * two_ns_phit;\n    etas       \t\t= ( Vgsi - ( VtOb - delta - 0.5 * alpha_phit * FFs ) ) / two_ns_phit;\n    if ( etas  <= `LARGE_VALUE ) begin\n        Qinvs      \t= Qrefs * ln( 1.0 + exp( etas ) ); \n    end else begin\n        Qinvs      \t= Qrefs * ( etas ); \n    end\n    Qinv\t\t= Qinvs;\n    mu         \t\t= mu0 / Tfac / ( 1.0  +  mtheta * Qinvs / Cg );\n    vx01       \t\t= vxo / ( 1.0 + vtheta * ( Qinvs / Cg ) ) * Tvfac * ( 1.0 + lamda *  Vdsi / Leff );\n    vx0        \t\t= FFs * phit  + ( 1 - FFs) * vx01;\n    Vdsats     \t\t= vx01 * Leff / mu;\n    Vdsats1    \t\t= vx01 * Leff / mu ;\n    Vdsat      \t\t= Vdsats  * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsat1     \t\t= Vdsats1 * ( 1 - FFs ) + two_ns_phit * FFs;\n    Vdsc       \t\t= Vdsi;\n    Fsat       \t\t= Vdsc / Vdsat / ( pow( 1.0 + pow( abs( Vdsc / Vdsat ), beta ), 1.0 / beta ) );\n    v          \t\t= vx01 * Fsat;\n    Ids        \t\t= dir * type * Wg  * Qinvs * v;\n    I(di,si)   \t\t<+ Ids;\n\n\n    //Current in drain side access transistor\n    dibsatrd  \t\t= Vdsrdi / ( pow ( 1.0 + pow( abs( Vdsrdi / Vdibsat ), betard ), 1.0 / betard ) );\n    deltard   \t\t= ( delta1rd - delta2rd * dibsatrd ) * Vdsrdi;\n    nrd       \t\t= Srd / ( 2.3 * phit ) + ndrd * Vdsrdi; \n    VtObrd    \t\t= VtOrd;     \n    etaFFsrd  \t\t= ( Vgsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFsrd <= `LARGE_VALUE ) begin\n\tFFsrd     \t= 1.0 / (1 + exp( etaFFsrd ) );\n    end else begin\n        FFsrd     \t= exp( -etaFFsrd );\n    end\n    two_ns_phitrd\t= 2.0 * nrd  * phit;\n    Qrefsrd   \t\t= Cgrd * two_ns_phitrd; \n    etasrd    \t\t= ( ( Vgsrdi ) - ( VtObrd - deltard - 0.5 * alpha_phit * FFsrd ) ) / two_ns_phitrd; \n    if ( etasrd  <= `LARGE_VALUE ) begin\n        Qinvsrd      \t= Qrefsrd * ln( 1.0 + exp( etasrd ) );   \n    end else begin\n        Qinvsrd      \t= Qrefsrd * ( etasrd ); \n    end\n    murd      \t\t= mu0 / Tfacrd / ( 1.0 + mtheta * Qinvsrd / Cgrd );\n    vx01rd    \t\t= vxo / ( 1.0 + vthetard * ( Qinvsrd / Cgrd ) ) * Tvfac; \n    vx0rd     \t\t= 2.0 * FFsrd * phit * murd / Ld + ( 1 - FFsrd ) * vx01rd; \n    Vdsatsrd  \t\t= vx01rd * Ld / murd;\n    Vdsats1rd \t\t= vx01rd * Ld / murd;\n    Vdsatrd   \t\t= Vdsatsrd  * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;\n    Vdsat1rd  \t\t= Vdsats1rd * ( 1 - FFsrd ) + two_ns_phitrd * FFsrd;  \n    Fsdrd     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrdi / Vdsat1rd ) , betard ), 1.0 / betard );\n    Vdxrd     \t\t= Vdsrdi * Fsdrd;\n    etaFFdrd  \t\t=( Vgsrdi - Vdsrdi - ( VtObrd - deltard - alpha_phit / 2.0 ) ) / ( nrd * alpha_phit );\n    if ( etaFFdrd <= `LARGE_VALUE ) begin\n\tFFdrd     \t= 1.0 / ( 1 + exp( etaFFdrd ) );\n    end else begin\n        FFdrd     \t= exp( -etaFFdrd );\n    end\n    two_nd_phitrd\t= 2.0 * nrd * phit;\n    Qrefdrd   \t\t= Cgrd * two_nd_phitrd;\n    etadrd    \t\t= ( Vgsrdi - Vdxrd - ( VtObrd - deltard - 0.5 * alpha_phit * FFdrd ) ) / two_nd_phitrd; \n    if ( etadrd  <= `LARGE_VALUE ) begin\n        Qinvdrd      \t= Qrefdrd * ln( 1.0 + exp( etadrd ) );   \n    end else begin\n        Qinvdrd      \t= Qrefdrd * ( etadrd ); \n    end\n    Vdscrd    \t\t= ( Qinvsrd - Qinvdrd ) / Cgrd;\n    Fsatrd    \t\t= Vdscrd / Vdsatrd / ( pow( 1.0 + pow( abs( Vdscrd / Vdsatrd ), betard ), 1.0 / betard ) );\n    vrd       \t\t= vx0rd * Fsatrd; \n    Idsrd     \t\t= dirrd * type * Wg * 0.5 * ( Qinvsrd + Qinvdrd ) * vrd;\n    if (Rsh > 0 && Ld > 0)\n        I(drc,di)\t<+ Idsrd; \n    else \n       \tV(drc,di)\t<+ 0; \n\n    //Drain side contact resistance \n    if (Rc > 0) \n       I(drc,d)    \t<+ V(drc,d) / ( Rc / Wg ); \n    else \n       V(drc,d)    \t<+ 0;\n\n    //Current in source side access transistor\n    dibsatrs  \t\t= Vdsrsi / ( pow( 1.0 + pow( abs( Vdsrsi / Vdibsat ), betars ), 1.0 / betars ) );\n    deltars   \t\t= ( delta1rs - delta2rs * dibsatrs ) * Vdsrsi;\n    nrs       \t\t= Srs / ( 2.3 * phit ) + ndrs * Vdsrsi; \n    VtObrs    \t\t= VtOrs;     \n    etaFFsrs  \t\t= ( Vgsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if ( etaFFsrs <= `LARGE_VALUE ) begin\n\tFFsrs     \t= 1.0 / ( 1 + exp( etaFFsrs ) );\n    end else begin\n        FFsrs     \t= exp( -etaFFsrs );\n    end\n    two_ns_phitrs       = 2.0 * nrs * phit;\n    Qrefsrs  \t\t= Cgrs * two_ns_phitrs; \n    etasrs    \t\t= ( ( Vgsrsi ) - ( VtObrs - deltars - 0.5 * alpha_phit * FFsrs ) ) / two_ns_phitrs; \n    if ( etasrs  <= `LARGE_VALUE ) begin\n        Qinvsrs      \t= Qrefsrs * ln( 1.0 + exp( etasrs ) );   \n    end else begin\n        Qinvsrs      \t= Qrefsrs * ( etasrs ); \n    end\n    murs      \t\t= mu0 / Tfacrs / ( 1.0 + mtheta * Qinvsrs / Cgrs );\n    vx01rs    \t\t= vxo / ( 1.0 + vthetars * ( Qinvsrs / Cgrs ) ) * Tvfac; \n    vx0rs     \t\t= 2.0 * FFsrs * phit * murs / Ls + ( 1 - FFsrs ) * vx01rs; \n    Vdsatsrs  \t\t= vx01rs * Ls / murs;\n    Vdsats1rs \t\t= vx01rs * Ls / murs;\n    Vdsatrs   \t\t= Vdsatsrs  * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;\n    Vdsat1rs  \t\t= Vdsats1rs * ( 1 - FFsrs ) + two_ns_phitrs * FFsrs;  \n    Fsdrs     \t\t= 1.0 / pow( 1.0 + pow( abs( Vdsrsi / Vdsat1rs ), betars), 1.0 / betars );\n    Vdxrs     \t\t= Vdsrsi * Fsdrs;\n    etaFFdrs  \t\t=( Vgsrsi - Vdsrsi - ( VtObrs - deltars - alpha_phit / 2.0 ) ) / ( nrs * alpha_phit );\n    if (etaFFdrs <= `LARGE_VALUE) begin\n\tFFdrs     \t= 1.0 / ( 1 + exp( etaFFdrs ) );\n    end else begin\n        FFdrs     \t= exp( -etaFFdrs );\n    end\n    two_nd_phitrs\t= 2.0 * nrs * phit;\n    Qrefdrs   \t\t= Cgrs * two_nd_phitrs;\n    etadrs    \t\t= ( Vgsrsi - Vdxrs - ( VtObrs - deltars - 0.5 * alpha_phit * FFdrs ) ) / two_nd_phitrs; \n    if (etadrs  <= `LARGE_VALUE) begin\n        Qinvdrs      \t= Qrefdrs * ln( 1.0 + exp( etadrs ) );   \n    end else begin\n        Qinvdrs      \t= Qrefdrs * ( etadrs ); \n    end\n    Vdscrs    \t\t= ( Qinvsrs - Qinvdrs ) / Cgrs;\n    Fsatrs    \t\t= Vdscrs / Vdsatrs / ( pow( 1.0 + pow( abs( Vdscrs / Vdsatrs ), betars ), 1.0 / betars ) );\n    vrs       \t\t= vx0rs * Fsatrs; \n    Idsrs     \t\t= dirrs * type * Wg * 0.5 * ( Qinvsrs + Qinvdrs ) * vrs;\n    if (Rsh > 0 && Ls > 0)\n       \t I(si,src)\t<+ Idsrs; \n    else \n       \tV(src,si)\t<+ 0; \n\n    //Source side contact resistance \n    if (Rc > 0) \n       I(src,s)    \t<+ V(src,s) / ( Rc / Wg ); \n    else \n       V(src,s)    \t<+ 0;\n\n    // Charge computation\n    // NVsat model\n    Vgt        \t\t= Qinv / Cg;\n    alp       \t\t= 1.0;\n    Vdsatq     \t\t= sqrt( 9.0 * phit * phit + Vgt * Vgt / ( alp * alp ) );\n    beta1      \t\t= 1.5;\n    Fsatq      \t\t= ( ( Vdsi ) / Vdsatq ) / ( 1.0 + pow( pow( Vdsi / Vdsatq, beta1 ), 1.0 / beta1 ) );\n    t          \t\t= 1.0 - Fsatq;\n    den        \t\t= 15.0 * ( 1.0 + t ) * ( 1.0 + t );\n    qsc       \t \t= ( 6.0 + t * ( 12.0 + t * ( 8.0 + 4.0 * t ) ) ) / den;\n    qdc        \t\t= ( 4.0 + t * ( 8.0 + t * ( 12.0 + 6.0 * t ) ) ) / den;\n \n    //QB model\n    me         \t\t= 9.1e-31 * mc;\n    kq         \t\t= 0.0;\n    tol        \t\t= ( `SMALL_VALUE * vxo / 100 ) * ( `SMALL_VALUE * vxo / 100 ) * me / ( 2 * `P_Q );\n    if  ( Vdsi <= tol ) begin    \n\tkq2    \t\t= ( 2.0 * `P_Q / me * Vdsi ) / ( vxo * vxo ) * 10000.0;\n        kq4    \t\t= kq2 * kq2;\n        qsb    \t\t= 0.5 - kq2 / 24.0 + kq4 / 80.0;\n        qdb    \t\t= 0.5 - 0.125 * kq2 + kq4 / 16.0;\n    end\n    else begin\n        kq     \t\t= sqrt( 2.0 * `P_Q / me * Vdsi ) / vxo * 100.0;\n        kq2    \t\t= kq  * kq;\n        qsb    \t\t= asinh( kq ) / kq - ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n        qdb    \t\t= ( sqrt( kq2 + 1.0 )-1.0 ) / kq2;\n    end\n\n    qs         \t\t= Qinv * ( qsc * ( 1.0 - Fsat ) + qsb * Fsat );\n    qd1        \t\t= Qinv * ( qdc * ( 1.0 - Fsat ) + qdb * Fsat );\n  \n    //DIBL correction\n    etai       \t\t= ( Vgsi - ( VtOb - FFs * alpha_phit ) ) / ( n * phit );\n    if ( etai <= `LARGE_VALUE )\n        Qinvi  \t\t= Qrefs * ln( 1.0 + exp( etai ) );\n    else\n        Qinvi  \t\t= Qrefs * etai;\n    dQinv      \t\t= Qinv - Qinvi;\n    qd         \t\t= qd1 - ( 1.0 - Fsat ) * ( qs + qd1 ) * dQinv;\n\n    //Inner fringing Caps\n    Fs_arg \t\t= ( Vgs_raw - VtOb ) / ( 1.0 * n * phit );\n    if ( Fs_arg <= `LARGE_VALUE ) begin\n        Fs     \t\t= 1.0 + exp( Fs_arg );\n        FFx    \t\t= Vgs_raw - n * phit * ln( Fs );\n    end else begin\n        Fs     \t\t= 0.0; // not used\n        FFx    \t\t= Vgs_raw - n * phit * Fs_arg;\n    end\n\n    Fd_arg\t\t= ( Vgd_raw - VtOb ) / ( 5.0 * n * phit );\n    if ( Fd_arg <= `LARGE_VALUE ) begin\n        Fd     \t\t= 1.0 + exp( Fd_arg );\n        FFy    \t\t= Vgd_raw - n * phit * ln( Fd );\n    end else begin\n        Fd     \t\t= 0.0; // not used\n        FFy    \t\t= Vgd_raw - n * phit * Fd_arg;\n    end\n\n    Qsif       \t\t= type * Cif * FFx ;\n    Qdif       \t\t= type * Cif * FFy ;\n\n    //Channel charges/Caps\n    Qinvx      \t\t= type * Leff *  0.5 * ( ( 1 + dir ) * qs + ( 1 - dir ) * qd );\n    Qinvy      \t\t= type * Leff *  0.5 * ( ( 1 - dir ) * qs + ( 1 + dir ) * qd );\n\n    //Outer fringing Caps\n    Qsov       \t\t= Cofs * (V(g) - V(si));\n    Qdov       \t\t= Cofd * (V(g) - V(di));\n\n    Qs         \t\t= -Wg * ( Qinvx + Qsov + Qsif );\n    Qd         \t\t= -Wg * ( Qinvy + Qdov + Qdif );\n    Qb         \t\t= 0;\n    Qg         \t\t= - ( Qs + Qd + Qb );\n\n    I(g,si)    \t\t<+ -ddt(Qs);\n    I(g,di)    \t\t<+ -ddt(Qd);\n\n\n    // Self-heating\n    if (Rth !=0) begin\n        Pwr(dt)    \t<+ ddt( Cth * Temp(dt) );\n        Pwr(dt)   \t<+ - ( I(di,si) * V(di,si) + I(d,drc) * V(d,drc) + I(src,s) * V(src,s) + V(drc,di) * I(drc,di) + V(src,si) * I(src,si) );\n        Pwr(dt)   \t<+ Temp(dt) / Rth;\n    end\n    else\n       Temp(dt)   <+0.0;\n\nend\n\nendmodule\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf;           // Width of the device [m] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real \t\tW         \t= 25e-6         \t\t\tfrom (0:inf);           // Width of the device [m]\n\n Correction Criteria：Missing closing parenthesis ')' in parameter range constraint"
      }
    ]
  }
]