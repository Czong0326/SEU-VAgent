//  VerilogA baseband behavioral model of a down-converting IQ mixer pair.
//  Copyright (c) 1999
//  by Cadence Design Systems, Inc.  All rights reserved.
 
// 11/20/99
 
/*
This is a simple baseband model of down-converting mixer stage. The local
oscillator is absorbed into this model.
*/
 
/* PARAMETER DEFINITIONS:
======================
I_gain    = available power gain in dB. 
I_IP3     = input referenced IP3(dBm)
I_psinf   = output phase shift as the input power goes to infinity.
I_cmp     = input power pt for phase point.[dBm]
I_pscp    = output phase shift at cmp.[radians]
I_shp     = determines how fast the phase shift occurs with increasing
          input power. A larger number delays the shift but makes
          the shift rise faster as a function of input signal level.
I_cw      = determines the direction of the phase shift. The phase
          shift is only in one direction. +1 means counter-clockwise, -1
          means clockwise, and 0 means no phase shift (no am/pm conversion).

Q_gain    = voltage gain in dB.
Q_IP3     = input referenced IP3(dBm)
Q_psinf   = output phase shift as the input power goes to infinity.
Q_cmp     = input power pt for phase point.[dBm]
Q_pscp    = output phase shift at cmp.[radians]
Q_shp     = determines how fast the phase shift occurs with increasing
          input power. A larger number delays the shift but makes
          the shift rise faster as a function of input signal level.
Q_cw      = determines the direction of the phase shift. The phase
          shift is only in one direction. +1 means counter-clockwise, -1
          means clockwise, and 0 means no phase shift (no am/pm conversion).
 

nf      = noise figure [dB]
rin     = input resistance
rout    = output resistance
=====================
*/
 
`define PI 3.1415926535897932384626433

`include "constants.h"
`include "discipline.h"

module IQ_demod_BB(I_in , I_out, Q_in, Q_out, phase_err);
inout I_in ;
electrical I_in ;
inout I_out;
electrical I_out;
inout Q_in;
electrical Q_in;
inout Q_out;
electrical Q_out;
inout phase_err;
electrical phase_err;

parameter real I_gain = 40;
parameter real Q_gain = 40;
parameter real I_ip3 = -30;
parameter real Q_ip3 = -30;
parameter real rin = 50 from (0:inf);
parameter real rout = 50 from (0:inf);
 
parameter real I_cmp = -30;
parameter real Q_cmp = -30;
parameter real I_pscp = 0.7 from (0:inf);
parameter real Q_pscp = 0.7 from (0:inf);
parameter real I_psinf = 2 from (I_pscp:inf);
parameter real Q_psinf = 2 from (Q_pscp:inf);
parameter real I_shp = 2 from [0:inf);
parameter real Q_shp = 2 from [0:inf);
parameter integer I_cw = 0 from [-1:1];
parameter integer Q_cw = 0 from [-1:1];
parameter real nf = 2 from [0:inf];

parameter real quad_error = 0;
 
real I_a;
real Q_a;
real I_b;
real Q_b;
real I_ip;
real Q_ip;
real rho;
real I_rhooutmax;
real Q_rhooutmax;
real I_rhoinmax;
real Q_rhoinmax;
real I_rhoout;
real Q_rhoout;
real theta;
real I_theta;
real Q_theta;
real I_beta;
real Q_beta;
real tmp;
real I_cp;
real Q_cp;
real noise_current;
real rnf;
real root2;
 
analog begin
 
// The initial block converts the input parameters from engineering
// units to implementation units.
   @(initial_step) begin

     I_a = sqrt(pow(10,I_gain/10)*rout/rin);
     I_ip = sqrt(pow(10,I_ip3/10)*2*rin*0.001);
     I_cp = sqrt(pow(10,I_cmp/10)*2*rout*0.001)/I_a;
     I_b = I_a/(I_ip*I_ip);
     I_rhoinmax = sqrt(I_a/(3*I_b));
     I_rhooutmax = (2*I_a/3)*I_rhoinmax;
     I_beta = I_pscp/(I_psinf-I_pscp);

     Q_a = sqrt(pow(10,Q_gain/10)*rout/rin);
     Q_ip = sqrt(pow(10,Q_ip3/10)*2*rin*0.001);
     Q_cp = sqrt(pow(10,Q_cmp/10)*2*rout*0.001)/Q_a;
     Q_b = Q_a/(Q_ip*Q_ip);
     Q_rhoinmax = sqrt(Q_a/(3*Q_b));
     Q_rhooutmax = (2*Q_a/3)*Q_rhoinmax;
     Q_theta = 0;
     Q_beta = Q_pscp/(Q_psinf-Q_pscp);

     root2 = sqrt(2);

     rnf = pow(10,nf/10);
     noise_current = sqrt(8*(rnf-1)*1.380620e-23*$temperature/rin);
 
   end

// Compute the input angle and radius.
  if (V(I_in) !=0) theta = atan2(V(Q_in),V(I_in));
  else if (V(Q_in) > 0) theta = `PI/2;
  else theta = -`PI/2;
  rho = hypot(V(I_in),V(Q_in));
 

 
// Apply the third order non-linearity. Clamp the
// output for extreme inputs.
  if ( abs(rho) < I_rhoinmax ) I_rhoout = (I_a - I_b*rho*rho)*rho;
  else if (rho < 0) I_rhoout = -I_rhooutmax;
  else I_rhoout = I_rhooutmax;
  if ( abs(rho) < Q_rhoinmax ) Q_rhoout = (Q_a - Q_b*rho*rho)*rho;
  else if (rho < 0) Q_rhoout = -Q_rhooutmax;
  else Q_rhoout = Q_rhooutmax;

 
// Rotate the output for am/pm conversion.
  tmp = pow(rho/I_cp,I_shp);
  I_theta = theta+I_cw*(1+I_beta)*I_pscp*tmp/(1+I_beta*tmp)-V(phase_err)-quad_error/2;

  tmp = pow(rho/Q_cp,Q_shp);
  Q_theta = theta+Q_cw*(1+Q_beta)*Q_pscp*tmp/(1+Q_beta*tmp)-V(phase_err)+quad_error/2;

 
  I(phase_err) <+ V(phase_err)/50;
  I(I_in) <+ V(I_in)/rin;
  I(Q_in) <+ V(Q_in)/rin;
  I(I_out) <+ (-root2*I_rhoout*cos(I_theta) + V(I_out))/rout;
  I(Q_out) <+ (-root2*Q_rhoout*sin(Q_theta) + V(Q_out))/rout;
 
  I(I_in) <+ white_noise(noise_current*noise_current, "IQ_demod_BB_i");
  I(Q_in) <+ white_noise(noise_current*noise_current, "IQ_demod_BB_q");
 
end

endmodule
