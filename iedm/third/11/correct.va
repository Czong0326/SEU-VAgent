// VerilogA for sources_modules, RC_Transmitter, veriloga
// Cadence Design System, Inc. 2010
// Written by Xihu Lai, Dec 2010

`include "constants.vams"
`include "disciplines.vams"

(* instrument_module *)
module RC_Transmitter(I_in, Q_in, I_out, Q_out);
input  I_in,  Q_in;
output I_out, Q_out;
electrical I_in, Q_in, I_out, Q_out;

parameter integer group_delay = 4;
parameter real frame_time = 5e-8;
parameter real alpha = 0.22;
parameter integer over_samples = 4;
parameter integer numChipsOut = 1;

real filter_taps[0:(2*group_delay*over_samples+1)],
       i_input_data[0:(2*group_delay*over_samples+1)],
       q_input_data[0:(2*group_delay*over_samples+1)];
real tmp, gain, alpha2;
real period, i_out, q_out, delay;
integer tmpInteger, middle, taps;
real start_time;
integer i, j, k;
integer upflag;

analog begin
  @(initial_step) begin
    delay = group_delay*over_samples;
    taps =2*delay+1;
//    gain = sqrt ( over_samples ) / over_samples / 2.0;
//    gain = gain * sqrt(over_samples)
    gain =  1;
    alpha2 = 4 * alpha * alpha;
    middle = floor(taps / 2.0);

    for ( i = 0; i < middle; i = i + 1 ) begin
      tmpInteger = taps-i-1;
      i_input_data[i]  = 0;
      q_input_data[i] = 0;
      i_input_data[tmpInteger]  = 0;
      q_input_data[tmpInteger] = 0;
      tmp  = ( i - delay ) / over_samples;
      if( ceil(tmp) ==  floor(tmp) )
        filter_taps[i] = 0;
      else
        filter_taps[i] = sin(`M_PI*tmp)*cos(`M_PI*alpha*tmp)/(`M_PI*tmp*(1-alpha2*pow(tmp, 2)));

      filter_taps[tmpInteger] =  filter_taps[i];
    end

    i_input_data[middle]  = 0;
    q_input_data[middle] = 0;
    filter_taps[middle] =  1;
    period = frame_time / over_samples / numChipsOut;
    i_out  = 0;
    q_out  = 0;
    start_time = frame_time / numChipsOut ;
    start_time = start_time / 500 ;
    j = 0 ;
    k = 0 ;
    upflag = 0;
  end

   @(timer(start_time, period)) begin
    i_out  = 0;
    q_out = 0;
    for ( i = taps - 1 ; i > 0; i = i - 1 ) begin
       i_input_data[i] =  i_input_data[i-1];
       q_input_data[i] =  q_input_data[i-1];
      i_out  = i_out   +  i_input_data[i] * filter_taps[i];
      q_out = q_out + q_input_data[i] * filter_taps[i];
    end

    if ( upflag ==  0 ) begin
        i_input_data[0]  = V(I_in);
        q_input_data[0] = V(Q_in);
    end else begin
        i_input_data[0] = 0 ;
        q_input_data[0] = 0 ;
    end

    i_out  = i_out   +  i_input_data[0] * filter_taps[0];
    q_out = q_out + q_input_data[0] * filter_taps[0];
    
    upflag = upflag + 1;
    if ( upflag == over_samples )
        upflag = 0 ;  
  end

 

  V(I_out)  <+  i_out;
  V(Q_out) <+ q_out;
end

endmodule
