// VerilogA for sources_modules, MPSK, veriloga
// This model implement a M-array PSK baseband modulator
// 3 modes in ouput constellation: "Gray", "Binary" and "user_defined"
// When specifing "user_defined", Usr_mappig_vec need to be specified as [0 1 ... M-1].
// Phase is decided by phase_offset * pi. 
// Input: MSB...LSB -> [inbit[`Bits -1] ... inbit[1] inbit[0]]
// Change M and Bits according to your need
// Write on 9/20/2010 

`include "constants.vams"
`include "disciplines.vams"
`define M 8
`define Bits 3

(* instrument_module *)
module MPSK(inbit, outi, outq);
input [0:`Bits -1] inbit;
output outi, outq;
electrical [0:`Bits -1] inbit;
electrical outi, outq;

parameter real Symbol_Period = 1e-6 from (0:inf);
parameter string Constellation_ordering = "Gray";
parameter integer Usr_mappig_vec[0:`M-1] = {0, 1, 2, 3, 4, 5, 6, 7};
parameter real phase_offset = 1.0/8;
parameter integer Disable_input = 0 from [0:1];
parameter integer Seed = 12345;

integer integerOut, tmpInteger;
integer mappingArray[0:`M-1];
integer i, use_seed;
real PhaseImag[0:`M-1], PhaseReal[0:`M-1];
real tmp[0:`Bits-1];


analog begin
  @(initial_step) begin

    if ( Constellation_ordering == "Binary" ) begin
      for (i = 0; i < `M; i = i + 1)
        mappingArray[i] = i ;
    end else if ( Constellation_ordering == "Gray" ) begin
      for (i = 0; i < `M; i = i + 1) begin
        tmpInteger      = i ^ (i>>8);
        tmpInteger      = tmpInteger ^ (tmpInteger>>4);
        tmpInteger      = tmpInteger ^ (tmpInteger>>2);
        tmpInteger      = tmpInteger ^ (tmpInteger>>1);
        mappingArray[i] = tmpInteger ^ (tmpInteger>>8);
      end
    end 

    for (i = 0; i < `M; i = i + 1) begin
        PhaseReal[i] = cos(phase_offset * `M_PI + i * `M_TWO_PI / `M);
        PhaseImag[i] = sin(phase_offset * `M_PI + i * `M_TWO_PI / `M);
    end

    integerOut = 0;
    use_seed  = Seed;
    tmpInteger = 1;
  end

  @(timer( 0, Symbol_Period, Symbol_Period/100000)) begin

    generate j (0, `Bits-1) begin
        if ( Disable_input ) 
            tmp[j] = $rdist_uniform(use_seed, 0, 1);
        else 
            tmp[j] = V(inbit[j]);
    end

    integerOut = 0;
    for (i=0; i < `Bits; i = i+1)
        if ( tmp[i] > 0.5 )
            integerOut = integerOut + pow(2, i);

    if ( Constellation_ordering == "user_defined" ) 
        tmpInteger = Usr_mappig_vec[integerOut];
    else 
        tmpInteger = mappingArray[integerOut];
  end

  V(outi)  <+ PhaseReal[tmpInteger];
  V(outq) <+ PhaseImag[tmpInteger];

end

endmodule
