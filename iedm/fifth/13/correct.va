`include "discipline.h"
`include"constants.h"


// $Date: 1997/08/28 05:53:40 $
// $Revision: 1.1 $
//
//
// Based on the OVI Verilog-A Language Reference Manual, version 1.0 1996
//
//

`define PI  	3.14159265358979323846264338327950288419716939937511
`define ABSTOL_TIME 1e-12


//--------------------
// zmeter
//
// -  Impedance meter
//
// iin:		input for current passing through the meter [V,A]
// vp_iout:	positive voltage sensing terminal and output for current
//              passing through the meter [V,A]
// vn:		negative voltage sensing terminal [V,A]
// zout:	measured impedance converted to a voltage [Ohms]
//
// INSTANCE parameters
//    bw          = bw of rms filters (a first order filter) [Hz]
//    log_to_file = whether to log the results to a file; yes or no []
//
// MODEL parameters
//    {none}
//
// In order to measure the impedance across 2 port device,
// this meter should be placed in the netlist so that the current flowing
// into the device passes between 'iin' and 'vp_iout' first,
// that 'vp_iout' is connected to the positive terminal of the device and
// that 'vn' is connected to the negative terminal of the device.
//
// The impendance is calculated by finding the rms values of the current and
// voltage first and filtering them with a first order filter of bandwidth,
// 'bw'. The impedance is the ratio of these filtered Irms and Vrms values.
// The purpose of the filtering is to remove ripple.
//
// It is recommended that the 'bw' be set to a low value in order to
// produce accurate measurements and that at least 10 input ac cycles be
// allowed before the zmeter is considered settled. Also allow time
// for the filters to settle.
//
// The timestep size should also be kept small in order to increase
// accuracy.
//
// This meter is non-instrusive - .i.e. it doesn't drive current in the
// device being measured. However to work it requires that something else
// drives current through the device.
//

nature Impedance
	abstol = 1m;
	huge = 100M;
	units = "Ohms";
	access = Z;
endnature

discipline impedance_current
	potential Impedance;
	flow Current;
enddiscipline

module zmeter(iin,vp_iout,vn,zout);
electrical iin, vp_iout, vn;
impedance_current zout;
parameter real bw = 10 from (0:inf);
parameter integer log_to_file = 0;

   electrical v_ifilt1, v_ifilt2;
   electrical v_vfilt1, v_vfilt2;
   electrical vgnd;

   svcvs  #(.poles({-2*`PI*bw,0})) irms_filter (v_ifilt2,vgnd,v_ifilt1,vgnd);
   svcvs  #(.poles({-2*`PI*bw,0})) vrms_filter (v_vfilt2,vgnd,v_vfilt1,vgnd);

   integer out_file;

   real vin_val;
   real iin_val;

   real v_vfilt1_val;
   real v_ifilt1_val;

   real irms;
   real vrms;

   real integ_vin_sqd; // Need to integrate squares of vin,iin because 
   real integ_iin_sqd; //  impedance measurement is based on rms values


   real zout_val;	// measured impedance

   analog begin
      
      @ ( initial_step ) begin
         if (log_to_file) begin
             out_file = $fopen( "%C:r.dat" );
             $fstrobe(out_file,"# Generated by Spectre from module `%M'");
         end
      end

      V(vgnd) <+ 0;

      // so that device is not intrusive
      V(iin,vp_iout) <+ 0;

      vin_val = V(vp_iout,vn);
      iin_val = I(iin,vp_iout);

      integ_vin_sqd  = idt(vin_val*vin_val,0);
      integ_iin_sqd  = idt(iin_val*iin_val,0);

      // vrms calculation 
      //
      integ_vin_sqd  = idt(vin_val*vin_val,0);
      if ($abstime > `ABSTOL_TIME) begin	// to avoid div by zero error
          v_vfilt1_val = sqrt(integ_vin_sqd/$abstime);
      end else begin
          v_vfilt1_val = 0;
      end

      V(v_vfilt1) <+ v_vfilt1_val;
      vrms = V(v_vfilt2);

      // irms calculation 
      //
      integ_iin_sqd  = idt(iin_val*iin_val,0);
      if ($abstime > `ABSTOL_TIME) begin	// to avoid div by zero error
          v_ifilt1_val = sqrt(integ_iin_sqd/$abstime);
      end else begin
          v_ifilt1_val = 0;
      end

      V(v_ifilt1) <+ v_ifilt1_val;
      irms = V(v_ifilt2);


      // impedance calculation
      //
      if ( irms > zout.flow.abstol )  begin
         zout_val = vrms/irms;
         if (log_to_file) begin
            $fstrobe(out_file, "%-.10g\t%-.10g", $abstime, zout_val);
         end
      end else if ($abstime <= `ABSTOL_TIME ) begin
         zout_val = 0;
         if (log_to_file) begin
            $fstrobe(out_file, "%-.10g\t%-.10g", $abstime, zout_val);
         end          
      end  else begin // probably have opencircuit
         zout_val = 1M;
         if (log_to_file) begin
            $fstrobe(out_file, "%-.10g\tinf", $abstime);
         end
      end

      Z(zout) <+ zout_val;

      @ ( final_step ) begin
         if (log_to_file) $fclose(out_file);
      end
   end
endmodule
