[
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nqsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)+(6.0*kq2+4.0))/(3.0*kq2*kq2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nqsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2);\n\n Correction Criteria：Changed subtraction to addition in the numerator, making the ballistic source charge calculation physically incorrect by reversing the sign of the corrective term, which violates charge conservation principles."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real rbt_wgVtoT   = -`RBT_WGVTOT;     // Voltage to Stress conversion Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\n\n Correction Criteria：The negative sign inverts the voltage-to-stress conversion direction, causing the stress calculation to have the opposite polarity. This reverses the piezoresistive effect, making mobility increase when it should decrease (or vice versa) under applied voltage."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nqsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nqsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2);\n\n Correction Criteria：Removed one 'kq2' factor from the denominator, causing incorrect charge scaling by omitting the squared term in the divisor. This distorts the ballistic charge calculation at high Vds."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nVbscorr  = Vbsi + Vgsraw;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nVbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n\n Correction Criteria：Replaced correction voltage Vcorr with raw gate-source voltage Vgsraw, causing incorrect body voltage correction. This disrupts threshold voltage calculations and charge modeling by improperly coupling gate voltage to body bias."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nVdsats          = vx0 * Leff * limexp( ln(rbt_mu) ); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nVdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );\n\n Correction Criteria：Changed sign of the ln argument from negative to positive, making Vdsats proportional to mobility instead of inversely proportional. This reverses the physical relationship where higher mobility should lower the saturation voltage."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_Cif    = -1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm]\n\n Correction Criteria：Assigned negative value to mvss_Cif. Inner fringing capacitance must be non-negative per design, but negative capacitance causes unphysical charge calculations and violates the [0:inf) range constraint."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nnphit   = n - phit;              // Product of n and phit [used as one variable] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nnphit   = n * phit;              // Product of n and phit [used as one variable]\n\n Correction Criteria：Changed multiplication to subtraction, altering the subthreshold slope calculation. This causes incorrect charge and current computations by distorting the thermal voltage scaling factor in weak inversion regions."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        FF       = 1.0/ ( 1.0 - eVg ); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        FF       = 1.0/ ( 1.0 + eVg );\n\n Correction Criteria：Changed addition to subtraction in the denominator, causing FF to become negative when eVg > 1. This reverses the gate voltage dependency and produces unphysical charge/current values in strong inversion."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_zeta   = -0.5   from (0:1];                     // Energy-transfer factor Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n Correction Criteria：Negative energy-transfer factor (-0.5) violates physical constraints and causes imaginary numbers in sqrt(2.0 * `P_Q/me * Vdsi * mvss_zeta) calculations, leading to simulation failures."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nVdbetabeta      = pow( 1.0 + Vdbeta, 1.0) / mvss_beta; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nVdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n\n Correction Criteria：The exponent term 1.0/mvss_beta was mistakenly replaced by 1.0 and the entire pow result is divided by mvss_beta. This causes Vdbetabeta to be (1+Vdbeta)/mvss_beta instead of (1+Vdbeta)^(1/mvss_beta), leading to incorrect saturation behavior and overestimation of drain current."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Rd      = 0;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs.  Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n\n Correction Criteria：Sets drain resistance Rd to 0 ohms, creating an unrealistic short circuit between drain and internal nodes. This violates the physical design requirement of non-zero resistance for terminal connections, causing incorrect voltage drops and current calculations."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nVbscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nVbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n\n Correction Criteria：Used gate-source voltage (Vgsi) instead of body-source voltage (Vbsi) for intrinsic body voltage correction. This swaps body-bias effect with gate-bias effect, disrupting threshold voltage calculations and inversion charge modeling."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_W       = `MVSS_WFET   from [0:inf);           // Transistor width [cm] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\n\n Correction Criteria：Changing the range from (0:inf) to [0:inf) allows zero transistor width. This causes division-by-zero errors in resistance calculations (Rs/Rd = 1e-4/mvss_W) since physical devices require positive width."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_Cof    = 2e-13         from (0:inf);           // Outer fringing S or D capacitance [F/cm]  Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \n\n Correction Criteria：Changed range from [0:inf) to (0:inf), excluding zero. This prevents mvss_Cof=0 which is physically valid for negligible fringing capacitance, violating design specifications."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nelectrical d, g, s; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nelectrical d, g, s, b;\n\n Correction Criteria：Removed the 'b' pin declaration, causing the body terminal to be undefined. This breaks all body voltage (Vbs) calculations and threshold voltage dependencies on body bias, rendering the model non-functional."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        else if (0) begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        else begin\n\n Correction Criteria：The condition '0' is always false, preventing execution of the else block. This leaves qsb and qdb unassigned when Vdsi > tol, causing incorrect charge calculations and potential convergence issues."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qd; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\n\n Correction Criteria：Removed variable 'Qs' from the declaration. This causes an undeclared variable error when 'Qs' is later assigned in the charge calculation (Qs = -mvss_W * ( Qinvs + Qsov + Qsif )), breaking the terminal charge computation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nQsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFy; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nQsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n\n Correction Criteria：Replaced source potential factor FFx with drain factor FFy for source inner fringing charge calculation, causing incorrect cross-coupling between source/drain potentials in charge computation."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_Rs0     = -100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\n\n Correction Criteria：Changed source resistance value from positive 100 to negative -100. Negative resistance is unphysical and violates the parameter range constraint (0:inf), causing instability in resistance calculations and potential simulation divergence."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal dmu = 1.0; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal dmu;\n\n Correction Criteria：Initializing dmu to 1.0 instead of declaring it without initialization causes the mobility modification factor to always include a fixed offset. This corrupts the piezoresistive effect calculation by adding a constant error to the stress-dependent mobility change, making the sensing response inaccurate and non-physical."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit                              // Computed from corrected intrinsic Vbs and intrinsic Vds Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit ) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nelse Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n`else\n\n Correction Criteria：Missing backtick before 'else' directive, causing a syntax error as the preprocessor expects a valid compiler directive starting with a backtick."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nQb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi )) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nQb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nelectrical xdisp vss; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nelectrical xdisp, vss;\n\n Correction Criteria：Missing comma between identifiers in net declaration. VerilogA requires commas to separate multiple identifiers in a single declaration statement."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\ntol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q ; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\ntol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n\n Correction Criteria：Missing closing parenthesis in denominator expression causes mismatched parentheses"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        I(di,si)                <+      mvss_type * dir * Id Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        I(di,si)                <+      mvss_type * dir * Id;\n\n Correction Criteria：Missing semicolon at the end of the contribution statement, causing syntax error as statements must be properly terminated in VerilogA."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        rbt_mu = mvss_mu * mobModFactor Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        rbt_mu = mvss_mu * mobModFactor;\n\n Correction Criteria：Missing semicolon at end of assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_phib   = 1.2,;                                  // ~abs(2*phif)>0 [V] Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\n\n Correction Criteria：Extra comma after parameter value creates invalid syntax (expects another parameter assignment to follow)."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        stress = (- rbt_wgVtoT) * rbt_senseMSF V(xdisp,vss); // -ve sign for equivalent circuit convention Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n\n Correction Criteria：Missing multiplication operator between 'rbt_senseMSF' and 'V(xdisp,vss)', creating invalid adjacent expressions without operator."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs Vdsi, Vgsi, Vbsi, dir; Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\n\n Correction Criteria：Missing comma between Vbs and Vdsi in variable declaration list, causing syntax error due to unseparated identifiers."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Vbscorr  = Vbsi + Vcorr                                                         // Intrinsic Vgs corrected (to be used for charge and current computation) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Vgta                    =       Vgt/ a                                                          // Vdsat in strong inversion Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n\n Correction Criteria：Missing semicolon at end of assignment statement"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        Vdsi = mvss_type * ( V(si) - V(di) ) Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        Vdsi = mvss_type * ( V(si) - V(di) );\n\n Correction Criteria：Missing semicolon at the end of the assignment statement. VerilogA requires all statements to end with a semicolon."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nVdsi = mvss_type * ( V(di) - V(si); Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nVdsi = mvss_type * ( V(di) - V(si) );\n\n Correction Criteria：Missing closing parenthesis in expression - unmatched opening parenthesis remains unclosed"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf           // Saturation factor. Typ. nFET=1.8, pFET=1.6 Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\n\n Correction Criteria：Missing closing parenthesis in the range expression. Correct syntax requires parentheses around range limits: from (min:max)."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\n        elsee begin Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\n        else begin\n\n Correction Criteria：Misspelled 'else' keyword as 'elsee', causing unrecognized token syntax error"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nI(di,b)                 <+      ddt( Qd ;                                                      // charge term: node di to node b Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nI(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n\n Correction Criteria：Missing closing parenthesis in ddt function call. The statement ends with a semicolon inside the parentheses, causing syntax error."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "You are a Verilog-A hardware modeling expert. Below is a reference code snippet:\n```\n//======================================================================\n//Copyright @ 2016 Massachusetts Institute of Technology (MIT)\n// \n// The terms under which the software and associated documentation\n// (the Software) is provided are as the following:\n// \n// The Software is provided \"as is\", without warranty of any kind,\n// express or implied, including but not limited to the warranties of\n// merchantability, fitness for a particular purpose and noninfringement.\n// In no event shall the authors or copyright holders be liable for any claim,\n// damages or other liability, whether in an action of contract,\n// tort or otherwise, arising from, out of or in connection with the Software\n// or the use or other dealings in the Software.\n// \n// MIT grants, free of charge, to any users the right to modify, copy,\n// and redistribute the Software, both within the user's organization and\n// externally, subject to the following restrictions:\n// \n// 1. The users agree not to charge for the MIT code itself but may charge\n//      for additions, extensions, or support.\n// \n// 2. In any product based on the Software, the users agree to acknowledge\n//      the MIT Computational Prototyping Research Group that developed\n//      the software. This acknowledgment shall appear in the product\n//      documentation.\n// \n// 3. The users agree to obey all U.S. Government restrictions governing\n//      redistribution or export of the software.\n// \n// 4. The users agree to reproduce any copyright notice which appears on\n//      the software on any copy or modification of such made available to others.\n// \n// Agreed to by \n// Luca Daniel, MIT\n// March 1st, 2016\n//======================================================================\n// rbtMVSSense.va\n//======================================================================\n// Modified MVS model for piezoresistive FET sensing\n// to be used with the RBT-MVS compact model\n//\n// Version: 1.0.0\n// Tested on: Cadence Spectre 15.1.0.284.isr1\n//\n// Author: Bichoy Bahr [bichoy at mit dot edu]\n// Last Modified: March 31st, 2016\n\n\n//======================================================================\n//======================================================================\n// Original MVS v 1.0.1 model preamble\n//======================================================================\n//======================================================================\n////////////////////////////////////////////////////////////////////////\n//Copyright @ 2013 Massachusetts Institute of Technology (MIT)\n \n//The terms under which the software and associated documentation (the Software) is provided are as the following:\n \n//The Software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.\n \n//MIT grants, free of charge, to any users the right to modify, copy, and redistribute the Software, both within the user's organization and externally, subject to the following restrictions:\n \n//1. The users agree not to charge for the MIT code itself but may charge for additions, extensions, or support.\n \n//2. In any product based on the Software, the users agree to acknowledge the MIT VS Model Research Group that developed the software. This acknowledgment shall appear in the product documentation.\n \n//3. The users agree to obey all U.S. Government restrictions governing redistribution or export of the software.\n \n//4. The users agree to reproduce any copyright notice which appears on the software on any copy or modification of such made available to others.\n \n//Agreed to by \n//Dimitri A. Antoniadis, MIT\n//May 27 2013\n////////////////////////////////////////////////////////////////////////\n\n// VerilogA for virtual-source (VS) based self-consistent transport/capacitance model for Si MOSFET\n// transport model:  A. Khakifirooz, et al, p. 1674, T-ED 2009.\n// charge model: L. Wei et al, p. 1263, T-ED 2012.\n// Implemented on July 15, 2013 by S. Rakheja\n// Modified on Sep. 19, 2013 by S. Rakheja\n// Modified on July 17, 2015 by S. Rakheja \n// List of changes: \n// 1. Energy transfer parameter mvss_zeta added\n// 2. Qinv definition corrected to use FF instead of FFpre\n// 3. DIBL correction normalized\n// 4. Ballistic charge calculated for linear potential profile (default) \n// 5. Inner fringing charge corrected \n// 6. Unused variables removed\n//======================================================================\n//======================================================================\n// End of Original MVS v1.0.1 model preamble\n//======================================================================\n//======================================================================\n\n`ifdef __RBT_MVS_SENSE__VA__\n`else\n`define __RBT_MVS_SENSE_VA__\n\n`include \"constants.vams\"\n`include \"disciplines.vams\"\n`include \"rbtConst.va\"\n//`include \"strainnature.vams\"\n\n\nmodule rbtMVSSense(d, g, s, b, xdisp, vss, T);\ninout d, g, s, b;\ninout xdisp, vss;\ninout T;\nelectrical d, g, s, b;\nelectrical xdisp, vss;\nthermal T;\n\n// Internal nodes\nelectrical di, si;\n\n\n/************************/\n/* Resonator Parameters */\n/************************/\nparameter real version      = 1.00;            // Model version\nparameter real rbt_pilong   = `RBT_PILONG;     // Longitudinal piezoresistivity coefficient\nparameter real rbt_wgVtoT   = `RBT_WGVTOT;     // Voltage to Stress conversion\nparameter real rbt_senseMSF = `RBT_SENSEMSF;   // mode shape factor for sensing\n\n\n/*-------End of RBT Specific Parameter-----------------*/\n\n/************************/\n/* MVS Parameters       */\n/************************/\n\n// Original VS parameters\nparameter real      mvss_version = 1.10;                                 // MVS model mvss_version = 1.0.1\nparameter integer   mvss_type    = 1            from [-1 : 1] exclude 0;// mvss_type of transistor. nFET mvss_type=1; pFET mvss_type=-1\nparameter real      mvss_W       = `MVSS_WFET   from (0:inf);           // Transistor width [cm]\nparameter real      mvss_Lgdr    = `MVSS_LFET   from (0:inf);           // Physical gate length [cm]. // This is the designed gate length for litho printing.\nparameter real      mvss_dLg     = 10.5e-7      from (0:inf);           // Overlap length including both source and drain sides [cm]  \nparameter real      mvss_Cg      = `MVSS_CG     from (0:inf);           // Gate-to-channel areal capacitance at the virtual source [F/cm^2]\nparameter real      mvss_etov    = `MVSS_EOTV   from (0:inf);           // Equivalent thickness of dielectric at S/D-G overlap [cm]\nparameter real      mvss_delta   = `MVSS_DELTA  from [0:inf);           // Drain-induced-barrier-lowering (DIBL) [V/V]\nparameter real      mvss_n0      = 1.5          from [0:inf);           // Subthreshold swing factor [unit-less] {typically between 1.0 and 2.0}\nparameter real      mvss_Rs0     = 100          from (0:inf);           // Access resistance on s-terminal [Ohms-micron]\nparameter real      mvss_Rd0     = 100          from (0:inf);           // Access resistance on d-terminal [Ohms-micron] \n\n                                                                        // Generally, mvss_Rs0 = mvss_Rd0 for symmetric source and drain\nparameter real      mvss_Cif    = 1e-12         from [0:inf);           // Inner fringing S or D capacitance [F/cm] \nparameter real      mvss_Cof    = 2e-13         from [0:inf);           // Outer fringing S or D capacitance [F/cm] \nparameter real      mvss_vxo    = 0.765e7       from (0:inf);           // Virtual source injection velocity [cm/s]\nparameter real      mvss_mu     = 200           from (0:inf);           // Low-field mobility [cm^2/V.s]\nparameter real      mvss_beta   = `MVSS_BETA    from (0:inf);           // Saturation factor. Typ. nFET=1.8, pFET=1.6\nparameter real      mvss_Tjun   = 298           from [173:inf);         // Junction temperature [K]\nparameter real      mvss_phib   = 1.2;                                  // ~abs(2*phif)>0 [V]\nparameter real      mvss_gamma  = 0.0           from [0:inf);           // Body factor  [sqrt(V)]\nparameter real      mvss_Vt0    = `MVSS_VT0;                            // Strong inversion threshold voltage [V] \nparameter real      mvss_alpha  = 3.5;                                  // Empirical parameter for threshold voltage shift between strong and weak inversion.\nparameter real      mvss_mc     = 0.2           from [0.01 : 10];       // Choose an appropriate value between 0.01 to 10 \n                                                                        // For, values outside of this range,convergence or accuracy of results is not guaranteed\nparameter integer   mvss_CTM_select = 1         from [1 : inf);         // If mvss_CTM_select = 1, then classic DD-NVSAT model is used\n                                                                        // For mvss_CTM_select other than 1,blended DD-NVSAT and ballistic charge transport model is used \nparameter real      mvss_CC     = 0     from [0:inf);                   // Fitting parameter to adjust Vg-dependent inner fringe capacitances(Not used in this mvss_version)\nparameter real      mvss_nd     = 0     from [0:inf);                   // Punch-through factor [1/V]\nparameter real      mvss_zeta   = 1.0   from (0:1];                     // Energy-transfer factor\n\n\n`define  MVSS_SMALL_VALUE  (1e-10)\n`define  MVSS_SMALL_MU     (1e-3)\n`define  MVSS_LARGE_VALUE  (40)  \n\n//************************************************************\n// Model Variables\n//************************************************************\n\n// Resonator variables\nlocalparam tanhSmooth = `RBT_MVSS_SMOOTHTANH;\nreal dmu;\nreal mobModFactor;\nreal rbt_mu;\nreal stress;\n//real absTemp; // Device absolute temperature\n\n// Original MVS model variables\nreal Rs, Rd, Vds, Vgs, Vgsraw, Vgdraw, Vbs, Vdsi, Vgsi, Vbsi, dir;\nreal Leff, me, phit;\nreal n, nphit, aphit, Vtpcorr, eVgpre, FFpre, ab, Vcorr, Vgscorr, Vbscorr, Vt0bs, Vt0bs0, Vtp, Vtp0;\nreal eVg, FF, eVg0, FF0, Qref, eta, eta0;\nreal Qinv, Qinv_corr, vx0, Vdsats, Vdsat,Vdratio, Vdbeta, Vdbetabeta, Fsat, Id ;\nreal Vgt, psis, Vgta, Vdsatq, Fsatq, x;\nreal qsc, qdc, qi, kq, kq2, kq4, tol, qsb, qdb, qs, qd, Qs, Qd;\nreal Qb, etai, Qinvi, dQinv, dibl_corr; \nreal Qinvs, Qinvd, Qsov, Qdov, Vt0x, Vt0y, Fs_arg, Fs, Fd_arg, Fd, FFx, FFy, Qsif, Qdif, Qg, a, Cofs, Cofd;\nreal A, B;\n//--------------------End of MVS Variables--------------------//\n\n//************************************************************\n// Analog Block\n//************************************************************\n\nanalog begin\n\n        // Absolute device temperature\n        //absTemp = $temperature + Temp(T);\n\n        //Voltage definitions\n        Vgsraw          =       mvss_type * ( V(g) - V(si) );\n        Vgdraw          =       mvss_type * ( V(g) - V(di) );\n        if (Vgsraw >= Vgdraw) begin\n                Vds  = mvss_type * ( V(d) - V(s) ); \n                Vgs  = mvss_type * ( V(g) - V(s) );\n                Vbs  = mvss_type * ( V(b) - V(s) );\n                Vdsi = mvss_type * ( V(di) - V(si) );\n                Vgsi = Vgsraw;\n                Vbsi = mvss_type * ( V(b) - V(si) );\n                dir  = 1;\n        end\n        else begin\n                Vds  = mvss_type * ( V(s) - V(d) );\n                Vgs  = mvss_type * ( V(g) - V(d) );\n                Vbs  = mvss_type * ( V(b) - V(d) );\n                Vdsi = mvss_type * ( V(si) - V(di) );\n                Vgsi = Vgdraw;\n                Vbsi = mvss_type * ( V(b) - V(di) );\n                dir  = -1;\n        end\n\n    //Parasitic element definition\n        Rs      = 1e-4/ mvss_W * mvss_Rs0;                             // s-terminal resistance [ohms]\n        Rd      = Rs;                                                  // d-terminal resistance [ohms] For symmetric source and drain Rd = Rs. \n        //Rd    = 1e-4/ mvss_W * mvss_Rd0;                             // d-terminal resistance [ohms] {Uncomment for asymmetric source and drain resistance.}\n        Cofs    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // s-terminal outer fringing cap [F/cm]\n        Cofd    = ( 0.345e-12/ mvss_etov ) * mvss_dLg/ 2.0 + mvss_Cof; // d-terminal outer fringing cap [F/cm]\n        Leff    = mvss_Lgdr - mvss_dLg;                                         // Effective channel length [cm]. After subtracting overlap lengths on s and d side \n        \n        phit    = $vt(mvss_Tjun);                // Thermal voltage, kT/q [V]                \n        me      = (9.1e-31) * mvss_mc;     // Carrier mass [Kg]\n        n       = mvss_n0 + mvss_nd * Vdsi;// Total subthreshold swing factor taking punchthrough into account [unit-less]\n        nphit   = n * phit;              // Product of n and phit [used as one variable]\n        aphit   = mvss_alpha * phit;     // Product of mvss_alpha and phit [used as one variable]\n\n        // **************************************************\n        // Piezoresistive sensing for RBT Models\n        // **************************************************\n        stress = (- rbt_wgVtoT) * rbt_senseMSF * V(xdisp,vss); // -ve sign for equivalent circuit convention\n        dmu = tanhSmooth * tanh( (1/tanhSmooth) * rbt_pilong * stress); // change in mobility\n        mobModFactor = (1 - dmu );\n        rbt_mu = mvss_mu * mobModFactor;\n        //--------------------End of RBT Piezoresistive Sense--------------------//\n\n        \n        //Correct Vgsi and Vbsi\n        //Vcorr is computed using external Vbs and Vgs but internal Vdsi, Qinv and Qinv_corr are computed with uncorrected Vgs, Vbs and corrected Vgs, Vbs respectively.        \n        Vtpcorr  = mvss_Vt0 + mvss_gamma * (sqrt(abs(mvss_phib - Vbs))- sqrt(mvss_phib))- Vdsi * mvss_delta;// Calculated from extrinsic Vbs\n        eVgpre   = limexp(( Vgs - Vtpcorr )/ ( aphit * 1.5 ));                          // Calculated from extrinsic Vgs\n        FFpre    = 1.0/ ( 1.0 + eVgpre );                                               // Only used to compute the correction factor\n        ab       = 2 * ( 1 - 0.99 * FFpre ) * phit;  \n        Vcorr    = ( 1.0 + 2.0 * mvss_delta ) * ( ab/ 2.0 ) * ( limexp( -Vdsi/ ab ));   // Correction to intrinsic Vgs\n        Vgscorr  = Vgsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vbscorr  = Vbsi + Vcorr;                                                        // Intrinsic Vgs corrected (to be used for charge and current computation)\n        Vt0bs    = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbscorr)) - sqrt( mvss_phib ));      // Computed from corrected intrinsic Vbs\n        Vt0bs0   = mvss_Vt0 + mvss_gamma * (sqrt( abs( mvss_phib - Vbsi)) - sqrt( mvss_phib ));         // Computed from uncorrected intrinsic Vbs\n        Vtp      = Vt0bs - Vdsi * mvss_delta - 0.5 * aphit;                             // Computed from corrected intrinsic Vbs and intrinsic Vds\n        Vtp0     = Vt0bs0 - Vdsi * mvss_delta - 0.5 * aphit;                            // Computed from uncorrected intrinsic Vbs and intrinsic Vds\n        eVg      = limexp(( Vgscorr - Vtp )/ ( aphit ));                                // Compute eVg factor from corrected intrinsic Vgs\n        FF       = 1.0/ ( 1.0 + eVg );\n        eVg0     = limexp(( Vgsi - Vtp0 )/ ( aphit ));                                  // Compute eVg factor from uncorrected intrinsic Vgs\n        FF0      = 1.0/ ( 1.0 + eVg0 );\n        Qref     = mvss_Cg * nphit;     \n        eta      = ( Vgscorr - ( Vt0bs - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );  // Compute eta factor from corrected intrinsic Vgs and intrinsic Vds\n        eta0     = ( Vgsi - ( Vt0bs0 - Vdsi * mvss_delta - FF * aphit ))/ ( nphit );    // Compute eta0 factor from uncorrected intrinsic Vgs and internal Vds. \n                                                                                        // Using FF instead of FF0 in eta0 gives smoother capacitances.\n\n        //Charge at VS in saturation (Qinv)\n        if (eta  <= `MVSS_LARGE_VALUE) begin\n                Qinv_corr = Qref * ln( 1.0 + limexp(eta) );\n        end\n        else begin\n                Qinv_corr = Qref * eta;\n        end     \n        if (eta0 <= `MVSS_LARGE_VALUE) begin \n                Qinv     = Qref * ln( 1.0 + limexp(eta0) );                             // Compute charge w/ uncorrected intrinsic Vgs for use later on in charge partitioning\n        end\n        else    begin\n                Qinv     = Qref * eta0;\n        end\n\n\n        //Transport equations\n        vx0             = mvss_vxo;     \n        Vdsats          = vx0 * Leff * limexp( - ln(rbt_mu) );                                                  \n        Vdsat           = Vdsats * ( 1.0 - FF ) + phit * FF;                            // Saturation drain voltage for current\n        Vdratio         = abs( Vdsi/ Vdsat);\n        Vdbeta          = pow( Vdratio, mvss_beta);\n        Vdbetabeta      = pow( 1.0 + Vdbeta, 1.0/ mvss_beta);\n        Fsat            = Vdratio / Vdbetabeta;                                         // Transition function from linear to saturation. \n                                                                                                        // Fsat = 1 when Vds>>Vdsat; Fsat= Vds when Vds<<Vdsat\n\n        //Total drain current                                                                           \n        Id                      =       Qinv_corr * vx0 * Fsat * mvss_W;                \n\n\n        //Calculation of intrinsic charge partitioning factors (qs and qd)\n        Vgt                     =       Qinv/ mvss_Cg;                                                  // Use charge computed from uncorrected intrinsic Vgs\n\n        // Approximate solution for psis is weak inversion\n        if (mvss_gamma == 0) begin\n                a               =       1.0;\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin\n                        psis    =       mvss_phib + phit * ( 1.0 + ln( eta0 ));\n                end\n        end\n        else begin\n                if (eta0 <= `MVSS_LARGE_VALUE) begin\n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( ln( 1.0 + `MVSS_SMALL_VALUE + limexp( eta0 ))));\n                end\n                else begin      \n                        psis    =       mvss_phib + ( 1.0 - mvss_gamma )/ ( 1.0 + mvss_gamma ) * phit * ( 1.0 + ln( eta0 ));\n                end\n                a               =       1.0 + mvss_gamma/ ( 2.0 * sqrt( abs( psis - ( Vbsi ))));\n        end\n        Vgta                    =       Vgt/ a;                                                         // Vdsat in strong inversion\n        Vdsatq                  =       sqrt( FF0 * aphit * aphit + Vgta * Vgta);                       // Vdsat approx. to extend to weak inversion; \n                                                                                                        // The multiplier of phit has strong effect on Cgd discontinuity at Vd=0.\n\n        // Modified Fsat for calculation of charge partitioning\n        //DD-NVSAT charge\n        Fsatq                   =       abs( Vdsi/ Vdsatq )/ ( pow( 1.0 + pow( abs( Vdsi/ Vdsatq ), mvss_beta ), 1.0/ mvss_beta ));\n        x                       =       1.0 - Fsatq;\n        \n\n         // MVS 1.0.1 release uses Tsividis model for implementing DD-NVSAT charges. \n        // In MVS 1.1.0, we use the formulation from L. Wei's 2012 TED paper referenced in the documentation. \n        // Both models are identical. \n\n        // *** From Tsividis (DD-NVSAT)\n        // den                  =       15 * ( 1 + x ) * ( 1 + x );\n        // qsc                  =       Qinv *(6 + 12 * x + 8 * x * x + 4 * x * x * x)/ den;\n        // qdc                  =       Qinv *(4 + 8 * x + 12 * x * x + 6 * x * x * x)/ den;\n        // qi                   =       qsc + qdc;                                                      //      Charge in the channel \n\n        // *** From L. Wei (DD-NVSAT)\n    A = pow((1-x),2)/(12.0*(1-(1-x)/2.0));\n        B = (5.0-2.0*(1-x))/(10.0-(1-x)/2.0);\n        qsc = Qinv*(0.5-(1-x)/6.0+A*(1-B));\n        qdc = Qinv*(0.5-(1-x)/3.0+A*B);\n        qi = qsc+qdc;\n\n                \n\n        //QB charge     \n        //kq                    =       0.0;\n        tol                     =       ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * ( `MVSS_SMALL_VALUE * mvss_vxo/ 100.0 ) * me/ ( 2 * `P_Q );\n        if (Vdsi <= tol) begin\n                kq2             =       ( 2.0 * `P_Q/ me * Vdsi * mvss_zeta)/ ( vx0 * vx0 ) * 10000.0;\n                kq4             =       kq2 * kq2;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (0.5 - kq2/12.0 +kq4/32.0);\n                qdb             =       Qinv * (0.5 - kq2/6.0 +3.0*kq4/32.0);\n                \n                // Uncomment following lines for parabolic potential profile\n                //qsb           =       Qinv * ( 0.5 - kq2/ 24.0 + kq4/ 80.0 );\n                //qdb           =       Qinv * ( 0.5 - 0.125 * kq2 + kq4/ 16.0 );\n        end\n        else begin      \n                kq              =       sqrt( 2.0 * `P_Q/ me * Vdsi * mvss_zeta )/ vx0 * 100.0;\n                kq2             =       kq * kq;\n                \n                // Uncomment following lines for linear potential profile\n                qsb             =       Qinv * (4.0*(kq2+1.0)*sqrt(kq2+1.0)-(6.0*kq2+4.0))/(3.0*kq2*kq2); \n                qdb             =       Qinv * (2.0*(kq2-2)*sqrt(kq2+1.0)+4.0)/(3.0*kq2*kq2);\n\n                // Uncomment following lines for parabolic potential profile\n                // qsb          =       Qinv * ( asinh( kq )/ kq - ( sqrt( kq2 + 1.0 ) - 1.0 )/ kq2);\n                // qdb          =       Qinv * (( sqrt( kq2 + 1.0 )- 1.0 )/ kq2);\n        end\n        \n\n        // Flag for classic or ballistic charge partitioning:\n        if (mvss_CTM_select == 1) begin                                                                 // Ballistic blended with classic DD-NVSAT\n                qs              =       qsc;                                                            // Calculation of \"ballistic\" channel charge partitioning factors, qsb and qdb.\n                qd              =       qdc;                                                            // Here it is assumed that the potential increases parabolically from the\n        end                                                                                             // virtual source point, where Qinv_corr is known to Vds-dvd at the drain.\n        else begin                                                                                      // Hence carrier velocity increases linearly by kq (below) depending on the\n                qs              =       qsc * ( 1 - Fsatq * Fsatq ) + qsb * Fsatq * Fsatq;              // efecive ballistic mass of the carriers.\n                qd              =       qdc * ( 1 - Fsatq * Fsatq ) + qdb * Fsatq * Fsatq;                              \n        end                                                                                             \n                                                                                                        \n                                                                \n        //Body charge based on approximate surface potential (psis) calculation with mvss_delta=0 using psis=mvss_phib in Qb gives continuous Cgs, Cgd, Cdd in SI, while Cdd is smooth anyway.\n        Qb                      =       -mvss_type * mvss_W * Leff * ( mvss_Cg * mvss_gamma * sqrt( abs( psis - Vbsi )) + ( a - 1.0 )/ ( 1.0 * a ) * Qinv * ( 1.0 - qi ));\n\n\n        //DIBL effect on drain charge calculation.\n        //Calculate dQinv at virtual source due to DIBL only. Then:Correct the qd factor to reflect this channel charge change due to Vd\n        //Vt0bs0 and FF=FF0 causes least discontinuity in Cgs and Cgd but produces a spike in Cdd at Vds=0 (in weak inversion.  But bad in strong inversion)\n        etai                    =       ( Vgsi - ( Vt0bs0 - FF * aphit ))/ ( nphit );\n        if (etai <= `MVSS_LARGE_VALUE) begin\n                Qinvi           =       Qref * ln( 1.0 + limexp( etai ));\n        end\n        else begin\n                Qinvi           =       Qref * etai;\n        end\n        dQinv                   =       Qinv - Qinvi;\n        dibl_corr               =       ( 1.0 - FF0 ) * ( 1.0 - Fsatq ) * qi * dQinv/Qinv;\n        qd                      =       qd - dibl_corr;\n\n                 \n        //Inversion charge partitioning to terminals s and d\n        Qinvs                   =       mvss_type * Leff * (( 1 + dir ) * qs + ( 1 - dir ) * qd)/ 2.0;\n        Qinvd                   =       mvss_type * Leff * (( 1 - dir ) * qs + ( 1 + dir ) * qd)/ 2.0;\n\n\n        //Outer fringing capacitance\n        Qsov                    =       Cofs * ( V(g) - V(si) );\n        Qdov                    =       Cofd * ( V(g) - V(di) );\n\n\n        //Inner fringing capacitance\n        Vt0x                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(si) ))) - sqrt(mvss_phib));\n        Vt0y                    =       mvss_Vt0 + mvss_gamma * ( sqrt( abs( mvss_phib - mvss_type * ( V(b) - V(di) ))) - sqrt(mvss_phib));\n        Fs_arg                  =       ( Vgsraw - ( Vt0x - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fs_arg <= `MVSS_LARGE_VALUE) begin\n                Fs              =       1.0 + limexp( Fs_arg );\n                FFx             =       Vgsraw - nphit * ln( Fs );\n        end\n        else begin\n                Fs              =       0.0;                                                            // Not used\n                FFx             =       Vgsraw - nphit * Fs_arg;\n        end\n        Fd_arg                  =       ( Vgdraw - ( Vt0y - Vdsi * mvss_delta * Fsat ) + aphit * 0.5 )/ ( 1.1 * nphit );\n        if (Fd_arg <= `MVSS_LARGE_VALUE) begin\n                Fd              =       1.0 + limexp( Fd_arg );\n                FFy             =       Vgdraw - nphit * ln( Fd );\n        end\n        else begin\n                Fd              =       0.0;                                                            // Not used\n                FFy             =       Vgdraw - nphit * Fd_arg;\n        end\n        Qsif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgsraw ) * FFx;\n        Qdif                    =       ( mvss_type * mvss_Cif + mvss_CC * Vgdraw ) * FFy;\n                \n        \n        //Partitioned charge\n        Qs                      =       -mvss_W * ( Qinvs + Qsov + Qsif );              // s-terminal charge\n        Qd                      =       -mvss_W * ( Qinvd + Qdov + Qdif );              // d-terminal charge\n        Qg                      =       -( Qs + Qd + Qb );                                              // g-terminal charge\n\n\n        //Sub-circuit initialization\n        I(di,si)                <+      mvss_type * dir * Id;\n        I(d,di)                 <+      ( V(d) - V(di) )/ Rd;\n        I(si,s)                 <+      ( V(si) - V(s) )/ Rs;\n\n        I(si,b)                 <+      ddt( Qs );                                                      // charge term: node si to node b\n        I(di,b)                 <+      ddt( Qd );                                                      // charge term: node di to node b\n        I(g,b)                  <+      ddt( Qg );                                                      // charge term: node g to node b\n\n        // Thermal contribution to the thermal node\n        Pwr(T) <+ -Vds * Id - V(g,b) * ddt(Qg);\n\nend\nendmodule\n\n`endif\n```\n Please correct the code based on the input error code, paying attention to functional and syntactic accuracy."
      },
      {
        "role": "user",
        "content": "Please correct the problematic Verilog-A code below:\nFs              =       0.0                                                            // Not used Please provide the corrected code and the Correction Criteria."
      },
      {
        "role": "assistant",
        "content": "corrected code：\nFs              =       0.0;                                                            // Not used\n\n Correction Criteria：Missing semicolon at the end of the assignment statement"
      }
    ]
  }
]